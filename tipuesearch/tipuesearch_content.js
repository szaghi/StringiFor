var tipuesearch = {"pages":[{"title":" StringiFor ","text":"StringiFor StringiFor StringiFor, Strings Fortran Manipulator, yet another strings Fortran module A KISS pure Fortran library providing  astrings (class) manipulator for modern (2003+) Fortran projects. StringiFor is a pure Fortran (KISS) library providing a strings manipulator for modern Fortran projects; StringiFor is Fortran 2003+ standard compliant; StringiFor is OOP designed; StringiFor is TDD designed; StringiFor is a Free, Open Source Project. Issues Compiler Support What is StringiFor? | Main features | Copyrights | Download | Compilation | Documentation | Comparison to other Approaches What is StringiFor? Modern Fortran standards (2003+) have introduced a better support for characters variables, but Fortraners still do not have the power on dealing with strings of other more-rich-programmers, e.g. Pythoners. Allocatable deferred length character variables are now quantum-leap with respect the old inflexible Fortran characters, but it is still not enough for many Fortraners. Moreover, Fortran does not provide builtin methods for widely used strings manipulations offered by other languages, e.g. UPPER/lowercase transformation, tokenization, etc… StringiFor attempts to fill this lack. Go to Top Main features StringiFor exposes only one class (OO-designed), the string type, that should be used as a more powerful string variable with respect a standard Fortran character variable. The main features of this class are: [x] seamless interchangeability with standard character variables, e.g. concatenation, IO, etc…; [x] handy builtin methods, e.g. split, search, basename, join, etc…; [x] low memory consumption: only one deferred length allocatable character member is stored, allowing for efficient memory allocation in array of strings, the elements of which can have different lengths; [x] safe: almost all methods are elemental or pure; [x] robust: the library is Test Driven Developed TDD , a comprehensive tests suite is provided. Any feature request is welcome. Go to Top A Taste of StringiFor StringiFor is very handy… Basic IO String manipulation Numbers handling Complex scenario Basic IO The class string IO is overloaded by defined write/read TBP. Moreover, dedicated methods and operators can be exploited for IO, e.g. use stringifor type ( string ) :: astring astring = 'Hello World' print \"(A)\" , astring % chars () ! \"chars\" method returns a standard character variable print \"(DT)\" , astring ! defined IO (in gfortran is available for GNU GCC >= 7.1) print \"(A)\" , astring // '' ! on-the-fly conversion to standard character by means of concatenation String manipulation The class string has many methods for a plethora of strings manipulations, e.g. use stringifor type ( string ) :: astring type ( string ) :: strings ( 3 ) astring = '0123456789' print \"(A)\" , astring % reverse () // '' ! print \"9876543210\" astring = 'Hello World' print \"(A)\" , astring % replace ( old = 'World' , new = 'People' ) // '' ! print \"Hello People\" astring = 'Hello World' strings = astring % partition ( sep = 'lo Wo' ) print \"(A)\" , 'Before sep: \"' // strings ( 1 ) // '\"' ! print \"Hel\" print \"(A)\" , 'Sep itself: \"' // strings ( 2 ) // '\"' ! print \"lo Wo\" print \"(A)\" , 'After sep:  \"' // strings ( 3 ) // '\"' ! print \"rld\" strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' print \"(A)\" , astring % join ( strings ) // '' ! print \"oneHello WorldtwoHello Worldthree\" print \"(A)\" , astring % join ( strings , sep = '-' ) // '' ! print \"one-two-three\" astring = ' a StraNgE caSe var' print \"(A)\" , astring % camelcase () // '' ! print \" AStrangeCaseVar\" print \"(A)\" , astring % snakecase () // '' ! print \" a_strange_case_var\" print \"(A)\" , astring % startcase () // '' ! print \" A Strange Case Var\" Numbers handling StringiFor, by means of the portability environment library, PENF can handle numbers (reals and integers) effortless. The string/number casting (to/from and viceversa) is done by overloaded assignments (for all kinds of integers and reals). For convenience, StringiFor exposes the PENF number portable kind parameters. use stringifor type ( string ) :: astring astring = 127 _ I1P ! \"I1P\" is the PENF kind for 1-byte-like integer. print \"(A)\" , astring // '' ! print \"+127\" astring = 3.021e6_R4P ! \"R4P\" is the PENF kind for 4-byte-like real. print \"(A)\" , astring // '' ! print \"+0.302100E+07\" astring = \"3.4e9\" ! assign to a string without the necessity to define a real kind if ( astring % is_number ()) then if ( astring % is_real ()) then print \"(E13.6)\" , astring % to_number ( kind = 1._R4P ) ! print \" 0.340000E+10\" using a 4-byte-like kind endif endif Complex scenario StingiFor is developed to improve the poor Fortran people with daily strings-usage, however, also complex scenario is taken into account, e.g. file parsing, OS operations, etc… use stringifor type ( string ) :: astring ! OS like manipulation astring = '/bar/foo.tar.bz2' print \"(A)\" , astring % basedir () // '' ! print \"/bar\" print \"(A)\" , astring % basename () // '' ! print \"foo.tar.bz2\" print \"(A)\" , astring % basename ( extension = '.tar' ) // '' ! print \"foo\" print \"(A)\" , astring % basename ( strip_last_extension = . true .) // '' ! print \"foo.tar\" ! XML like tag parsing astring = '<test> <first> hello </first> <first> not the first </first> </test>' print \"(A)\" , astring % search ( tag_start = '<first>' , tag_end = '</first>' ) // '' ! print \"<first> hello </first>\" A naive CSV parser This is just a provocation, but with StringiFor it is easy to develop a naive CSV parser. Let us assume we want to parse a cars-price database as the following one Year, Make, Model, Description, Price\n1997, Ford, E350   , ac abs moon, 3000.00\n1999, Chevy, Venture \"Extended Edition\"  , , 4900.00\n1999, Chevy, Venture \"Extended Edition Very Large\", , 5000.00 Well, parsing it and handling its cells values is very easy by means of StringiFor use stringifor implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. type ( string ) :: most_expensive !< The most expensive car. real ( R8P ) :: highest_cost !< The highest cost. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: r !< Counter. ! parsing the just created CSV file: all done 9 statements! call csv % read_file ( file = 'cars.csv' ) ! read the CSV file as a single stream call csv % split ( tokens = rows , sep = new_line ( 'a' )) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' print \"(A)\" , '|' // repeat ( '----|' , size ( columns )) ! printing separators do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' ! find the most expensive car print \"(A)\" , 'Searching for the most expensive car' most_expensive = 'unknown' highest_cost = - 1._R8P do r = 2 , rows_number if ( cells ( 5 , r )% to_number ( kind = 1._R8P ) >= highest_cost ) then highest_cost = cells ( 5 , r )% to_number ( kind = 1._R8P ) most_expensive = csv % join ( array = [ cells ( 2 , r ), cells ( 3 , r )], sep = ' ' ) endif enddo print \"(A)\" , 'The most expensive car is : ' // most_expensive See the test program csv_naive_parser for a working example. Obviously, this is a naive parser without any robustness, but it proves the usefulness of the StringiFor approach. Go to Top Copyrights StringiFor is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to StringiFor is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Download StringiFor home is at https://github.com/szaghi/StringiFor . It uses git submodule to handle the third party dependencies. To download all the source files you can: clone this repository (all dependencies are satisfied): git clone https://github.com/szaghi/StringiFor cd StringiFor git submodule update --init download only the StringiFor sources, all other dependencies must be downloaded manually: download the latest master-branch archive: wget https://github.com/szaghi/StringiFor/archive/master.zip unzip StringiFor-master.zip cd StringiFor-master git submodule update --init download a release archive at https://github.com/szaghi/StringiFor/releases Third Party dependencies Currently StringiFor depends on: FACE PENF BeFoR64 The third party libraries are necessary for building StringiFor. StringiFor is constantly made up-to-date with third party libraries master branch or their latest release. If you download a release of StringiFor manually (without git) you must download manually the above dependencies and place them into src/third_party sub-directory of the project root-tree. Go to Top Compilation StringiFor is a modern Fortran project thus a modern Fortran compiler is need to compile the project. In the following table the support for some widely-used Fortran compilers is summarized. Compiler Vendor Support Notes full support full support not tested not tested not tested not tested The library is modular, namely it exploits Fortran modules. As a consequence, there is compilation-cascade hierarchy to build the library. To correctly build the library the following approaches are supported Build by means of FoBiS : full support; Build by means of GNU Make : support for GNU Make is not provided, a Makefile is provided, but it is likely outdated and could not work as expected. Help for maintaining GNU Make support is strongly welcome, feel free to join this progect. Build by means of CMake : support for CMake is not provide, some CMake support is provided by great users, but it could be outdated. Help for maintaining CMake support is strongly welcome, feel free to join this progect. The FoBiS building support is the most complete and the only one officially supported by the author, as it is the one used for the developing StringiFor. Build by means of FoBiS A fobos file is provided to build the library by means of the Fortran Building System FoBiS . Build all tests Type FoBiS.py build After (a successuful) building a directory ./exe is created containing all the compiled tests that constitute the StringiFor regression-tests-suite , e.g. → FoBiS.py build\nBuilder options\nDirectories Building directory: \"exe\" Compiled-objects .o directory: \"exe/obj\" Compiled-objects .mod directory: \"exe/mod\" Compiler options Vendor: \"gnu\" Compiler command: \"gfortran\" Module directory switch: \"-J\" Compiling flags: \"-c -frealloc-lhs -std=f2008 -fall-intrinsics -O2 -Dr16p\" Linking flags: \"-O2\" Preprocessing flags: \"-Dr16p\" Coverage: False Profile: False\nPreForM.py used: False\nPreForM.py output directory: None\nPreForM.py extensions processed: [] Building src/tests/is_real.f90\nCompiling src/lib/penf.F90 serially\nCompiling src/lib/string_t.F90 serially\nCompiling src/lib/stringifor.F90 serially\nCompiling src/tests/is_real.f90 serially\nLinking exe/is_real\nTarget src/tests/is_real.f90 has been successfully built\nBuilder options Directories Building directory: \"exe\" Compiled-objects .o directory: \"exe/obj\" Compiled-objects .mod directory: \"exe/mod\" Compiler options Vendor: \"gnu\" Compiler command: \"gfortran\" Module directory switch: \"-J\" Compiling flags: \"-c -frealloc-lhs -std=f2008 -fall-intrinsics -O2 -Dr16p\" Linking flags: \"-O2\" Preprocessing flags: \"-Dr16p\" Coverage: False Profile: False PreForM.py used: False PreForM.py output directory: None PreForM.py extensions processed: [] Building src/tests/slen.f90\nCompiling src/tests/slen.f90 serially\n...\n\n→ tree -L 1 exe/\nexe/\n├── assignments\n├── basename_dir\n├── camelcase\n├── capitalize\n├── concatenation\n├── equal\n├── escape\n├── extension\n├── fill\n...\n├── swapcase\n├── to_number\n├── unique\n└── upper_lower Build the library Type # static-linked library by means of GNU gfortran FoBiS.py build -mode stringifor-static-gnu # shared-linked library by means of GNU gfortran FoBiS.py build -mode stringifor-shared-gnu # static-linked library by means of Intel Fortran FoBiS.py build -mode stringifor-static-intel # shared-linked library by means of Intel Fortran FoBiS.py build -mode stringifor-shared-intel The library will be built into the directory ./lib . List other fobos modes To list all fobos-provided modes type → FoBiS.py build -lmodes\nThe fobos file defines the following modes: - \"tests-gnu\" - \"tests-gnu-debug\" - \"tests-intel\" - \"tests-intel-debug\" - \"stringifor-static-gnu\" - \"stringifor-shared-gnu\" - \"stringifor-static-intel\" - \"stringifor-shared-intel\" It is worth to note that the first mode is the one automatically called by FoBiS.py build . Build by means of GNU Make The provided makefile support only static-linked library building (not shared one) with both Intel Fortran Compiler and GNU gfortran, and it has two main building rules: build the (static linked) library; build the tests suite. the GNU gfortran compiler is the default one, but the compiler used can be customized with COMPILER=#vendor switch. To build the library type with the GNU gfortran compiler. make The library will be built into the directory ./lib/libstringifor.a . To build the tests suite type make TESTS = yes The tests will be built into the directory ./exe . If you want to use Intel Fortran Compiler add the switch COMPILER=intel to the above commands, i.e. make COMPILER = intel # build only the library make COMPILER = intel TESTS = yes # build the tests suite Build by means of CMake To be done. Go to Top Documentation The StringiFor documentation is mainly contained into this file (it has its own wiki with some less important documents). Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Methods API In the following all the methods of string are listed with a brief description of their aim. The hyperlinks bring you to the full API explained into the GH pages. built-ins replacements name meaning adjustl adjustl replacement adjustr adjustr replacement count count replacement index index replacement len len replacement len_trim len_trim replacement repeat repeat replacement scan scan replacement trim trim replacement verify verify replacement auxiliary methods name meaning basedir return the base directory name of a string containing a file name basename return the base file name of a string containing a file name camelcase return a string with all words capitalized without spaces capitalize return a string with its first character capitalized and the rest lowercased chars return the raw characters data decode decode string encode encode string escape escape backslashes (or custom escape character) extension return the extension of a string containing a file name fill pad string on the left (or right) with zeros (or other char) to fill width free free dynamic memory insert insert substring into string at a specified position join return a string that is a join of an array of strings or characters lower return a string with all lowercase characters partition split string at separator and return the 3 parts (before the separator and after) read_file read a file a single string stream read_line read line (record) from a connected unit read_lines read (all) lines (records) from a connected unit as a single ascii stream replace return a string with all occurrences of substring old replaced by new reverse return a reversed string search search for tagged record into string slice return the raw characters data sliced snakecase return a string with all words lowercase separated by _ split return a list of substring in the string using sep as the delimiter string startcase return a string with all words capitalized, e.g. title case strip return a string with the leading and trailing characters removed swapcase return a string with uppercase chars converted to lowercase and vice versa tempname return a safe temporary name suitable for temporary file or directories to_number cast string to number unescape unescape double backslashes (or custom escaped character) unique reduce to one (unique) multiple occurrences of a substring into a string upper return a string with all uppercase characters write_file write a single string stream into file write_line write line (record) to a connected unit write_lines write lines (records) to a connected unit inquire methods name meaning end_with return true if a string ends with a specified suffix is_allocated return true if the string is allocated is_digit return true if all characters in the string are digits is_integer return true if the string contains an integer is_lower return true if all characters in the string are lowercase is_number return true if the string contains a number (real or integer) is_real return true if the string contains an real is_upper return true if all characters in the string are uppercase start_with return true if a string starts with a specified prefix operators name meaning assignment assignment of string from different inputs // concatenation resulting in characters for seamless integration .cat. concatenation resulting in string == equal operator /= not equal operator < lower than operator <= lower equal than operator >= greater equal than operator > greater than operator IO name meaning read(formatted) formatted input write(formatted) formatted output read(unformatted) unformatted input write(unformatted) unformatted output Go to Top Comparison to other Approaches The lack of Fortran support for strings manipulation has promoted different solutions in the past years. Following the classification of Clive Page 1 (#clive-page-talk) we can consider: standard character type; deferred-length allocatable character type (standard 2003+); VARYING_STRING type (standard 90/95+) as defined in ISO/IEC 1539-2:2000 (Varying length character strings). Let us compare StringiFor to the previous three approaches. In particular, let us consider Ian Harvey extension of VARYING_STRING , i.e. the aniso_varying_string 2 (#aniso_vstring). Clive Page had pointed out the following issues, among the others: fixed (at compile time) string length character ( len = 3 ) :: astring ! further lengths different from 3 are not allowed silent truncation on assignment character ( len = 3 ) :: astring astring = 'abcdefgh' ! silent trunctation at 'abc' trim-cluttered code character ( len = 99 ) :: astring character ( len = 99 ) :: anotherstring astring = 'abcdefgh' anotherstring = trim ( astring ) // 'ilmnopqrst' ! trim-cluttering is a necessity handle significant trailing spaces character ( len = 99 ) :: astring character ( len = 99 ) :: anotherstring astring = 'Hello ' ! for some reasons you want to keep these trailing white spaces anotherstring = trim ( astring ) // 'World' ! you need trim because ! len(astring)==len(anotherstring), but lost the significant ! trailing spaces... different character definition character :: astring * 10 ! old way character ( len = 10 ) :: anotherstring ! new way allocation of array of strings character ( len = 10 ), allocatable :: astring (:) allocate ( astring ( 100 )) ! all 100 elements of the array have 10 characters, ! different lengths cannot be declared initialization of array of strings ! the following is illegal character ( len = 9 ), parameter :: day ( 7 ) = [ 'Monday' , & 'Tuesday' , & 'Wednesday' , & 'Thursday' , & 'Friday' , & 'Saturday' , & 'Sunday' ] ! the following is legal, but cluttered by non significant trailing spaces character ( len = 9 ), parameter :: day ( 7 ) = [ 'Monday   ' , & 'Tuesday  ' , & 'Wednesday' , & 'Thursday ' , & 'Friday   ' , & 'Saturday ' , & 'Sunday' ] IO limitations for non standard character variables character ( len = 99 ) :: astring character ( len = :), allocatable :: anotherstring type ( varying_string ) :: yetanotherstring ! fully-simple support for standard character variables astring = 'abcdefgh' print * , astring print \"(A)\" , astring read ( 10 , * ) astring ! partial-simple support for standard deferred length-length allocatable character variables ! care must be placed in input operation... print * , anotherstring print \"(A)\" , anotherstring read ( 10 , * ) anotherstring ! support depends on the implementation of the varying string type print * , yetanotherstring print \"(DT)\" , yetanotherstring read ( 10 , * ) yetanotherstring substring notation (slice)  for non standard character variables character ( len = 99 ) :: astring character ( len = :), allocatable :: anotherstring type ( varying_string ) :: yetanotherstring astring = 'abcdefgh' yetanotherstring = astring anotherstring = astring ( 2 : 6 ) ! allowed anotherstring = yetanotherstring ( 2 : 6 ) ! not allowed passing string to procedures expecting standard character argument is complicated Analyzing the above issues we can agree that deferred-length allocatable character and aniso_varyng_string approaches address many of them, at the cost of introducing some oddies. deferred-length allocatable character This approaches addresses all the issues related to the fixed length limitation, e.g. character ( len = :), allocatable :: astring character ( len = :), allocatable :: anotherstring astring = 'Hello ' anotherstring = astring // 'World' ! trailing with spaces of astring correctly handled ! no need of trim However, it has some limitations too. Aside the input operation, the most important (IMHO) are related to arrays of strings handling, e.g. character ( len = :), allocatable :: asetofstring (:) allocate ( character ( len = 99 ) :: asetofstring ( 10 )) ! all 10 elements must have len=99 aniso_varying_string Aniso_varying_string is an implemention of ISO/IEC 1539-2:2000 (Varying length character strings) developed by Ian Harvey that is internally based on a deferred-lenght allocatable character variable: it is essentially a derived type wrapping a deferred-lenght allocatable character. As a consequence, it has all the advantages of the deferred-length allocatable character approach. The wrapping approach addresses the arrays related issues, e.g. type ( varying_string ), allocatable :: asetofstring (:) allocate ( asetofstring ( 10 )) ! all 10 elements can have diffent lengths Its major issues are related to IO operations: however, this is addressed by new Fortran support for defined IO for derived type that make more effortless the IO of such an object. The other main issue is the impossibility to use the standard slice notation to access to substring: aniso_varying_string addresses (partially) this issue by public-exposing the wrapped allocatable character of its implementations thus allowing the slicing of it, e.g. type ( varying_string ) :: astring astring = 'abcdefg' print \"(A)\" , astring % chars ( 2 : 3 ) ! print 'bc' StringiFor StringiFor shares the same philosophy of aniso_varying_string, thut it has the same pros and cons. However, StringiFor is an Object Oriented Designed class, thus it has some peculiariaties distinguishing it from aniso_varying_string, see StringiFor Peculiarities . Comparison results The following table summarizes the comparison analysis. issue standard character deferred-length allocatable character aniso_varying_string StringiFor fixed length :cloud: :sunny: :sunny: :sunny: silent trunction :cloud: :sunny: :sunny: :sunny: trim-clutter :cloud: :sunny: :sunny: :sunny: significant trailing spaces :cloud: :sunny: :sunny: :sunny: different string definition :cloud: :cloud: :sunny: :sunny: array allocatation :cloud: :cloud: :sunny: :sunny: array initialization :cloud: :cloud: :sunny: :sunny: IO :sunny: :sunny: :partly_sunny: :partly_sunny: substring (slice) notation :sunny: :sunny: :partly_sunny: :partly_sunny: Fortran builtins :sunny: :sunny: :partly_sunny: :partly_sunny: legend symbol meaning :cloud: bad or no support :partly_sunny: partial support :sunny: good support StringiFor Peculiarities StringiFor publics an OOD class, the string object. This class is aimed to address all the issues of the standard character type, as ISO Varying String approaches do, but it is also designed to provide a features-rich string object as you can find on other languages like Python. As a matter of facts, the auxiliary methods added to the string object consitute a long list of new (for Fortraners) string-facilities, allowing you to handle strings effortless (cases-conversion, files-handling, encode/decode, numbers-casting, etc…), see the complete API . It is worth to note that StringiFor is a tentative to adopt an fully OOD thus all methods and operators are TBP defined: to use StringiFor you can import only the string type, allowing a sane and robust names space handling. Only in the case you want the Fortran builtins to accept a string instead of a standard character type, e.g. to use index(astring, 'c') seamless with both a type(string) :: astring and a character(99) :: astring , you must use all the StringiFor public objects, including the overloaded interfaces of the Fortran builtins. References [1] Improved String-handling in Fortran , Clive Page, October 2015. [2] aniso_varying_string , Ian Harvey, 2016. Go to Top Developer Info Stefano Zaghi","tags":"home","loc":"index.html"},{"title":"string – StringiFor ","text":"type, public :: string OOP designed string class. Components Type Visibility Attributes Name Initial character(kind=CK, len=:), public, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: adjustl => sadjustl Adjustl replacement. private elemental function sadjustl (self) result(adjusted) Left adjust a string by removing leading spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. procedure, public, pass(self) :: adjustr => sadjustr Adjustr replacement. private elemental function sadjustr (self) result(adjusted) Right adjust a string by removing leading spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. procedure, public, pass(self) :: count => scount Count replacement. private elemental function scount (self, substring, ignore_isolated) result(No) Count the number of occurences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore “isolated” occurrences. Return Value integer Number of occurrences. generic, public :: index => sindex_string_string , sindex_string_character Index replacement. private elemental function sindex_string_string (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sindex_string_character (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, public, pass(self) :: len => slen Len replacement. private elemental function slen (self) result(l) Return the length of a string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. procedure, public, pass(self) :: len_trim => slen_trim Len_trim replacement. private elemental function slen_trim (self) result(l) Return the length of a string, ignoring any trailing blanks. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. generic, public :: repeat => srepeat_string_string , srepeat_character_string Repeat replacement. private elemental function srepeat_string_string (self, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. private elemental function srepeat_character_string (rstring, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. generic, public :: scan => sscan_string_string , sscan_string_character Scan replacement. private elemental function sscan_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, public, pass(self) :: trim => strim Trim replacement. private elemental function strim (self) result(trimmed) Remove trailing spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. generic, public :: verify => sverify_string_string , sverify_string_character Verify replacement. private elemental function sverify_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, public, pass(self) :: basedir Return the base directory name of a string containing a file name. private elemental function basedir (self, sep) Return the base directory name of a string containing a file name. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. procedure, public, pass(self) :: basename Return the base file name of a string containing a file name. private elemental function basename (self, sep, extension, strip_last_extension) Return the base file name of a string containing a file name. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Directory separator. character(kind=CK, len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. procedure, public, pass(self) :: camelcase Return a string with all words capitalized without spaces. private elemental function camelcase (self, sep) Return a string with all words capitalized without spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. private elemental function capitalize (self) result(capitalized) Return a string with its first character capitalized and the rest lowercased. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. procedure, public, pass(self) :: chars Return the raw characters data. private pure function chars (self) result(raw) Return the raw characters data. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK, len=:), allocatable Raw characters data. generic, public :: colorize => colorize_str Colorize and stylize strings. private pure function colorize_str (self, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, DEFAULT kind. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:), allocatable Colorized string. procedure, public, pass(self) :: decode Decode string. private elemental function decode (self, codec) result(decoded) Return a string decoded accordingly the codec. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. procedure, public, pass(self) :: encode Encode string. private elemental function encode (self, codec) result(encoded) Return a string encoded accordingly the codec. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. procedure, public, pass(self) :: escape Escape backslashes (or custom escape character). private elemental function escape (self, to_escape, esc) result(escaped) Escape backslashes (or custom escape character). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK, len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. procedure, public, pass(self) :: extension Return the extension of a string containing a file name. private elemental function extension (self) Return the extension of a string containing a file name. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. procedure, public, pass(self) :: fill Pad string on the left (or right) with zeros (or other char) to fill width. private elemental function fill (self, width, right, filling_char) result(filled) Pad string on the left (or right) with zeros (or other char) to fill width. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK, len=1), intent(in), optional :: filling_char Filling character (default “0”). Return Value type( string ) Filled string. procedure, public, pass(self) :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. generic, public :: glob => glob_character , glob_string Glob search, finds all the pathnames matching a given pattern. private  subroutine glob_character (self, pattern, list) Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: pattern Given pattern. character(len=:), intent(out), allocatable :: list (:) List of matching pathnames. private  subroutine glob_string (self, pattern, list) Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: pattern Given pattern. type( string ), intent(out), allocatable :: list (:) List of matching pathnames. generic, public :: insert => insert_string , insert_character Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Insert substring into string at a specified position. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. private elemental function insert_character (self, substring, pos) result(inserted) Insert substring into string at a specified position. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. generic, public :: join => join_strings , join_characters Return a string that is a join of an array of strings or characters. private pure function join_strings (self, array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function join_characters (self, array, sep) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. generic, public :: strjoin => strjoin_strings , strjoin_characters , strjoin_strings_array , strjoin_characters_array Return a string that is a join of an array of strings or characters;\nReturn join 1D string array of an 2D array of strings or characters in columns or rows. private pure function strjoin_strings (array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function strjoin_characters (array, sep, is_trim) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not Return Value type( string ) The join of array. private pure function strjoin_strings_array (array, sep, is_col) result(join) Return a string that is a join of columns or rows of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ), allocatable, (:) The join of array. private pure function strjoin_characters_array (array, sep, is_trim, is_col) result(join) Return a string that is a join of columns or rows of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ), allocatable, (:) The join of array. procedure, public, pass(self) :: lower Return a string with all lowercase characters. private elemental function lower (self) Return a string with all lowercase characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). private pure function partition (self, sep) result(partitions) Split string at separator and return the 3 parts (before, the separator and after). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ), (1:3) after the separator. procedure, public, pass(self) :: read_file Read a file a single string stream. private  subroutine read_file (self, file, is_fast, form, iostat, iomsg) Read a file as a single string stream. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. logical, intent(in), optional :: is_fast Flag to enable (super) fast file reading. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. procedure, public, pass(self) :: read_line Read line (record) from a connected unit. private  subroutine read_line (self, unit, form, iostat, iomsg) Read line (record) from a connected unit. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. procedure, public, pass(self) :: read_lines Read (all) lines (records) from a connected unit as a single ascii stream. private  subroutine read_lines (self, unit, form, iostat, iomsg) Read (all) lines (records) from a connected unit as a single ascii stream. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. private elemental function replace (self, old, new, count) result(replaced) Return a string with all occurrences of substring old replaced by new. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: old Old substring. character(kind=CK, len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. procedure, public, pass(self) :: reverse Return a reversed string. private elemental function reverse (self) result(reversed) Return a reversed string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. procedure, public, pass(self) :: search Search for tagged record into string. private  function search (self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Search for tagged record into string, return the first record found (if any) matching the tags. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: tag_start Start tag. character(kind=CK, len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK, len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. procedure, public, pass(self) :: slice Return the raw characters data sliced. private pure function slice (self, istart, iend) result(raw) Return the raw characters data sliced. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK, len=:), allocatable Raw characters data. procedure, public, pass(self) :: snakecase Return a string with all words lowercase separated by “_”. private elemental function snakecase (self, sep) Return a string with all words lowercase separated by “_”. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. private pure subroutine split (self, tokens, sep, max_tokens) Return a list of substring in the string, using sep as the delimiter string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK, len=*), intent(in), optional :: sep Separator. integer, intent(in), optional :: max_tokens Fix the maximum number of returned tokens. procedure, public, pass(self) :: split_chunked Return a list of substring in the string, using sep as the delimiter string. private pure subroutine split_chunked (self, tokens, chunks, sep) Return a list of substring in the string, using sep as the delimiter string, chunked (memory-efficient) algorithm. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. integer, intent(in) :: chunks Number of chunks. character(kind=CK, len=*), intent(in), optional :: sep Separator. procedure, public, pass(self) :: startcase Return a string with all words capitalized, e.g. title case. private elemental function startcase (self, sep) Return a string with all words capitalized, e.g. title case. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. procedure, public, pass(self) :: strip Return a string with the leading and trailing characters removed. private elemental function strip (self, remove_nulls) Return a copy of the string with the leading and trailing characters removed. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. procedure, public, pass(self) :: swapcase Return a string with uppercase chars converted to lowercase and vice versa. private elemental function swapcase (self) Return a copy of the string with uppercase characters converted to lowercase and vice versa. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. procedure, public, pass(self) :: tempname Return a safe temporary name suitable for temporary file or directories. private  function tempname (self, is_file, prefix, path) Return a safe temporary name suitable for temporary file or directories. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: is_file True if tempname should be used for file (the default). character(len=*), intent(in), optional :: prefix Name prefix, otherwise self is used (if allocated). character(len=*), intent(in), optional :: path Path where file/directory should be used, default ./ . Return Value character(len=:), allocatable Safe (unique) temporary name. generic, public :: to_number => to_integer_I1P , to_integer_I2P , to_integer_I4P , to_integer_I8P , to_real_R8P , to_real_R4P Cast string to number. private elemental function to_integer_I1P (self, kind) result(to_number) Cast string to integer (I1P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. private elemental function to_integer_I2P (self, kind) result(to_number) Cast string to integer (I2P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. private elemental function to_integer_I4P (self, kind) result(to_number) Cast string to integer (I4P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. private elemental function to_integer_I8P (self, kind) result(to_number) Cast string to integer (I8P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. private elemental function to_real_R8P (self, kind) result(to_number) Cast string to real (R8P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. private elemental function to_real_R4P (self, kind) result(to_number) Cast string to real (R4P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. procedure, public, pass(self) :: unescape Unescape double backslashes (or custom escaped character). private elemental function unescape (self, to_unescape, unesc) result(unescaped) Unescape double backslashes (or custom escaped character). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK, len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. procedure, public, pass(self) :: unique Reduce to one (unique) multiple occurrences of a substring into a string. private elemental function unique (self, substring) result(uniq) Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. procedure, public, pass(self) :: upper Return a string with all uppercase characters. private elemental function upper (self) Return a string with all uppercase characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. procedure, public, pass(self) :: write_file Write a single string stream into file. private  subroutine write_file (self, file, form, iostat, iomsg) Write a single string stream into file. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. procedure, public, pass(self) :: write_line Write line (record) to a connected unit. private  subroutine write_line (self, unit, form, iostat, iomsg) Write line (record) to a connected unit. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. procedure, public, pass(self) :: write_lines Write lines (records) to a connected unit. private  subroutine write_lines (self, unit, form, iostat, iomsg) Write lines (records) to a connected unit. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. private elemental function end_with (self, suffix, start, end, ignore_null_eof) Return true if a string ends with a specified suffix. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. logical, intent(in), optional :: ignore_null_eof Ignore null character at the end of file. Return Value logical Result of the test. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. private elemental function is_allocated (self) Return true if the string is allocated. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. private elemental function is_digit (self) Return true if all characters in the string are digits. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. procedure, public, pass(self) :: is_integer Return true if the string contains an integer. private elemental function is_integer (self, allow_spaces) Return true if the string contains an integer. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. private elemental function is_lower (self) Return true if all characters in the string are lowercase. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. procedure, public, pass(self) :: is_number Return true if the string contains a number (real or integer). private elemental function is_number (self, allow_spaces) Return true if the string contains a number (real or integer). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. procedure, public, pass(self) :: is_real Return true if the string contains an real. private elemental function is_real (self, allow_spaces) Return true if the string contains a real. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. private elemental function is_upper (self) Return true if all characters in the string are uppercase. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. private elemental function start_with (self, prefix, start, end) Return true if a string starts with a specified prefix. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. generic, public :: assignment(=) => string_assign_string , string_assign_character , string_assign_integer_I1P , string_assign_integer_I2P , string_assign_integer_I4P , string_assign_integer_I8P , string_assign_real_R8P , string_assign_real_R4P Assignment operator overloading. private pure subroutine string_assign_string (lhs, rhs) Assignment operator from string input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. private pure subroutine string_assign_character (lhs, rhs) Assignment operator from character input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I1P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I2P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I4P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I8P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_real_R8P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_real_R4P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. generic, public :: operator(//) => string_concat_string , string_concat_character , character_concat_string Concatenation operator overloading. private pure function string_concat_string (lhs, rhs) result(concat) Concatenation with string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK, len=:), allocatable Concatenated string. private pure function string_concat_character (lhs, rhs) result(concat) Concatenation with character. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK, len=:), allocatable Concatenated string. private pure function character_concat_string (lhs, rhs) result(concat) Concatenation with character (inverted). Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK, len=:), allocatable Concatenated string. generic, public :: operator(.cat.) => string_concat_string_string , string_concat_character_string , character_concat_string_string Concatenation operator (string output) overloading. private elemental function string_concat_string_string (lhs, rhs) result(concat) Concatenation with string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Concatenation with character. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. private elemental function character_concat_string_string (lhs, rhs) result(concat) Concatenation with character (inverted). Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. generic, public :: operator(==) => string_eq_string , string_eq_character , character_eq_string Equal operator overloading. private elemental function string_eq_string (lhs, rhs) result(is_it) Equal to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_eq_character (lhs, rhs) result(is_it) Equal to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_eq_string (lhs, rhs) result(is_it) Equal to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: operator(/=) => string_ne_string , string_ne_character , character_ne_string Not equal operator overloading. private elemental function string_ne_string (lhs, rhs) result(is_it) Not equal to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_ne_character (lhs, rhs) result(is_it) Not equal to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_ne_string (lhs, rhs) result(is_it) Not equal to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: operator(<) => string_lt_string , string_lt_character , character_lt_string Lower than operator overloading. private elemental function string_lt_string (lhs, rhs) result(is_it) Lower than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_lt_character (lhs, rhs) result(is_it) Lower than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_lt_string (lhs, rhs) result(is_it) Lower than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: operator(<=) => string_le_string , string_le_character , character_le_string Lower equal than operator overloading. private elemental function string_le_string (lhs, rhs) result(is_it) Lower equal than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_le_character (lhs, rhs) result(is_it) Lower equal than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_le_string (lhs, rhs) result(is_it) Lower equal than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: operator(>=) => string_ge_string , string_ge_character , character_ge_string Greater equal than operator overloading. private elemental function string_ge_string (lhs, rhs) result(is_it) Greater equal than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_ge_character (lhs, rhs) result(is_it) Greater equal than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_ge_string (lhs, rhs) result(is_it) Greater equal than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: operator(>) => string_gt_string , string_gt_character , character_gt_string Greater than operator overloading. private elemental function string_gt_string (lhs, rhs) result(is_it) Greater than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_gt_character (lhs, rhs) result(is_it) Greater than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_gt_string (lhs, rhs) result(is_it) Greater than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: read(formatted) => read_formatted Formatted input. private  subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Formatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. generic, public :: write(formatted) => write_formatted Formatted output. private  subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Formatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK, len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. generic, public :: read(unformatted) => read_unformatted Unformatted input. private  subroutine read_unformatted (dtv, unit, iostat, iomsg) Unformatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. generic, public :: write(unformatted) => write_unformatted Unformatted output. private  subroutine write_unformatted (dtv, unit, iostat, iomsg) Unformatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(self) :: sindex_string_string Index replacement. private elemental function sindex_string_string (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, private, pass(self) :: sindex_string_character Index replacement. private elemental function sindex_string_character (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, private, pass(self) :: srepeat_string_string Repeat replacement. private elemental function srepeat_string_string (self, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. procedure, private, nopass :: srepeat_character_string Repeat replacement. private elemental function srepeat_character_string (rstring, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. procedure, private, pass(self) :: sscan_string_string Scan replacement. private elemental function sscan_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, private, pass(self) :: sscan_string_character Scan replacement. private elemental function sscan_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, private, pass(self) :: sverify_string_string Verify replacement. private elemental function sverify_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, private, pass(self) :: sverify_string_character Verify replacement. private elemental function sverify_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, private, pass(self) :: colorize_str Colorize and stylize strings. private pure function colorize_str (self, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, DEFAULT kind. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:), allocatable Colorized string. procedure, private, pass(self) :: glob_character Glob search (character output). private  subroutine glob_character (self, pattern, list) Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: pattern Given pattern. character(len=:), intent(out), allocatable :: list (:) List of matching pathnames. procedure, private, pass(self) :: glob_string Glob search (string output). private  subroutine glob_string (self, pattern, list) Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: pattern Given pattern. type( string ), intent(out), allocatable :: list (:) List of matching pathnames. procedure, private, pass(self) :: insert_string Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Insert substring into string at a specified position. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. procedure, private, pass(self) :: insert_character Insert substring into string at a specified position. private elemental function insert_character (self, substring, pos) result(inserted) Insert substring into string at a specified position. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. procedure, private, pass(self) :: join_strings Return join string of an array of strings. private pure function join_strings (self, array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. procedure, private, pass(self) :: join_characters Return join string of an array of characters. private pure function join_characters (self, array, sep) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. procedure, private, nopass :: strjoin_strings Return join string of an array of strings. private pure function strjoin_strings (array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. procedure, private, nopass :: strjoin_characters Return join string of an array of strings. private pure function strjoin_characters (array, sep, is_trim) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not Return Value type( string ) The join of array. procedure, private, nopass :: strjoin_strings_array Return join 1D string array of an 2D array of strings in columns or rows. private pure function strjoin_strings_array (array, sep, is_col) result(join) Return a string that is a join of columns or rows of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ), allocatable, (:) The join of array. procedure, private, nopass :: strjoin_characters_array Return join 1D string array of an 2D array of characters in columns or rows. private pure function strjoin_characters_array (array, sep, is_trim, is_col) result(join) Return a string that is a join of columns or rows of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ), allocatable, (:) The join of array. procedure, private, pass(self) :: to_integer_I1P Cast string to integer. private elemental function to_integer_I1P (self, kind) result(to_number) Cast string to integer (I1P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. procedure, private, pass(self) :: to_integer_I2P Cast string to integer. private elemental function to_integer_I2P (self, kind) result(to_number) Cast string to integer (I2P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. procedure, private, pass(self) :: to_integer_I4P Cast string to integer. private elemental function to_integer_I4P (self, kind) result(to_number) Cast string to integer (I4P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. procedure, private, pass(self) :: to_integer_I8P Cast string to integer. private elemental function to_integer_I8P (self, kind) result(to_number) Cast string to integer (I8P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. procedure, private, pass(self) :: to_real_R4P Cast string to real. private elemental function to_real_R4P (self, kind) result(to_number) Cast string to real (R4P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. procedure, private, pass(self) :: to_real_R8P Cast string to real. private elemental function to_real_R8P (self, kind) result(to_number) Cast string to real (R8P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. procedure, private, pass(self) :: to_real_R16P Cast string to real. private elemental function to_real_R16P (self, kind) result(to_number) Cast string to real (R16P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. private pure subroutine string_assign_string (lhs, rhs) Assignment operator from string input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. private pure subroutine string_assign_character (lhs, rhs) Assignment operator from character input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_integer_I1P Assignment operator from integer input. private pure subroutine string_assign_integer_I1P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_integer_I2P Assignment operator from integer input. private pure subroutine string_assign_integer_I2P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_integer_I4P Assignment operator from integer input. private pure subroutine string_assign_integer_I4P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_integer_I8P Assignment operator from integer input. private pure subroutine string_assign_integer_I8P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_real_R4P Assignment operator from real input. private pure subroutine string_assign_real_R4P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_real_R8P Assignment operator from real input. private pure subroutine string_assign_real_R8P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_real_R16P Assignment operator from real input. private pure subroutine string_assign_real_R16P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. private pure function string_concat_string (lhs, rhs) result(concat) Concatenation with string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK, len=:), allocatable Concatenated string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. private pure function string_concat_character (lhs, rhs) result(concat) Concatenation with character. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK, len=:), allocatable Concatenated string. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). private pure function character_concat_string (lhs, rhs) result(concat) Concatenation with character (inverted). Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK, len=:), allocatable Concatenated string. procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). private elemental function string_concat_string_string (lhs, rhs) result(concat) Concatenation with string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). private elemental function string_concat_character_string (lhs, rhs) result(concat) Concatenation with character. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). private elemental function character_concat_string_string (lhs, rhs) result(concat) Concatenation with character (inverted). Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. procedure, private, pass(lhs) :: string_eq_string Equal to string logical operator. private elemental function string_eq_string (lhs, rhs) result(is_it) Equal to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_eq_character Equal to character logical operator. private elemental function string_eq_character (lhs, rhs) result(is_it) Equal to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(rhs) :: character_eq_string Equal to character (inverted) logical operator. private elemental function character_eq_string (lhs, rhs) result(is_it) Equal to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_ne_string Not equal to string logical operator. private elemental function string_ne_string (lhs, rhs) result(is_it) Not equal to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_ne_character Not equal to character logical operator. private elemental function string_ne_character (lhs, rhs) result(is_it) Not equal to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(rhs) :: character_ne_string Not equal to character (inverted) logical operator. private elemental function character_ne_string (lhs, rhs) result(is_it) Not equal to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_lt_string Lower than to string logical operator. private elemental function string_lt_string (lhs, rhs) result(is_it) Lower than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_lt_character Lower than to character logical operator. private elemental function string_lt_character (lhs, rhs) result(is_it) Lower than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(rhs) :: character_lt_string Lower than to character (inverted) logical operator. private elemental function character_lt_string (lhs, rhs) result(is_it) Lower than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_le_string Lower equal than to string logical operator. private elemental function string_le_string (lhs, rhs) result(is_it) Lower equal than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_le_character Lower equal than to character logical operator. private elemental function string_le_character (lhs, rhs) result(is_it) Lower equal than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(rhs) :: character_le_string Lower equal than to character (inverted) logical operator. private elemental function character_le_string (lhs, rhs) result(is_it) Lower equal than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_ge_string Greater equal than to string logical operator. private elemental function string_ge_string (lhs, rhs) result(is_it) Greater equal than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_ge_character Greater equal than to character logical operator. private elemental function string_ge_character (lhs, rhs) result(is_it) Greater equal than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(rhs) :: character_ge_string Greater equal than to character (inverted) logical operator. private elemental function character_ge_string (lhs, rhs) result(is_it) Greater equal than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_gt_string Greater than to string logical operator. private elemental function string_gt_string (lhs, rhs) result(is_it) Greater than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_gt_character Greater than to character logical operator. private elemental function string_gt_character (lhs, rhs) result(is_it) Greater than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(rhs) :: character_gt_string Greater than to character (inverted) logical operator. private elemental function character_gt_string (lhs, rhs) result(is_it) Greater than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(dtv) :: read_formatted Formatted input. private  subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Formatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(dtv) :: read_delimited Read a delimited input. private  subroutine read_delimited (dtv, unit, delim, iostat, iomsg) Read a delimited string from a unit connected for formatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK, len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(dtv) :: read_undelimited Read an undelimited input. private  subroutine read_undelimited (dtv, unit, terminators, iostat, iomsg) Read an undelimited string up until end of record or a character from a set of terminators is encountered. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK, len=*), intent(in) :: terminators Characters that are considered to terminate the string.\nBlanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(dtv) :: read_undelimited_listdirected Read an undelimited list directed input. private  subroutine read_undelimited_listdirected (dtv, unit, iostat, iomsg) Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(dtv) :: write_formatted Formatted output. private  subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Formatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK, len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(dtv) :: read_unformatted Unformatted input. private  subroutine read_unformatted (dtv, unit, iostat, iomsg) Unformatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(dtv) :: write_unformatted Unformatted output. private  subroutine write_unformatted (dtv, unit, iostat, iomsg) Unformatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. private elemental function replace_one_occurrence (self, old, new) result(replaced) Return a string with the first occurrence of substring old replaced by new. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: old Old substring. character(kind=CK, len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Source Code type :: string !< OOP designed string class. character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods ! builtins replacements procedure , pass ( self ) :: adjustl => sadjustl !< Adjustl replacement. procedure , pass ( self ) :: adjustr => sadjustr !< Adjustr replacement. procedure , pass ( self ) :: count => scount !< Count replacement. generic :: index => sindex_string_string , & sindex_string_character !< Index replacement. procedure , pass ( self ) :: len => slen !< Len replacement. procedure , pass ( self ) :: len_trim => slen_trim !< Len_trim replacement. generic :: repeat => srepeat_string_string , & srepeat_character_string !< Repeat replacement. generic :: scan => sscan_string_string , & sscan_string_character !< Scan replacement. procedure , pass ( self ) :: trim => strim !< Trim replacement. generic :: verify => sverify_string_string , & sverify_string_character !< Verify replacement. ! auxiliary methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. generic :: colorize => & colorize_str !< Colorize and stylize strings. procedure , pass ( self ) :: decode !< Decode string. procedure , pass ( self ) :: encode !< Encode string. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: glob => & glob_character , & glob_string !< Glob search, finds all the pathnames matching a given pattern. generic :: insert => & insert_string , & insert_character !< Insert substring into string at a specified position. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. generic :: strjoin => & strjoin_strings , & strjoin_characters , & strjoin_strings_array , & strjoin_characters_array !< Return a string that is a join of an array of strings or characters; !< Return join 1D string array of an 2D array of strings or characters in columns or rows. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: read_file !< Read a file a single string stream. procedure , pass ( self ) :: read_line !< Read line (record) from a connected unit. procedure , pass ( self ) :: read_lines !< Read (all) lines (records) from a connected unit as a single ascii stream. procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: slice !< Return the raw characters data sliced. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: split_chunked !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. procedure , pass ( self ) :: tempname !< Return a safe temporary name suitable for temporary file or directories. generic :: to_number => & to_integer_I1P ,& #ifndef _NVF to_integer_I2P ,& #endif to_integer_I4P ,& to_integer_I8P ,& #if defined _R16P to_real_R16P , & #endif to_real_R8P , & to_real_R4P !< Cast string to number. procedure , pass ( self ) :: unescape !< Unescape double backslashes (or custom escaped character). procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: write_file !< Write a single string stream into file. procedure , pass ( self ) :: write_line !< Write line (record) to a connected unit. procedure , pass ( self ) :: write_lines !< Write lines (records) to a connected unit. ! inquire methods procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & #if defined _R16P string_assign_real_R16P , & #endif string_assign_real_R8P , & string_assign_real_R4P !< Assignment operator overloading. generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. generic :: operator ( == ) => string_eq_string , & string_eq_character , & character_eq_string !< Equal operator overloading. generic :: operator ( /= ) => string_ne_string , & string_ne_character , & character_ne_string !< Not equal operator overloading. generic :: operator ( < ) => string_lt_string , & string_lt_character , & character_lt_string !< Lower than operator overloading. generic :: operator ( <= ) => string_le_string , & string_le_character , & character_le_string !< Lower equal than operator overloading. generic :: operator ( >= ) => string_ge_string , & string_ge_character , & character_ge_string !< Greater equal than operator overloading. generic :: operator ( > ) => string_gt_string , & string_gt_character , & character_gt_string !< Greater than operator overloading. ! IO generic :: read ( formatted ) => read_formatted !< Formatted input. generic :: write ( formatted ) => write_formatted !< Formatted output. generic :: read ( unformatted ) => read_unformatted !< Unformatted input. generic :: write ( unformatted ) => write_unformatted !< Unformatted output. ! private methods ! builtins replacements procedure , private , pass ( self ) :: sindex_string_string !< Index replacement. procedure , private , pass ( self ) :: sindex_string_character !< Index replacement. procedure , private , pass ( self ) :: srepeat_string_string !< Repeat replacement. procedure , private , nopass :: srepeat_character_string !< Repeat replacement. procedure , private , pass ( self ) :: sscan_string_string !< Scan replacement. procedure , private , pass ( self ) :: sscan_string_character !< Scan replacement. procedure , private , pass ( self ) :: sverify_string_string !< Verify replacement. procedure , private , pass ( self ) :: sverify_string_character !< Verify replacement. ! auxiliary methods procedure , private , pass ( self ) :: colorize_str !< Colorize and stylize strings. procedure , private , pass ( self ) :: glob_character !< Glob search (character output). procedure , private , pass ( self ) :: glob_string !< Glob search (string output). procedure , private , pass ( self ) :: insert_string !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: insert_character !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , nopass :: strjoin_strings !< Return join string of an array of strings. procedure , private , nopass :: strjoin_characters !< Return join string of an array of strings. procedure , private , nopass :: strjoin_strings_array !< Return join 1D string array of an 2D array of strings in columns or rows. procedure , private , nopass :: strjoin_characters_array !< Return join 1D string array of an 2D array of characters in columns or rows. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. #ifndef _NVF procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. #endif procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. ! assignments procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. ! concatenation operators procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). ! logical operators procedure , private , pass ( lhs ) :: string_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: string_eq_character !< Equal to character logical operator. procedure , private , pass ( rhs ) :: character_eq_string !< Equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ne_string !< Not equal to string logical operator. procedure , private , pass ( lhs ) :: string_ne_character !< Not equal to character logical operator. procedure , private , pass ( rhs ) :: character_ne_string !< Not equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_lt_string !< Lower than to string logical operator. procedure , private , pass ( lhs ) :: string_lt_character !< Lower than to character logical operator. procedure , private , pass ( rhs ) :: character_lt_string !< Lower than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_le_string !< Lower equal than to string logical operator. procedure , private , pass ( lhs ) :: string_le_character !< Lower equal than to character logical operator. procedure , private , pass ( rhs ) :: character_le_string !< Lower equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ge_string !< Greater equal than to string logical operator. procedure , private , pass ( lhs ) :: string_ge_character !< Greater equal than to character logical operator. procedure , private , pass ( rhs ) :: character_ge_string !< Greater equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_gt_string !< Greater than to string logical operator. procedure , private , pass ( lhs ) :: string_gt_character !< Greater than to character logical operator. procedure , private , pass ( rhs ) :: character_gt_string !< Greater than to character (inverted) logical operator. ! IO procedure , private , pass ( dtv ) :: read_formatted !< Formatted input. procedure , private , pass ( dtv ) :: read_delimited !< Read a delimited input. procedure , private , pass ( dtv ) :: read_undelimited !< Read an undelimited input. procedure , private , pass ( dtv ) :: read_undelimited_listdirected !< Read an undelimited list directed input. procedure , private , pass ( dtv ) :: write_formatted !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted !< Unformatted output. ! miscellanea procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string","tags":"","loc":"type/string.html"},{"title":"read_file – StringiFor","text":"public  subroutine read_file(file, lines, form, iostat, iomsg) Read a file as a single string stream. The lines are returned as an array of strings that are read until the eof is reached.\n The line is read as an ascii stream read until the eor is reached. @note Note\n      For unformatted read only access='stream' is supported with new_line as line terminator. type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) call read_file ( file = 'read_file_test.tmp' , lines = strings , iostat = iostat , iomsg = iomsg ) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) call read_file ( file = 'read_file_test.tmp' , lines = strings , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Calls proc~~read_file~~CallsGraph proc~read_file read_file proc~chars string%chars proc~read_file->proc~chars proc~read_lines read_lines proc~read_file->proc~read_lines proc~upper string%upper proc~read_file->proc~upper proc~read_lines->proc~chars proc~read_lines->proc~upper proc~read_line string%read_line proc~read_lines->proc~read_line proc~read_line->proc~chars proc~read_line->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_file~~CalledByGraph proc~read_file read_file program~volatile_doctest~54 volatile_doctest program~volatile_doctest~54->proc~read_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_file ( file , lines , form , iostat , iomsg ) !< Read a file as a single string stream. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, file='read_file_test.tmp') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< close(scratch) !< call read_file(file='read_file_test.tmp', lines=strings, iostat=iostat, iomsg=iomsg) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< close(scratch) !< call read_file(file='read_file_test.tmp', lines=strings, form='unformatted', iostat=iostat, iomsg=iomsg) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< close(scratch, status='DELETE') !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call read_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_file","tags":"","loc":"proc/read_file.html"},{"title":"read_lines – StringiFor","text":"public  subroutine read_lines(unit, lines, form, iostat, iomsg) Read lines (records) from a connected-formatted unit. Note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. The lines are returned as an array of strings that are read until the eof is reached.\nThe line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. Note There is no doctests, this being tested by means of read_file doctests. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Calls proc~~read_lines~~CallsGraph proc~read_lines read_lines proc~chars string%chars proc~read_lines->proc~chars proc~read_line string%read_line proc~read_lines->proc~read_line proc~upper string%upper proc~read_lines->proc~upper proc~read_line->proc~chars proc~read_line->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_lines~~CalledByGraph proc~read_lines read_lines proc~read_file read_file proc~read_file->proc~read_lines program~volatile_doctest~54 volatile_doctest program~volatile_doctest~54->proc~read_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_lines ( unit , lines , form , iostat , iomsg ) !< Read lines (records) from a connected-formatted unit. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !< @note There is no doctests, this being tested by means of [[read_file]] doctests. integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = 1 ) :: ch !< Character storage. integer :: l !< Counter. form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) select case ( form_ % chars ()) case ( 'FORMATTED' ) l = 0 do read ( unit , * , err = 10 , end = 10 ) l = l + 1 enddo case ( 'UNFORMATTED' ) l = 0 do read ( unit , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) l = l + 1 enddo endselect 10 rewind ( unit ) if ( l > 0 ) then allocate ( lines ( 1 : l )) l = 1 iostat_ = 0 do call lines ( l )% read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if (( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )). or .( l >= size ( lines , dim = 1 ))) then exit endif l = l + 1 enddo endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_lines","tags":"","loc":"proc/read_lines.html"},{"title":"write_file – StringiFor","text":"public  subroutine write_file(file, lines, form, iostat, iomsg) Write a single string stream into file. @note Note\n      For unformatted read only access='stream' is supported with new_line as line terminator. type ( string ) :: astring type ( string ) :: anotherstring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) call write_file ( file = 'write_file_test.tmp' , lines = line , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo call write_file ( file = 'write_file_test.tmp' , lines = line , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( scratch , status = 'DELETE' ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Calls proc~~write_file~~CallsGraph proc~write_file write_file proc~chars string%chars proc~write_file->proc~chars proc~upper string%upper proc~write_file->proc~upper proc~write_lines write_lines proc~write_file->proc~write_lines proc~write_line string%write_line proc~write_lines->proc~write_line proc~write_line->proc~chars proc~write_line->proc~upper proc~end_with string%end_with proc~write_line->proc~end_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~write_file~~CalledByGraph proc~write_file write_file program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~write_file program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~write_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine write_file ( file , lines , form , iostat , iomsg ) !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string)              :: anotherstring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< anotherstring = anotherstring%join(array=line, sep=new_line('a')) !< call write_file(file='write_file_test.tmp', lines=line, iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< call write_file(file='write_file_test.tmp', lines=line, form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='write_file_test.tmp') !< close(scratch, status='DELETE') !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call write_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_file","tags":"","loc":"proc/write_file.html"},{"title":"write_lines – StringiFor","text":"public  subroutine write_lines(unit, lines, form, iostat, iomsg) Write lines (records) to a connected-formatted unit. Note There is no doctests, this being tested by means of write_file doctests. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Calls proc~~write_lines~~CallsGraph proc~write_lines write_lines proc~write_line string%write_line proc~write_lines->proc~write_line proc~chars string%chars proc~write_line->proc~chars proc~end_with string%end_with proc~write_line->proc~end_with proc~upper string%upper proc~write_line->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~write_lines~~CalledByGraph proc~write_lines write_lines proc~write_file write_file proc~write_file->proc~write_lines program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~write_file program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~write_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine write_lines ( unit , lines , form , iostat , iomsg ) !< Write lines (records) to a connected-formatted unit. !< !< @note There is no doctests, this being tested by means of [[write_file]] doctests. integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: l !< Counter. do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endsubroutine write_lines","tags":"","loc":"proc/write_lines.html"},{"title":"string_ – StringiFor","text":"private pure function string_(c) Return a string given a character input. print \"(L1)\" , string ( 'Hello World' ) // '' == 'Hello World' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character. Return Value type( string ) String. Source Code pure function string_ ( c ) !< Return a string given a character input. !< !<```fortran !< print \"(L1)\", string('Hello World')//''=='Hello World' !<``` !=> T <<< character ( * ), intent ( in ) :: c !< Character. type ( string ) :: string_ !< String. string_ % raw = c endfunction string_","tags":"","loc":"proc/string_.html"},{"title":"sadjustl_character – StringiFor","text":"private pure function sadjustl_character(s) result(adjusted) Left adjust a string by removing leading spaces (character output). type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , adjustl ( astring ) == 'Hello World!   ' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK, len=:), allocatable Adjusted string. Called by proc~~sadjustl_character~~CalledByGraph proc~sadjustl_character sadjustl_character interface~adjustl adjustl interface~adjustl->proc~sadjustl_character Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function sadjustl_character ( s ) result ( adjusted ) !< Left adjust a string by removing leading spaces (character output). !< !<```fortran !< type(string) :: astring !< astring = '   Hello World!' !< print \"(L1)\", adjustl(astring)=='Hello World!   ' !<``` !=> T <<< class ( string ), intent ( in ) :: s !< String. character ( kind = CK , len = :), allocatable :: adjusted !< Adjusted string. if ( allocated ( s % raw )) adjusted = adjustl ( s % raw ) endfunction sadjustl_character","tags":"","loc":"proc/sadjustl_character.html"},{"title":"sadjustr_character – StringiFor","text":"private pure function sadjustr_character(s) result(adjusted) Right adjust a string by removing leading spaces (character output). type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , adjustr ( astring ) == '   Hello World!' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK, len=:), allocatable Adjusted string. Called by proc~~sadjustr_character~~CalledByGraph proc~sadjustr_character sadjustr_character interface~adjustr adjustr interface~adjustr->proc~sadjustr_character Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function sadjustr_character ( s ) result ( adjusted ) !< Right adjust a string by removing leading spaces (character output). !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", adjustr(astring)=='   Hello World!' !<``` !=> T <<< class ( string ), intent ( in ) :: s !< String. character ( kind = CK , len = :), allocatable :: adjusted !< Adjusted string. if ( allocated ( s % raw )) adjusted = adjustr ( s % raw ) endfunction sadjustr_character","tags":"","loc":"proc/sadjustr_character.html"},{"title":"count_substring – StringiFor","text":"private elemental function count_substring(s, substring) result(No) Count the number of occurences of a substring into a string. print \"(L1)\" , count ( 'hello' , substring = 'll' ) == 1 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Called by proc~~count_substring~~CalledByGraph proc~count_substring count_substring interface~count count interface~count->proc~count_substring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function count_substring ( s , substring ) result ( No ) !< Count the number of occurences of a substring into a string. !< !<```fortran !< print \"(L1)\", count('hello', substring='ll')==1 !<``` !=> T <<< character ( * ), intent ( in ) :: s !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. No = 0 if ( len ( substring ) > len ( s )) return c1 = 1 do c2 = index ( string = s ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo endfunction count_substring","tags":"","loc":"proc/count_substring.html"},{"title":"sindex_character_string – StringiFor","text":"private elemental function sindex_character_string(s, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = index ( s = 'Hello World Hello!' , substring = string1 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = index ( s = 'Hello World Hello!' , substring = string1 , back = . true .) == index ( string = 'Hello World Hello!' , & substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: s String. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sindex_character_string~~CalledByGraph proc~sindex_character_string sindex_character_string interface~index index interface~index->proc~sindex_character_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sindex_character_string ( s , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'llo' !< test_passed(1) = index(s='Hello World Hello!', substring=string1)==index(string='Hello World Hello!', substring='llo') !< test_passed(2) = index(s='Hello World Hello!', substring=string1, back=.true.)==index(string='Hello World Hello!', & !<                                                                                       substring='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: s !< String. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( substring % raw )) then i = index ( string = s , substring = substring % raw , back = back ) else i = 0 endif endfunction sindex_character_string","tags":"","loc":"proc/sindex_character_string.html"},{"title":"sscan_character_string – StringiFor","text":"private elemental function sscan_character_string(s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = scan ( s = 'Hello World Hello!' , set = string1 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = scan ( s = 'Hello World Hello!' , set = string1 , back = . true .) == scan ( string = 'Hello World Hello!' , & set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sscan_character_string~~CalledByGraph proc~sscan_character_string sscan_character_string interface~scan scan interface~scan->proc~sscan_character_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sscan_character_string ( s , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'llo' !< test_passed(1) = scan(s='Hello World Hello!', set=string1)==scan(string='Hello World Hello!', set='llo') !< test_passed(2) = scan(s='Hello World Hello!', set=string1, back=.true.)==scan(string='Hello World Hello!', & !<                                                                               set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: s !< String. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( set % raw )) then i = scan ( string = s , set = set % raw , back = back ) else i = 0 endif endfunction sscan_character_string","tags":"","loc":"proc/sscan_character_string.html"},{"title":"sverify_character_string – StringiFor","text":"private elemental function sverify_character_string(s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'ell' test_passed ( 1 ) = verify ( s = 'Hello World Hello!' , set = string1 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = verify ( s = 'Hello World Hello!' , set = string1 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sverify_character_string~~CalledByGraph proc~sverify_character_string sverify_character_string interface~verify verify interface~verify->proc~sverify_character_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sverify_character_string ( s , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'ell' !< test_passed(1) = verify(s='Hello World Hello!', set=string1)==verify(string='Hello World Hello!', set='llo') !< test_passed(2) = verify(s='Hello World Hello!', set=string1, back=.true.)==verify(string='Hello World Hello!', set='llo', & !<                                                                                   back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: s !< String. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( set % raw )) then i = verify ( string = s , set = set % raw , back = back ) else i = 0 endif endfunction sverify_character_string","tags":"","loc":"proc/sverify_character_string.html"},{"title":"sadjustl – StringiFor","text":"private elemental function sadjustl(self) result(adjusted) Left adjust a string by removing leading spaces. type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , astring % adjustl () // '' == 'Hello World!   ' Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Source Code elemental function sadjustl ( self ) result ( adjusted ) !< Left adjust a string by removing leading spaces. !< !<```fortran !< type(string) :: astring !< astring = '   Hello World!' !< print \"(L1)\", astring%adjustl()//''=='Hello World!   ' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) endfunction sadjustl","tags":"","loc":"proc/sadjustl.html"},{"title":"sadjustr – StringiFor","text":"private elemental function sadjustr(self) result(adjusted) Right adjust a string by removing leading spaces. type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % adjustr () // '' == '   Hello World!' Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Source Code elemental function sadjustr ( self ) result ( adjusted ) !< Right adjust a string by removing leading spaces. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%adjustr()//''=='   Hello World!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) endfunction sadjustr","tags":"","loc":"proc/sadjustr.html"},{"title":"scount – StringiFor","text":"private elemental function scount(self, substring, ignore_isolated) result(No) Count the number of occurences of a substring into a string. @note Note\n      If ignore_isolated is set to true the eventual “isolated” occurences are ignored: an isolated occurrences are those\n     occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a\n     right companion). type ( string ) :: astring logical :: test_passed ( 4 ) astring = '   Hello World  !    ' test_passed ( 1 ) = astring % count ( substring = ' ' ) == 10 astring = 'Hello World  !    ' test_passed ( 2 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 6 astring = '    Hello World  !' test_passed ( 3 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 6 astring = '   Hello World  !    ' test_passed ( 4 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 8 print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore “isolated” occurrences. Return Value integer Number of occurrences. Source Code elemental function scount ( self , substring , ignore_isolated ) result ( No ) !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = '   Hello World  !    ' !< test_passed(1) = astring%count(substring=' ')==10 !< astring = 'Hello World  !    ' !< test_passed(2) = astring%count(substring=' ', ignore_isolated=.true.)==6 !< astring = '    Hello World  !' !< test_passed(3) = astring%count(substring=' ', ignore_isolated=.true.)==6 !< astring = '   Hello World  !    ' !< test_passed(4) = astring%count(substring=' ', ignore_isolated=.true.)==8 !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated c1 = 1 do c2 = index ( string = self % raw ( c1 :), substring = substring ) if ( c2 == 0 ) return if (. not . ignore_isolated_ ) then No = No + 1 else if (. not .(( c1 == 1. and . c2 == 1 ) . or . ( c1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif endfunction scount","tags":"","loc":"proc/scount.html"},{"title":"sindex_string_string – StringiFor","text":"private elemental function sindex_string_string(self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % index ( substring = string2 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = string2 , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sindex_string_string~~CalledByGraph proc~sindex_string_string string%sindex_string_string interface~index index interface~index->proc~sindex_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sindex_string_string ( self , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !< !<```fortran !< type(string) :: string1 !< type(string) :: string2 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< string2 = 'llo' !< test_passed(1) = string1%index(substring=string2)==index(string='Hello World Hello!', substring='llo') !< test_passed(2) = string1%index(substring=string2, back=.true.)==index(string='Hello World Hello!', substring='llo', & !<                                                                       back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring % raw , back = back ) else i = 0 endif endfunction sindex_string_string","tags":"","loc":"proc/sindex_string_string.html"},{"title":"sindex_string_character – StringiFor","text":"private elemental function sindex_string_character(self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % index ( substring = 'llo' ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = 'llo' , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sindex_string_character~~CalledByGraph proc~sindex_string_character string%sindex_string_character interface~index index interface~index->proc~sindex_string_character Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sindex_string_character ( self , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< test_passed(1) = string1%index(substring='llo')==index(string='Hello World Hello!', substring='llo') !< test_passed(2) = string1%index(substring='llo', back=.true.)==index(string='Hello World Hello!', substring='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif endfunction sindex_string_character","tags":"","loc":"proc/sindex_string_character.html"},{"title":"slen – StringiFor","text":"private elemental function slen(self) result(l) Return the length of a string. type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len () == len ( 'Hello World!   ' ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Source Code elemental function slen ( self ) result ( l ) !< Return the length of a string. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%len()==len('Hello World!   ') !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif endfunction slen","tags":"","loc":"proc/slen.html"},{"title":"slen_trim – StringiFor","text":"private elemental function slen_trim(self) result(l) Return the length of a string, ignoring any trailing blanks. type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len_trim () == len_trim ( 'Hello World!   ' ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Called by proc~~slen_trim~~CalledByGraph proc~slen_trim string%slen_trim interface~len_trim len_trim interface~len_trim->proc~slen_trim Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function slen_trim ( self ) result ( l ) !< Return the length of a string, ignoring any trailing blanks. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%len_trim()==len_trim('Hello World!   ') !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif endfunction slen_trim","tags":"","loc":"proc/slen_trim.html"},{"title":"srepeat_string_string – StringiFor","text":"private elemental function srepeat_string_string(self, ncopies) result(repeated) Concatenates several copies of an input string. type ( string ) :: astring astring = 'x' print \"(L1)\" , astring % repeat ( 5 ) // '' == 'xxxxx' Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Called by proc~~srepeat_string_string~~CalledByGraph proc~srepeat_string_string string%srepeat_string_string interface~repeat repeat interface~repeat->proc~srepeat_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function srepeat_string_string ( self , ncopies ) result ( repeated ) !< Concatenates several copies of an input string. !< !<```fortran !< type(string) :: astring !< astring = 'x' !< print \"(L1)\", astring%repeat(5)//''=='xxxxx' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. #ifdef _NVF character ( 9999 ) :: nvf_bug !< Work around for NVFortran bug. #endif #ifdef _NVF nvf_bug = self % raw repeated % raw = repeat ( string = trim ( nvf_bug ), ncopies = ncopies ) #else repeated % raw = repeat ( string = self % raw , ncopies = ncopies ) #endif endfunction srepeat_string_string","tags":"","loc":"proc/srepeat_string_string.html"},{"title":"srepeat_character_string – StringiFor","text":"private elemental function srepeat_character_string(rstring, ncopies) result(repeated) Concatenates several copies of an input string. type ( string ) :: astring astring = 'y' print \"(L1)\" , astring % repeat ( 'x' , 5 ) // '' == 'xxxxx' Type Bound string Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Source Code elemental function srepeat_character_string ( rstring , ncopies ) result ( repeated ) !< Concatenates several copies of an input string. !< !<```fortran !< type(string) :: astring !< astring = 'y' !< print \"(L1)\", astring%repeat('x', 5)//''=='xxxxx' !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. repeated % raw = repeat ( string = rstring , ncopies = ncopies ) endfunction srepeat_character_string","tags":"","loc":"proc/srepeat_character_string.html"},{"title":"sscan_string_string – StringiFor","text":"private elemental function sscan_string_string(self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % scan ( set = string2 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = string2 , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sscan_string_string~~CalledByGraph proc~sscan_string_string string%sscan_string_string interface~scan scan interface~scan->proc~sscan_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sscan_string_string ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !< !<```fortran !< type(string) :: string1 !< type(string) :: string2 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< string2 = 'llo' !< test_passed(1) = string1%scan(set=string2)==scan(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%scan(set=string2, back=.true.)==scan(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = scan ( string = self % raw , set = set % raw , back = back ) else i = 0 endif endfunction sscan_string_string","tags":"","loc":"proc/sscan_string_string.html"},{"title":"sscan_string_character – StringiFor","text":"private elemental function sscan_string_character(self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % scan ( set = 'llo' ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = 'llo' , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sscan_string_character~~CalledByGraph proc~sscan_string_character string%sscan_string_character interface~scan scan interface~scan->proc~sscan_string_character Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sscan_string_character ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< test_passed(1) = string1%scan(set='llo')==scan(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%scan(set='llo', back=.true.)==scan(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif endfunction sscan_string_character","tags":"","loc":"proc/sscan_string_character.html"},{"title":"strim – StringiFor","text":"private elemental function strim(self) result(trimmed) Remove trailing spaces. type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % trim () == trim ( 'Hello World!   ' ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Called by proc~~strim~~CalledByGraph proc~strim string%strim interface~trim trim interface~trim->proc~strim Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strim ( self ) result ( trimmed ) !< Remove trailing spaces. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%trim()==trim('Hello World!   ') !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) endfunction strim","tags":"","loc":"proc/strim.html"},{"title":"sverify_string_string – StringiFor","text":"private elemental function sverify_string_string(self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % verify ( set = string2 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = string2 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sverify_string_string~~CalledByGraph proc~sverify_string_string string%sverify_string_string interface~verify verify interface~verify->proc~sverify_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sverify_string_string ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !< !<```fortran !< type(string) :: string1 !< type(string) :: string2 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< string2 = 'llo' !< test_passed(1) = string1%verify(set=string2)==verify(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%verify(set=string2, back=.true.)==verify(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = verify ( string = self % raw , set = set % raw , back = back ) else i = 0 endif endfunction sverify_string_string","tags":"","loc":"proc/sverify_string_string.html"},{"title":"sverify_string_character – StringiFor","text":"private elemental function sverify_string_character(self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % verify ( set = 'llo' ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = 'llo' , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sverify_string_character~~CalledByGraph proc~sverify_string_character string%sverify_string_character interface~verify verify interface~verify->proc~sverify_string_character Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sverify_string_character ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< test_passed(1) = string1%verify(set='llo')==verify(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%verify(set='llo', back=.true.)==verify(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif endfunction sverify_string_character","tags":"","loc":"proc/sverify_string_character.html"},{"title":"basedir – StringiFor","text":"private elemental function basedir(self, sep) Return the base directory name of a string containing a file name. type ( string ) :: string1 logical :: test_passed ( 4 ) string1 = '/bar/foo.tar.bz2' test_passed ( 1 ) = string1 % basedir () // '' == '/bar' string1 = './bar/foo.tar.bz2' test_passed ( 2 ) = string1 % basedir () // '' == './bar' string1 = 'bar/foo.tar.bz2' test_passed ( 3 ) = string1 % basedir () // '' == 'bar' string1 = '\\bar\\foo.tar.bz2' test_passed ( 4 ) = string1 % basedir ( sep = '\\')//''==' \\ bar ' print ' ( L1 ) ' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Called by proc~~basedir~~CalledByGraph proc~basedir string%basedir program~volatile_doctest~99 volatile_doctest program~volatile_doctest~99->proc~basedir Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function basedir ( self , sep ) !< Return the base directory name of a string containing a file name. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(4) !< string1 = '/bar/foo.tar.bz2' !< test_passed(1) = string1%basedir()//''=='/bar' !< string1 = './bar/foo.tar.bz2' !< test_passed(2) = string1%basedir()//''=='./bar' !< string1 = 'bar/foo.tar.bz2' !< test_passed(3) = string1%basedir()//''=='bar' !< string1 = '\\bar\\foo.tar.bz2' !< test_passed(4) = string1%basedir(sep='\\')//''=='\\bar' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif endfunction basedir","tags":"","loc":"proc/basedir.html"},{"title":"basename – StringiFor","text":"private elemental function basename(self, sep, extension, strip_last_extension) Return the base file name of a string containing a file name. Optionally, the extension is also stripped if provided or the last one if required, e.g. type ( string ) :: astring logical :: test_passed ( 5 ) astring = 'bar/foo.tar.bz2' test_passed ( 1 ) = astring % basename () // '' == 'foo.tar.bz2' test_passed ( 2 ) = astring % basename ( extension = '.tar.bz2' ) // '' == 'foo' test_passed ( 3 ) = astring % basename ( strip_last_extension = . true .) // '' == 'foo.tar' astring = '\\bar\\foo.tar.bz2' test_passed ( 4 ) = astring % basename ( sep = '\\')//''==' foo . tar . bz2 ' astring = ' bar ' test_passed(5) = astring%basename(strip_last_extension=.true.)//''==' bar ' print ' ( L1 ) ' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Directory separator. character(kind=CK, len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Called by proc~~basename~~CalledByGraph proc~basename string%basename program~volatile_doctest~88 volatile_doctest program~volatile_doctest~88->proc~basename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function basename ( self , sep , extension , strip_last_extension ) !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(5) !< astring = 'bar/foo.tar.bz2' !< test_passed(1) = astring%basename()//''=='foo.tar.bz2' !< test_passed(2) = astring%basename(extension='.tar.bz2')//''=='foo' !< test_passed(3) = astring%basename(strip_last_extension=.true.)//''=='foo.tar' !< astring = '\\bar\\foo.tar.bz2' !< test_passed(4) = astring%basename(sep='\\')//''=='foo.tar.bz2' !< astring = 'bar' !< test_passed(5) = astring%basename(strip_last_extension=.true.)//''=='bar' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) if ( present ( extension )) then pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then pos = index ( basename % raw , '.' , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) endif endif endif endfunction basename","tags":"","loc":"proc/basename.html"},{"title":"camelcase – StringiFor","text":"private elemental function camelcase(self, sep) Return a string with all words capitalized without spaces. @note Note\n      Multiple subsequent separators are collapsed to one occurence. type ( string ) :: astring astring = 'caMeL caSe var' print '(L1)' , astring % camelcase () // '' == 'CamelCaseVar' Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Calls proc~~camelcase~~CallsGraph proc~camelcase string%camelcase none~join string%join proc~camelcase->none~join proc~capitalize string%capitalize proc~camelcase->proc~capitalize proc~split string%split proc~camelcase->proc~split proc~join_characters string%join_characters none~join->proc~join_characters proc~join_strings string%join_strings none~join->proc~join_strings proc~lower string%lower proc~capitalize->proc~lower proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~camelcase~~CalledByGraph proc~camelcase string%camelcase program~volatile_doctest~18 volatile_doctest program~volatile_doctest~18->proc~camelcase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function camelcase ( self , sep ) !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(L1)', astring%camelcase()//''=='CamelCaseVar' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif endfunction camelcase","tags":"","loc":"proc/camelcase.html"},{"title":"capitalize – StringiFor","text":"private elemental function capitalize(self) result(capitalized) Return a string with its first character capitalized and the rest lowercased. type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % capitalize () // '' == 'Say all hello world!' Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Calls proc~~capitalize~~CallsGraph proc~capitalize string%capitalize proc~lower string%lower proc~capitalize->proc~lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~capitalize~~CalledByGraph proc~capitalize string%capitalize proc~camelcase string%camelcase proc~camelcase->proc~capitalize proc~startcase string%startcase proc~startcase->proc~capitalize program~volatile_doctest~81 volatile_doctest program~volatile_doctest~81->proc~capitalize program~volatile_doctest~18 volatile_doctest program~volatile_doctest~18->proc~camelcase program~volatile_doctest~2 volatile_doctest program~volatile_doctest~2->proc~startcase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function capitalize ( self ) result ( capitalized ) !< Return a string with its first character capitalized and the rest lowercased. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%capitalize()//''=='Say all hello world!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif endfunction capitalize","tags":"","loc":"proc/capitalize.html"},{"title":"chars – StringiFor","text":"private pure function chars(self) result(raw) Return the raw characters data. type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % chars () == 'say all Hello WorLD!' Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK, len=:), allocatable Raw characters data. Called by proc~~chars~~CalledByGraph proc~chars string%chars proc~colorize_str string%colorize_str proc~colorize_str->proc~chars proc~glob_character string%glob_character proc~glob_character->proc~chars none~glob string%glob proc~glob_character->none~glob proc~read_file read_file proc~read_file->proc~chars proc~read_lines read_lines proc~read_file->proc~read_lines proc~read_file~2 string%read_file proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~read_line string%read_line proc~read_line->proc~chars proc~read_lines->proc~chars proc~read_lines->proc~read_line proc~write_file write_file proc~write_file->proc~chars proc~write_lines write_lines proc~write_file->proc~write_lines proc~write_file~2 string%write_file proc~write_file~2->proc~chars proc~write_lines~2 string%write_lines proc~write_file~2->proc~write_lines~2 proc~write_line string%write_line proc~write_line->proc~chars program~volatile_doctest~107 volatile_doctest program~volatile_doctest~107->proc~chars program~volatile_doctest~107->proc~read_file~2 program~volatile_doctest~111 volatile_doctest program~volatile_doctest~111->proc~chars program~volatile_doctest~15 volatile_doctest program~volatile_doctest~15->proc~chars program~volatile_doctest~15->proc~read_lines~2 program~volatile_doctest~21 volatile_doctest program~volatile_doctest~21->proc~chars program~volatile_doctest~50 volatile_doctest program~volatile_doctest~50->proc~chars program~volatile_doctest~54 volatile_doctest program~volatile_doctest~54->proc~chars program~volatile_doctest~54->proc~read_file program~volatile_doctest~68 volatile_doctest program~volatile_doctest~68->proc~chars program~volatile_doctest~72 volatile_doctest program~volatile_doctest~72->proc~chars program~volatile_doctest~87 volatile_doctest program~volatile_doctest~87->proc~chars program~volatile_doctest~87->proc~read_line program~volatile_doctest~94 volatile_doctest program~volatile_doctest~94->proc~chars interface~glob glob interface~glob->proc~glob_character proc~glob_string string%glob_string interface~glob->proc~glob_string none~colorize string%colorize none~colorize->proc~colorize_str none~glob->proc~glob_character none~glob->proc~glob_string proc~glob_string->proc~read_file~2 proc~read_lines~2->proc~read_line proc~write_lines->proc~write_line proc~write_lines~2->proc~write_line program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~read_file~2 program~stringifor_test_csv_naive_parser->proc~write_file program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~read_file~2 program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~read_file~2 program~volatile_doctest~17->proc~write_file program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~read_file~2 program~volatile_doctest~44->proc~write_file~2 program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->none~glob program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->none~glob program~volatile_doctest~90 volatile_doctest program~volatile_doctest~90->none~colorize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function chars ( self ) result ( raw ) !< Return the raw characters data. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%chars()=='say all Hello WorLD!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif endfunction chars","tags":"","loc":"proc/chars.html"},{"title":"colorize_str – StringiFor","text":"private pure function colorize_str(self, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, DEFAULT kind. type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % colorize ( color_fg = 'red' ) == '\u001b[31msay all Hello WorLD!\u001b[0m' Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:), allocatable Colorized string. Calls proc~~colorize_str~~CallsGraph proc~colorize_str string%colorize_str colorize colorize proc~colorize_str->colorize proc~chars string%chars proc~colorize_str->proc~chars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~colorize_str~~CalledByGraph proc~colorize_str string%colorize_str none~colorize string%colorize none~colorize->proc~colorize_str program~volatile_doctest~90 volatile_doctest program~volatile_doctest~90->none~colorize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function colorize_str ( self , color_fg , color_bg , style ) result ( colorized ) !< Colorize and stylize strings, DEFAULT kind. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%colorize(color_fg='red')=='\u001b[31msay all Hello WorLD!\u001b[0m' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :), allocatable :: colorized !< Colorized string. colorized = colorize ( string = self % chars (), color_fg = color_fg , color_bg = color_bg , style = style ) endfunction colorize_str","tags":"","loc":"proc/colorize_str.html"},{"title":"decode – StringiFor","text":"private elemental function decode(self, codec) result(decoded) Return a string decoded accordingly the codec. @note Note\n      Only BASE64 codec is currently available. type ( string ) :: astring astring = 'SG93IGFyZSB5b3U/' print '(L1)' , astring % decode ( codec = 'base64' ) // '' == 'How are you?' Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. Calls proc~~decode~~CallsGraph proc~decode string%decode b64_decode b64_decode proc~decode->b64_decode proc~strip string%strip proc~decode->proc~strip proc~upper string%upper proc~decode->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~decode~~CalledByGraph proc~decode string%decode program~volatile_doctest~32 volatile_doctest program~volatile_doctest~32->proc~decode Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function decode ( self , codec ) result ( decoded ) !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(L1)', astring%decode(codec='base64')//''=='How are you?' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif endfunction decode","tags":"","loc":"proc/decode.html"},{"title":"encode – StringiFor","text":"private elemental function encode(self, codec) result(encoded) Return a string encoded accordingly the codec. @note Note\n      Only BASE64 codec is currently available. type ( string ) :: astring astring = 'How are you?' print '(L1)' , astring % encode ( codec = 'base64' ) // '' == 'SG93IGFyZSB5b3U/' Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. Calls proc~~encode~~CallsGraph proc~encode string%encode b64_encode b64_encode proc~encode->b64_encode proc~upper string%upper proc~encode->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~encode~~CalledByGraph proc~encode string%encode program~volatile_doctest~16 volatile_doctest program~volatile_doctest~16->proc~encode Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function encode ( self , codec ) result ( encoded ) !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(L1)', astring%encode(codec='base64')//''=='SG93IGFyZSB5b3U/' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif endfunction encode","tags":"","loc":"proc/encode.html"},{"title":"escape – StringiFor","text":"private elemental function escape(self, to_escape, esc) result(escaped) Escape backslashes (or custom escape character). type ( string ) :: astring logical :: test_passed ( 2 ) astring = '&#94;\\s \\d+\\s*' test_passed ( 1 ) = astring % escape ( to_escape = '\\')//''==' &#94;\\\\ s \\\\ d + \\\\ s * ' test_passed(2) = astring%escape(to_escape=' \\ ', esc=' | ')//''==' &#94;|\\ s |\\ d + |\\ s * ' print ' ( L1 ) ' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK, len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Called by proc~~escape~~CalledByGraph proc~escape string%escape program~volatile_doctest~63 volatile_doctest program~volatile_doctest~63->proc~escape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function escape ( self , to_escape , esc ) result ( escaped ) !< Escape backslashes (or custom escape character). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '&#94;\\s \\d+\\s*' !< test_passed(1) = astring%escape(to_escape='\\')//''=='&#94;\\\\s \\\\d+\\\\s*' !< test_passed(2) = astring%escape(to_escape='\\', esc='|')//''=='&#94;|\\s |\\d+|\\s*' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif endfunction escape","tags":"","loc":"proc/escape.html"},{"title":"extension – StringiFor","text":"private elemental function extension(self) Return the extension of a string containing a file name. type ( string ) :: astring astring = '/bar/foo.tar.bz2' print '(L1)' , astring % extension () // '' == '.bz2' Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Called by proc~~extension~~CalledByGraph proc~extension string%extension program~volatile_doctest~22 volatile_doctest program~volatile_doctest~22->proc~extension Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function basename ( self , sep , extension , strip_last_extension ) !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(5) !< astring = 'bar/foo.tar.bz2' !< test_passed(1) = astring%basename()//''=='foo.tar.bz2' !< test_passed(2) = astring%basename(extension='.tar.bz2')//''=='foo' !< test_passed(3) = astring%basename(strip_last_extension=.true.)//''=='foo.tar' !< astring = '\\bar\\foo.tar.bz2' !< test_passed(4) = astring%basename(sep='\\')//''=='foo.tar.bz2' !< astring = 'bar' !< test_passed(5) = astring%basename(strip_last_extension=.true.)//''=='bar' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) if ( present ( extension )) then pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then pos = index ( basename % raw , '.' , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) endif endif endif endfunction basename elemental function camelcase ( self , sep ) !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(L1)', astring%camelcase()//''=='CamelCaseVar' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !< Return a string with its first character capitalized and the rest lowercased. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%capitalize()//''=='Say all hello world!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif endfunction capitalize pure function chars ( self ) result ( raw ) !< Return the raw characters data. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%chars()=='say all Hello WorLD!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif endfunction chars pure function colorize_str ( self , color_fg , color_bg , style ) result ( colorized ) !< Colorize and stylize strings, DEFAULT kind. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%colorize(color_fg='red')=='\u001b[31msay all Hello WorLD!\u001b[0m' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :), allocatable :: colorized !< Colorized string. colorized = colorize ( string = self % chars (), color_fg = color_fg , color_bg = color_bg , style = style ) endfunction colorize_str elemental function decode ( self , codec ) result ( decoded ) !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(L1)', astring%decode(codec='base64')//''=='How are you?' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif endfunction decode elemental function encode ( self , codec ) result ( encoded ) !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(L1)', astring%encode(codec='base64')//''=='SG93IGFyZSB5b3U/' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif endfunction encode elemental function escape ( self , to_escape , esc ) result ( escaped ) !< Escape backslashes (or custom escape character). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '&#94;\\s \\d+\\s*' !< test_passed(1) = astring%escape(to_escape='\\')//''=='&#94;\\\\s \\\\d+\\\\s*' !< test_passed(2) = astring%escape(to_escape='\\', esc='|')//''=='&#94;|\\s |\\d+|\\s*' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif endfunction escape elemental function extension ( self ) !< Return the extension of a string containing a file name. !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(L1)', astring%extension()//''=='.bz2' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) if ( pos > 0 ) extension % raw = self % raw ( pos :) endif endfunction extension","tags":"","loc":"proc/extension.html"},{"title":"fill – StringiFor","text":"private elemental function fill(self, width, right, filling_char) result(filled) Pad string on the left (or right) with zeros (or other char) to fill width. type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'this is string example....wow!!!' test_passed ( 1 ) = astring % fill ( width = 40 ) // '' == '00000000this is string example....wow!!!' test_passed ( 2 ) = astring % fill ( width = 50 ) // '' == '000000000000000000this is string example....wow!!!' test_passed ( 3 ) = astring % fill ( width = 50 , right = . true .) // '' == 'this is string example....wow!!!000000000000000000' test_passed ( 4 ) = astring % fill ( width = 40 , filling_char = '*' ) // '' == '********this is string example....wow!!!' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK, len=1), intent(in), optional :: filling_char Filling character (default “0”). Return Value type( string ) Filled string. Called by proc~~fill~~CalledByGraph proc~fill string%fill program~volatile_doctest~7 volatile_doctest program~volatile_doctest~7->proc~fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function fill ( self , width , right , filling_char ) result ( filled ) !< Pad string on the left (or right) with zeros (or other char) to fill width. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = 'this is string example....wow!!!' !< test_passed(1) = astring%fill(width=40)//''=='00000000this is string example....wow!!!' !< test_passed(2) = astring%fill(width=50)//''=='000000000000000000this is string example....wow!!!' !< test_passed(3) = astring%fill(width=50, right=.true.)//''=='this is string example....wow!!!000000000000000000' !< test_passed(4) = astring%fill(width=40, filling_char='*')//''=='********this is string example....wow!!!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif endfunction fill","tags":"","loc":"proc/fill.html"},{"title":"insert_character – StringiFor","text":"private elemental function insert_character(self, substring, pos) result(inserted) Insert substring into string at a specified position. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 5 ) astring = 'this is string example wow!!!' acharacter = '... ' test_passed ( 1 ) = astring % insert ( substring = acharacter , pos = 1 ) // '' == '... this is string example wow!!!' test_passed ( 2 ) = astring % insert ( substring = acharacter , pos = 23 ) // '' == 'this is string example...  wow!!!' test_passed ( 3 ) = astring % insert ( substring = acharacter , pos = 29 ) // '' == 'this is string example wow!!!... ' test_passed ( 4 ) = astring % insert ( substring = acharacter , pos =- 1 ) // '' == '... this is string example wow!!!' test_passed ( 5 ) = astring % insert ( substring = acharacter , pos = 100 ) // '' == 'this is string example wow!!!... ' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Called by proc~~insert_character~~CalledByGraph proc~insert_character string%insert_character none~insert string%insert none~insert->proc~insert_character program~volatile_doctest~104 volatile_doctest program~volatile_doctest~104->none~insert program~volatile_doctest~46 volatile_doctest program~volatile_doctest~46->none~insert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function insert_character ( self , substring , pos ) result ( inserted ) !< Insert substring into string at a specified position. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(5) !< astring = 'this is string example wow!!!' !< acharacter = '... ' !< test_passed(1) = astring%insert(substring=acharacter, pos=1)//''=='... this is string example wow!!!' !< test_passed(2) = astring%insert(substring=acharacter, pos=23)//''=='this is string example...  wow!!!' !< test_passed(3) = astring%insert(substring=acharacter, pos=29)//''=='this is string example wow!!!... ' !< test_passed(4) = astring%insert(substring=acharacter, pos=-1)//''=='... this is string example wow!!!' !< test_passed(5) = astring%insert(substring=acharacter, pos=100)//''=='this is string example wow!!!... ' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. if ( allocated ( self % raw )) then inserted = self safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring // self % raw ( safepos :) endif else inserted % raw = substring endif endfunction insert_character","tags":"","loc":"proc/insert_character.html"},{"title":"insert_string – StringiFor","text":"private elemental function insert_string(self, substring, pos) result(inserted) Insert substring into string at a specified position. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 5 ) astring = 'this is string example wow!!!' anotherstring = '... ' test_passed ( 1 ) = astring % insert ( substring = anotherstring , pos = 1 ) // '' == '... this is string example wow!!!' test_passed ( 2 ) = astring % insert ( substring = anotherstring , pos = 23 ) // '' == 'this is string example...  wow!!!' test_passed ( 3 ) = astring % insert ( substring = anotherstring , pos = 29 ) // '' == 'this is string example wow!!!... ' test_passed ( 4 ) = astring % insert ( substring = anotherstring , pos =- 1 ) // '' == '... this is string example wow!!!' test_passed ( 5 ) = astring % insert ( substring = anotherstring , pos = 100 ) // '' == 'this is string example wow!!!... ' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Called by proc~~insert_string~~CalledByGraph proc~insert_string string%insert_string none~insert string%insert none~insert->proc~insert_string program~volatile_doctest~104 volatile_doctest program~volatile_doctest~104->none~insert program~volatile_doctest~46 volatile_doctest program~volatile_doctest~46->none~insert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function insert_string ( self , substring , pos ) result ( inserted ) !< Insert substring into string at a specified position. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(5) !< astring = 'this is string example wow!!!' !< anotherstring = '... ' !< test_passed(1) = astring%insert(substring=anotherstring, pos=1)//''=='... this is string example wow!!!' !< test_passed(2) = astring%insert(substring=anotherstring, pos=23)//''=='this is string example...  wow!!!' !< test_passed(3) = astring%insert(substring=anotherstring, pos=29)//''=='this is string example wow!!!... ' !< test_passed(4) = astring%insert(substring=anotherstring, pos=-1)//''=='... this is string example wow!!!' !< test_passed(5) = astring%insert(substring=anotherstring, pos=100)//''=='this is string example wow!!!... ' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. if ( allocated ( self % raw )) then inserted = self if ( allocated ( substring % raw )) then safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring % raw // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring % raw else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring % raw // self % raw ( safepos :) endif endif else if ( allocated ( substring % raw )) inserted % raw = substring % raw endif endfunction insert_string","tags":"","loc":"proc/insert_string.html"},{"title":"join_strings – StringiFor","text":"private pure function join_strings(self, array, sep) result(join) Return a string that is a join of an array of strings. The join-separator is set equals to self if self has a value or it is set to a null string ‘’. This value can be overridden\n passing a custom separator. type ( string ) :: astring type ( string ) :: strings ( 3 ) logical :: test_passed ( 5 ) strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 1 ) = ( astring % join ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) test_passed ( 2 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 3 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free test_passed ( 4 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' test_passed ( 5 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Called by proc~~join_strings~~CalledByGraph proc~join_strings string%join_strings none~join string%join none~join->proc~join_strings proc~camelcase string%camelcase proc~camelcase->none~join proc~snakecase string%snakecase proc~snakecase->none~join proc~startcase string%startcase proc~startcase->none~join program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->none~join program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->none~join program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->none~join program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->none~join program~volatile_doctest~57 volatile_doctest program~volatile_doctest~57->none~join program~volatile_doctest~61 volatile_doctest program~volatile_doctest~61->none~join program~volatile_doctest~18 volatile_doctest program~volatile_doctest~18->proc~camelcase program~volatile_doctest~2 volatile_doctest program~volatile_doctest~2->proc~startcase program~volatile_doctest~98 volatile_doctest program~volatile_doctest~98->proc~snakecase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function join_strings ( self , array , sep ) result ( join ) !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !< !<```fortran !< type(string) :: astring !< type(string) :: strings(3) !< logical      :: test_passed(5) !< strings(1) = 'one' !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(1) = (astring%join(array=strings)//''==strings(1)//strings(2)//strings(3)) !< test_passed(2) = (astring%join(array=strings, sep='-')//''==strings(1)//'-'//strings(2)//'-'//strings(3)) !< call strings(1)%free !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(3) = (astring%join(array=strings, sep='-')//''==strings(2)//'-'//strings(3)) !< strings(1) = 'one' !< strings(2) = 'two' !< call strings(3)%free !< test_passed(4) = (astring%join(array=strings, sep='-')//''==strings(1)//'-'//strings(2)) !< strings(1) = 'one' !< call strings(2)%free !< strings(3) = 'three' !< test_passed(5) = (astring%join(array=strings, sep='-')//''==strings(1)//'-'//strings(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction join_strings","tags":"","loc":"proc/join_strings.html"},{"title":"join_characters – StringiFor","text":"private pure function join_characters(self, array, sep) result(join) Return a string that is a join of an array of characters. The join-separator is set equals to self if self has a value or it is set to a null string ‘’. This value can be overridden\n passing a custom separator. type ( string ) :: astring character ( 5 ) :: characters ( 3 ) logical :: test_passed ( 6 ) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 1 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) test_passed ( 2 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 3 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 4 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 5 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' astring = '_' test_passed ( 6 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // '_' // characters ( 2 ) // '_' // characters ( 3 )) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Called by proc~~join_characters~~CalledByGraph proc~join_characters string%join_characters none~join string%join none~join->proc~join_characters proc~camelcase string%camelcase proc~camelcase->none~join proc~snakecase string%snakecase proc~snakecase->none~join proc~startcase string%startcase proc~startcase->none~join program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->none~join program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->none~join program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->none~join program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->none~join program~volatile_doctest~57 volatile_doctest program~volatile_doctest~57->none~join program~volatile_doctest~61 volatile_doctest program~volatile_doctest~61->none~join program~volatile_doctest~18 volatile_doctest program~volatile_doctest~18->proc~camelcase program~volatile_doctest~2 volatile_doctest program~volatile_doctest~2->proc~startcase program~volatile_doctest~98 volatile_doctest program~volatile_doctest~98->proc~snakecase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function join_characters ( self , array , sep ) result ( join ) !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !< !<```fortran !< type(string) :: astring !< character(5) :: characters(3) !< logical      :: test_passed(6) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(1) = (astring%join(array=characters)//''==characters(1)//characters(2)//characters(3)) !< test_passed(2) = (astring%join(array=characters, sep='-')//''==characters(1)//'-'//characters(2)//'-'//characters(3)) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(3) = (astring%join(array=characters, sep='-')//''==characters(2)//'-'//characters(3)) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(4) = (astring%join(array=characters, sep='-')//''==characters(1)//'-'//characters(2)) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(5) = (astring%join(array=characters, sep='-')//''==characters(1)//'-'//characters(3)) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = 'three' !< astring = '_' !< test_passed(6) = (astring%join(array=characters)//''==characters(1)//'_'//characters(2)//'_'//characters(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction join_characters","tags":"","loc":"proc/join_characters.html"},{"title":"strjoin_strings – StringiFor","text":"private pure function strjoin_strings(array, sep) result(join) Return a string that is a join of an array of strings. The join-separator is set equals to a null string ‘’ if custom separator isn’t specified. type ( string ) :: strings ( 3 ) logical :: test_passed ( 5 ) strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 1 ) = ( strjoin ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) test_passed ( 2 ) = ( strjoin ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 3 ) = ( strjoin ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free test_passed ( 4 ) = ( strjoin ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' test_passed ( 5 ) = ( strjoin ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Called by proc~~strjoin_strings~~CalledByGraph proc~strjoin_strings string%strjoin_strings interface~strjoin strjoin interface~strjoin->proc~strjoin_strings proc~strjoin_strings_array string%strjoin_strings_array interface~strjoin->proc~strjoin_strings_array proc~strjoin_strings_array->proc~strjoin_strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function strjoin_strings ( array , sep ) result ( join ) !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< !<```fortran !< type(string)     :: strings(3) !< logical          :: test_passed(5) !< strings(1) = 'one' !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(1) = (strjoin(array=strings)//''==strings(1)//strings(2)//strings(3)) !< test_passed(2) = (strjoin(array=strings, sep='-')//''==strings(1)//'-'//strings(2)//'-'//strings(3)) !< call strings(1)%free !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(3) = (strjoin(array=strings, sep='-')//''==strings(2)//'-'//strings(3)) !< strings(1) = 'one' !< strings(2) = 'two' !< call strings(3)%free !< test_passed(4) = (strjoin(array=strings, sep='-')//''==strings(1)//'-'//strings(2)) !< strings(1) = 'one' !< call strings(2)%free !< strings(3) = 'three' !< test_passed(5) = (strjoin(array=strings, sep='-')//''==strings(1)//'-'//strings(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. sep_ = '' if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction strjoin_strings","tags":"","loc":"proc/strjoin_strings.html"},{"title":"strjoin_characters – StringiFor","text":"private pure function strjoin_characters(array, sep, is_trim) result(join) Return a string that is a join of an array of characters. The join-separator is set equals to a null string ‘’ if custom separator isn’t specified.\n The trim function is applied to array items if optional logical is_trim variable isn’t set to .false. character ( 5 ) :: characters ( 3 ) logical :: test_passed ( 13 ) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 1 ) = ( strjoin ( array = characters ) // '' == trim ( characters ( 1 )) // trim ( characters ( 2 )) // trim ( characters ( 3 ))) test_passed ( 2 ) = ( strjoin ( array = characters , sep = '-' ) // '' == trim ( characters ( 1 )) // '-' // trim ( characters ( 2 )) // '-' // trim ( characters ( 3 ))) test_passed ( 3 ) = ( strjoin ( array = characters , is_trim = . false .) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) test_passed ( 4 ) = ( strjoin ( array = characters , sep = '-' , is_trim = . false .) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 5 ) = ( strjoin ( array = characters ) // '' == trim ( characters ( 2 )) // trim ( characters ( 3 ))) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 6 ) = ( strjoin ( array = characters ) // '' == trim ( characters ( 1 )) // trim ( characters ( 2 ))) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 7 ) = ( strjoin ( array = characters ) // '' == trim ( characters ( 1 )) // trim ( characters ( 3 ))) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 8 ) = ( strjoin ( array = characters , sep = '-' ) // '' == trim ( characters ( 2 )) // '-' // trim ( characters ( 3 ))) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 9 ) = ( strjoin ( array = characters , sep = '-' ) // '' == trim ( characters ( 1 )) // '-' // trim ( characters ( 2 ))) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 10 ) = ( strjoin ( array = characters , sep = '-' ) // '' == trim ( characters ( 1 )) // '-' // trim ( characters ( 3 ))) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 11 ) = ( strjoin ( array = characters , sep = '-' , is_trim = . false .) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 12 ) = ( strjoin ( array = characters , sep = '-' , is_trim = . false .) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 13 ) = ( strjoin ( array = characters , sep = '-' , is_trim = . false .) // '' == characters ( 1 ) // '-' // characters ( 3 )) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not Return Value type( string ) The join of array. Called by proc~~strjoin_characters~~CalledByGraph proc~strjoin_characters string%strjoin_characters interface~strjoin strjoin interface~strjoin->proc~strjoin_characters proc~strjoin_characters_array string%strjoin_characters_array interface~strjoin->proc~strjoin_characters_array proc~strjoin_characters_array->proc~strjoin_characters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function strjoin_characters ( array , sep , is_trim ) result ( join ) !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< The trim function is applied to array items if optional logical is_trim variable isn't set to .false. !< !<```fortran !< character(5) :: characters(3) !< logical      :: test_passed(13) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(1) = (strjoin(array=characters)//''==trim(characters(1))//trim(characters(2))//trim(characters(3))) !< test_passed(2) = (strjoin(array=characters, sep='-')//''==trim(characters(1))//'-'//trim(characters(2))//'-'//trim(characters(3))) !< test_passed(3) = ( strjoin(array=characters, is_trim=.false.)//''==characters(1)//characters(2)//characters(3)) !< test_passed(4) = ( strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(1)//'-'//characters(2)//'-'//characters(3)) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(5) = (strjoin(array=characters)//''==trim(characters(2))//trim(characters(3))) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(6) = (strjoin(array=characters)//''==trim(characters(1))//trim(characters(2))) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(7) = (strjoin(array=characters)//''==trim(characters(1))//trim(characters(3))) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(8) = (strjoin(array=characters, sep='-')//''==trim(characters(2))//'-'//trim(characters(3))) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(9) = (strjoin(array=characters, sep='-')//''==trim(characters(1))//'-'//trim(characters(2))) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(10) = (strjoin(array=characters, sep='-')//''==trim(characters(1))//'-'//trim(characters(3))) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(11) = (strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(2)//'-'//characters(3)) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(12) = (strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(1)//'-'//characters(2)) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(13) = (strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(1)//'-'//characters(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. logical , intent ( in ), optional :: is_trim !< Flag to setup trim character or not type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. logical :: is_trim_ !< Flag to setup trim character or not integer :: a !< Counter. sep_ = '' if ( present ( sep )) sep_ = sep is_trim_ = . true . ; if ( present ( is_trim )) is_trim_ = is_trim join = '' if ( is_trim_ ) then do a = 2 , size ( array , dim = 1 ) if ( trim ( array ( a )) /= '' ) join % raw = join % raw // sep_ // trim ( array ( a )) enddo if ( trim ( array ( 1 )) /= '' ) then join % raw = trim ( array ( 1 )) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif else do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endif endfunction strjoin_characters","tags":"","loc":"proc/strjoin_characters.html"},{"title":"strjoin_strings_array – StringiFor","text":"private pure function strjoin_strings_array(array, sep, is_col) result(join) Return a string that is a join of columns or rows of an array of strings. The join-separator is set equals to a null string ‘’ if custom separator isn’t specified.\n The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). type ( string ), allocatable :: strings_arr (:, :) logical :: test_passed ( 5 ) strings_arr = reshape ( source = & [ string ( 'one' ), string ( 'two' ), string ( 'three' ), & string ( 'ONE' ), string ( 'TWO' ), string ( 'THREE' )], & shape = [ 3 , 2 ] ) test_passed ( 1 ) = all ( strjoin ( array = strings_arr ) == & reshape ([ string ( 'onetwothree' ), string ( 'ONETWOTHREE' )], & shape = [ 2 ]) ) test_passed ( 2 ) = all ( strjoin ( array = strings_arr , sep = '_' ) == & reshape ([ string ( 'one_two_three' ), string ( 'ONE_TWO_THREE' )], & shape = [ 2 ]) ) test_passed ( 3 ) = all ( strjoin ( array = strings_arr , is_col = . false .) == & reshape ([ string ( 'oneONE' ), string ( 'twoTWO' ), string ( 'threeTHREE' )], & shape = [ 3 ]) ) test_passed ( 4 ) = all ( strjoin ( array = strings_arr , sep = '_' , is_col = . false .) == & reshape ([ string ( 'one_ONE' ), string ( 'two_TWO' ), string ( 'three_THREE' )], & shape = [ 3 ]) ) call strings_arr ( 2 , 1 )% free test_passed ( 5 ) = all ( strjoin ( array = strings_arr , sep = '_' , is_col = . false .) == & reshape ([ string ( 'one_ONE' ), string ( 'TWO' ), string ( 'three_THREE' )], & shape = [ 3 ]) ) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ), allocatable, (:) The join of array. Calls proc~~strjoin_strings_array~~CallsGraph proc~strjoin_strings_array string%strjoin_strings_array proc~strjoin_strings string%strjoin_strings proc~strjoin_strings_array->proc~strjoin_strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~strjoin_strings_array~~CalledByGraph proc~strjoin_strings_array string%strjoin_strings_array interface~strjoin strjoin interface~strjoin->proc~strjoin_strings_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function strjoin_strings_array ( array , sep , is_col ) result ( join ) !< Return a string that is a join of columns or rows of an array of strings. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). !< !<```fortran !< type(string), allocatable :: strings_arr(:, :) !< logical                   :: test_passed(5) !< !< strings_arr = reshape( source = & !<                        [string('one'), string('two'), string('three'),  & !<                         string('ONE'), string('TWO'), string('THREE')], & !<                        shape = [3, 2] ) !< !< test_passed(1) = all( strjoin(array=strings_arr) == & !<                       reshape([string('onetwothree'), string('ONETWOTHREE')], & !<                       shape = [2]) ) !< !< test_passed(2) = all( strjoin(array=strings_arr, sep='_') == & !<                       reshape([string('one_two_three'), string('ONE_TWO_THREE')], & !<                       shape = [2]) ) !< !<  test_passed(3) = all( strjoin(array=strings_arr, is_col=.false.) == & !<                        reshape([string('oneONE'), string('twoTWO'), string('threeTHREE')], & !<                        shape = [3]) ) !< !<  test_passed(4) = all( strjoin(array=strings_arr, sep='_', is_col=.false.) == & !<                        reshape([string('one_ONE'), string('two_TWO'), string('three_THREE')], & !<                        shape = [3]) ) !< !< call strings_arr(2, 1)%free !< test_passed(5) = all( strjoin(array=strings_arr, sep='_', is_col=.false.) == & !<                  reshape([string('one_ONE'), string('TWO'), string('three_THREE')], & !<                  shape = [3]) ) !< !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: array ( 1 :, 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. logical , intent ( in ), optional :: is_col !< Direction: 'columns' if .true. or 'rows' if .false. type ( string ), allocatable :: join (:) !< The join of array. type ( string ), allocatable :: slice (:) !< The column or row slice of array character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. logical :: is_col_ !< Direction, default value. integer :: a , join_size , slice_size !< Counter, sizes of join vector and of slice of array sep_ = '' ; if ( present ( sep )) sep_ = sep is_col_ = . true . ; if ( present ( is_col )) is_col_ = is_col if ( is_col_ ) then join_size = size ( array , dim = 2 ) slice_size = size ( array , dim = 1 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( slice ( slice_size )) do a = 1 , join_size slice (:) = array (:, a ) join ( a ) = strjoin_strings ( slice , sep_ ) end do else join_size = size ( array , dim = 1 ) slice_size = size ( array , dim = 2 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( slice ( slice_size )) do a = 1 , join_size slice (:) = array ( a , :) join ( a ) = strjoin_strings ( slice , sep_ ) end do endif endfunction strjoin_strings_array","tags":"","loc":"proc/strjoin_strings_array.html"},{"title":"strjoin_characters_array – StringiFor","text":"private pure function strjoin_characters_array(array, sep, is_trim, is_col) result(join) Return a string that is a join of columns or rows of an array of characters. The join-separator is set equals to a null string ‘’ if custom separator isn’t specified.\n The trim function is applied to array items if optional logical is_trim variable isn’t set to .false.\n The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). character ( len = 10 ) :: chars_arr ( 3 , 2 ) logical :: test_passed ( 9 ) chars_arr (:, 1 ) = [ 'one       ' , 'two       ' , 'three     ' ] chars_arr (:, 2 ) = [ 'ONE       ' , 'TWO       ' , 'THREE     ' ] test_passed ( 1 ) = all ( strjoin ( array = chars_arr ) == & reshape ([ string ( 'onetwothree' ), string ( 'ONETWOTHREE' )], & shape = [ 2 ]) ) test_passed ( 2 ) = all ( strjoin ( array = chars_arr , is_trim = . false .) == & reshape ([ string ( 'one       two       three     ' ), & string ( 'ONE       TWO       THREE     ' )], & shape = [ 2 ]) ) test_passed ( 3 ) = all ( strjoin ( array = chars_arr , sep = '_' ) == & reshape ([ string ( 'one_two_three' ), string ( 'ONE_TWO_THREE' )], & shape = [ 2 ]) ) test_passed ( 4 ) = all ( strjoin ( array = chars_arr , sep = '_' , is_trim = . false .) == & reshape ([ string ( 'one       _two       _three     ' ), & string ( 'ONE       _TWO       _THREE     ' )], & shape = [ 2 ]) ) test_passed ( 5 ) = all ( strjoin ( array = chars_arr , is_col = . false .) == & reshape ([ string ( 'oneONE' ), string ( 'twoTWO' ), string ( 'threeTHREE' )], & shape = [ 3 ]) ) test_passed ( 6 ) = all ( strjoin ( array = chars_arr , is_trim = . false ., is_col = . false .) == & reshape ([ string ( 'one       ONE       ' ), & string ( 'two       TWO       ' ), & string ( 'three     THREE     ' )], & shape = [ 3 ]) ) test_passed ( 7 ) = all ( strjoin ( array = chars_arr , sep = '_' , is_col = . false .) == & reshape ([ string ( 'one_ONE' ), string ( 'two_TWO' ), string ( 'three_THREE' )], & shape = [ 3 ]) ) test_passed ( 8 ) = all ( strjoin ( array = chars_arr , sep = '_' , is_trim = . false ., is_col = . false .) == & reshape ([ string ( 'one       _ONE       ' ), & string ( 'two       _TWO       ' ), & string ( 'three     _THREE     ' )], & shape = [ 3 ]) ) chars_arr ( 2 , 1 ) = '' test_passed ( 9 ) = all ( strjoin ( array = chars_arr , sep = '_' , is_col = . false .) == & reshape ([ string ( 'one_ONE' ), & string ( 'TWO' ), & string ( 'three_THREE' )], & shape = [ 3 ]) ) print '(L1)' , all ( test_passed ) all items of character array have equal lengths Type Bound string Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ), allocatable, (:) The join of array. Calls proc~~strjoin_characters_array~~CallsGraph proc~strjoin_characters_array string%strjoin_characters_array proc~strjoin_characters string%strjoin_characters proc~strjoin_characters_array->proc~strjoin_characters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~strjoin_characters_array~~CalledByGraph proc~strjoin_characters_array string%strjoin_characters_array interface~strjoin strjoin interface~strjoin->proc~strjoin_characters_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function strjoin_characters_array ( array , sep , is_trim , is_col ) result ( join ) !< Return a string that is a join of columns or rows of an array of characters. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< The trim function is applied to array items if optional logical is_trim variable isn't set to .false. !< The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). !< !<```fortran !< character(len=10)         :: chars_arr(3, 2) !< logical                   :: test_passed(9) !< chars_arr(:, 1) = ['one       ', 'two       ', 'three     '] !< chars_arr(:, 2) = ['ONE       ', 'TWO       ', 'THREE     '] !< !< test_passed(1) = all( strjoin(array=chars_arr) == & !<                       reshape([string('onetwothree'), string('ONETWOTHREE')], & !<                       shape = [2]) ) !< !< test_passed(2) = all( strjoin(array=chars_arr, is_trim=.false.) ==  & !<                       reshape([string('one       two       three     '),  & !<                                string('ONE       TWO       THREE     ')], & !<                       shape = [2]) ) !< !< test_passed(3) = all( strjoin(array=chars_arr, sep='_') == & !<                       reshape([string('one_two_three'), string('ONE_TWO_THREE')], & !<                       shape = [2]) ) !< !< test_passed(4) = all( strjoin(array=chars_arr, sep='_', is_trim=.false.) ==  & !<                       reshape([string('one       _two       _three     '),  & !<                                string('ONE       _TWO       _THREE     ')], & !<                       shape = [2]) ) !< !< test_passed(5) = all( strjoin(array=chars_arr, is_col=.false.) == & !<                       reshape([string('oneONE'), string('twoTWO'), string('threeTHREE')], & !<                       shape = [3]) ) !< !< test_passed(6) = all( strjoin(array=chars_arr, is_trim=.false., is_col=.false.) ==  & !<                       reshape([string('one       ONE       '),  & !<                                string('two       TWO       '),  & !<                                string('three     THREE     ')], & !<                       shape = [3]) ) !< !< test_passed(7) = all( strjoin(array=chars_arr, sep='_', is_col=.false.) == & !<                       reshape([string('one_ONE'), string('two_TWO'), string('three_THREE')], & !<                       shape = [3]) ) !< !< test_passed(8) = all( strjoin(array=chars_arr, sep='_', is_trim=.false., is_col=.false.) ==  & !<                       reshape([string('one       _ONE       '),  & !<                                string('two       _TWO       '),  & !<                                string('three     _THREE     ')], & !<                       shape = [3]) ) !< !< chars_arr(2,1) = '' !< test_passed(9) = all( strjoin(array=chars_arr, sep='_', is_col=.false.) ==  & !<                       reshape([string('one_ONE'),  & !<                                string('TWO'),  & !<                                string('three_THREE')], & !<                       shape = [3]) ) !< !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :, 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. logical , intent ( in ), optional :: is_trim !< Flag to setup trim character or not logical , intent ( in ), optional :: is_col !< Direction: 'columns' if .true. or 'rows' if .false. type ( string ), allocatable :: join (:) !< The join of array. character ( kind = CK , len = :), allocatable :: slice (:) !< The column or row slice of array character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. logical :: is_trim_ !< Flag to setup trim character or not logical :: is_col_ !< Direction, default value. integer :: a , join_size , slice_size !< Counter, sizes of join vector and of slice of array integer :: item_len !< Length of array item (all items of character array have equal lengths) item_len = len ( array ( 1 , 1 )) !< all items of character array have equal lengths sep_ = '' ; if ( present ( sep )) sep_ = sep is_trim_ = . true . ; if ( present ( is_trim )) is_trim_ = is_trim is_col_ = . true . ; if ( present ( is_col )) is_col_ = is_col if ( is_col_ ) then join_size = size ( array , dim = 2 ) slice_size = size ( array , dim = 1 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( character ( len = item_len ) :: slice ( slice_size )) do a = 1 , join_size slice (:) = array (:, a ) join ( a ) = strjoin_characters ( slice , sep_ , is_trim_ ) end do else join_size = size ( array , dim = 1 ) slice_size = size ( array , dim = 2 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( character ( len = item_len ) :: slice ( slice_size )) do a = 1 , join_size slice (:) = array ( a , :) join ( a ) = strjoin_characters ( slice , sep_ , is_trim_ ) end do endif endfunction strjoin_characters_array","tags":"","loc":"proc/strjoin_characters_array.html"},{"title":"lower – StringiFor","text":"private elemental function lower(self) Return a string with all lowercase characters. type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % lower () // '' == 'hello world!' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Called by proc~~lower~~CalledByGraph proc~lower string%lower proc~capitalize string%capitalize proc~capitalize->proc~lower proc~snakecase string%snakecase proc~snakecase->proc~lower program~volatile_doctest~20 volatile_doctest program~volatile_doctest~20->proc~lower proc~camelcase string%camelcase proc~camelcase->proc~capitalize proc~startcase string%startcase proc~startcase->proc~capitalize program~volatile_doctest~81 volatile_doctest program~volatile_doctest~81->proc~capitalize program~volatile_doctest~98 volatile_doctest program~volatile_doctest~98->proc~snakecase program~volatile_doctest~18 volatile_doctest program~volatile_doctest~18->proc~camelcase program~volatile_doctest~2 volatile_doctest program~volatile_doctest~2->proc~startcase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function lower ( self ) !< Return a string with all lowercase characters. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%lower()//''=='hello world!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif endfunction lower","tags":"","loc":"proc/lower.html"},{"title":"partition – StringiFor","text":"private pure function partition(self, sep) result(partitions) Split string at separator and return the 3 parts (before, the separator and after). type ( string ) :: astring type ( string ) :: strings ( 3 ) logical :: test_passed ( 3 ) astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ), (1:3) after the separator. Called by proc~~partition~~CalledByGraph proc~partition string%partition proc~split string%split proc~split->proc~partition program~volatile_doctest~92 volatile_doctest program~volatile_doctest~92->proc~partition proc~camelcase string%camelcase proc~camelcase->proc~split proc~glob_string string%glob_string proc~glob_string->proc~split proc~snakecase string%snakecase proc~snakecase->proc~split proc~split_chunked string%split_chunked proc~split_chunked->proc~split proc~startcase string%startcase proc~startcase->proc~split proc~write_lines~2 string%write_lines proc~write_lines~2->proc~split program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~split program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~split program~stringifor_test_parse_large_csv->proc~split_chunked program~volatile_doctest~107 volatile_doctest program~volatile_doctest~107->proc~split program~volatile_doctest~15 volatile_doctest program~volatile_doctest~15->proc~split program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~split program~volatile_doctest~23 volatile_doctest program~volatile_doctest~23->proc~split program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~split proc~write_file~2 string%write_file program~volatile_doctest~44->proc~write_file~2 interface~glob glob interface~glob->proc~glob_string proc~glob_character string%glob_character interface~glob->proc~glob_character none~glob string%glob none~glob->proc~glob_string none~glob->proc~glob_character proc~write_file~2->proc~write_lines~2 program~volatile_doctest~18 volatile_doctest program~volatile_doctest~18->proc~camelcase program~volatile_doctest~2 volatile_doctest program~volatile_doctest~2->proc~startcase program~volatile_doctest~75 volatile_doctest program~volatile_doctest~75->proc~split_chunked program~volatile_doctest~98 volatile_doctest program~volatile_doctest~98->proc~snakecase proc~glob_character->none~glob program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->none~glob program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->none~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function partition ( self , sep ) result ( partitions ) !< Split string at separator and return the 3 parts (before, the separator and after). !< !<```fortran !< type(string) :: astring !< type(string) :: strings(3) !< logical      :: test_passed(3) !< astring = 'Hello WorLD!' !< strings = astring%partition(sep='lo Wo') !< test_passed(1) = (strings(1)//''=='Hel'.and.strings(2)//''=='lo Wo'.and.strings(3)//''=='rLD!') !< strings = astring%partition(sep='Hello') !< test_passed(2) = (strings(1)//''==''.and.strings(2)//''=='Hello'.and.strings(3)//''==' WorLD!') !< astring = 'Hello WorLD!' !< strings = astring%partition() !< test_passed(3) = (strings(1)//''=='Hello'.and.strings(2)//''==' '.and.strings(3)//''=='WorLD!') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) endif endif endfunction partition","tags":"","loc":"proc/partition.html"},{"title":"replace – StringiFor","text":"private elemental function replace(self, old, new, count) result(replaced) Return a string with all occurrences of substring old replaced by new. type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'When YOU are sad YOU should think to me :-)' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) astring = repeat ( new_line ( 'a' ) // 'abcd' , 20 ) astring = astring % replace ( old = new_line ( 'a' ), new = '|cr|' ) astring = astring % replace ( old = '|cr|' , new = new_line ( 'a' ) // '    ' ) test_passed ( 3 ) = ( astring // '' == repeat ( new_line ( 'a' ) // '    ' // 'abcd' , 20 )) astring = 'abcd  efg    hlmn' astring = astring % replace ( old = '' , new = '-' ) test_passed ( 4 ) = ( astring // '' == 'abcd  efg    hlmn' ) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: old Old substring. character(kind=CK, len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Calls proc~~replace~~CallsGraph proc~replace string%replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~replace~~CalledByGraph proc~replace string%replace proc~unique string%unique proc~unique->proc~replace program~volatile_doctest~62 volatile_doctest program~volatile_doctest~62->proc~replace proc~split string%split proc~split->proc~unique program~volatile_doctest~41 volatile_doctest program~volatile_doctest~41->proc~unique proc~camelcase string%camelcase proc~camelcase->proc~split proc~glob_string string%glob_string proc~glob_string->proc~split proc~snakecase string%snakecase proc~snakecase->proc~split proc~split_chunked string%split_chunked proc~split_chunked->proc~split proc~startcase string%startcase proc~startcase->proc~split proc~write_lines~2 string%write_lines proc~write_lines~2->proc~split program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~split program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~split program~stringifor_test_parse_large_csv->proc~split_chunked program~volatile_doctest~107 volatile_doctest program~volatile_doctest~107->proc~split program~volatile_doctest~15 volatile_doctest program~volatile_doctest~15->proc~split program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~split program~volatile_doctest~23 volatile_doctest program~volatile_doctest~23->proc~split program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~split proc~write_file~2 string%write_file program~volatile_doctest~44->proc~write_file~2 interface~glob glob interface~glob->proc~glob_string proc~glob_character string%glob_character interface~glob->proc~glob_character none~glob string%glob none~glob->proc~glob_string none~glob->proc~glob_character proc~write_file~2->proc~write_lines~2 program~volatile_doctest~18 volatile_doctest program~volatile_doctest~18->proc~camelcase program~volatile_doctest~2 volatile_doctest program~volatile_doctest~2->proc~startcase program~volatile_doctest~75 volatile_doctest program~volatile_doctest~75->proc~split_chunked program~volatile_doctest~98 volatile_doctest program~volatile_doctest~98->proc~snakecase proc~glob_character->none~glob program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->none~glob program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->none~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function replace ( self , old , new , count ) result ( replaced ) !< Return a string with all occurrences of substring old replaced by new. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = 'When YOU are sad YOU should think to me :-)' !< test_passed(1) = (astring%replace(old='YOU', new='THEY')//''=='When THEY are sad THEY should think to me :-)') !< test_passed(2) = (astring%replace(old='YOU', new='THEY', count=1)//''=='When THEY are sad YOU should think to me :-)') !< astring = repeat(new_line('a')//'abcd', 20) !< astring = astring%replace(old=new_line('a'), new='|cr|') !< astring = astring%replace(old='|cr|', new=new_line('a')//'    ') !< test_passed(3) = (astring//''==repeat(new_line('a')//'    '//'abcd', 20)) !< astring = 'abcd  efg    hlmn' !< astring = astring%replace(old='', new='-') !< test_passed(4) = (astring//''=='abcd  efg    hlmn') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. if ( allocated ( self % raw )) then replaced = self if ( len ( old ) == 0 ) return ! avoid infite loop for null substring replacement r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif endfunction replace","tags":"","loc":"proc/replace.html"},{"title":"reverse – StringiFor","text":"private elemental function reverse(self) result(reversed) Return a reversed string. type ( string ) :: astring logical :: test_passed ( 2 ) astring = 'abcdefghilmnopqrstuvz' test_passed ( 1 ) = ( astring % reverse () // '' == 'zvutsrqponmlihgfedcba' ) astring = '0123456789' test_passed ( 2 ) = ( astring % reverse () // '' == '9876543210' ) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Called by proc~~reverse~~CalledByGraph proc~reverse string%reverse program~volatile_doctest~109 volatile_doctest program~volatile_doctest~109->proc~reverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function reverse ( self ) result ( reversed ) !< Return a reversed string. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = 'abcdefghilmnopqrstuvz' !< test_passed(1) = (astring%reverse()//''=='zvutsrqponmlihgfedcba') !< astring = '0123456789' !< test_passed(2) = (astring%reverse()//''=='9876543210') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif endfunction reverse","tags":"","loc":"proc/reverse.html"},{"title":"search – StringiFor","text":"private  function search(self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Search for tagged record into string, return the first record found (if any) matching the tags. Optionally, returns the indexes of tag start/end, thus this is not an elemental function. @note Note\n      The tagged record is searched into self if allocated otherwise into in_string if passed or, eventually, into in_character is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are\n     zero. type ( string ) :: astring type ( string ) :: anotherstring character ( len = :), allocatable :: acharacter integer :: istart integer :: iend logical :: test_passed ( 5 ) astring = '<test> <first> hello </first> <first> not the first </first> </test>' anotherstring = astring % search ( tag_start = '<first>' , tag_end = '</first>' ) test_passed ( 1 ) = anotherstring // '' == '<first> hello </first>' astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' anotherstring = astring % search ( tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 2 ) = anotherstring // '' == '<a> <a> <a> the nested a </a> </a> </a>' call astring % free anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_string = anotherstring , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 3 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' call astring % free acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 4 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<sec>' , tag_end = '</sec>' , istart = istart , iend = iend ) test_passed ( 5 ) = astring // '' == acharacter ( 31 : 67 ) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: tag_start Start tag. character(kind=CK, len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK, len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Called by proc~~search~~CalledByGraph proc~search string%search program~volatile_doctest~69 volatile_doctest program~volatile_doctest~69->proc~search Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. !< !<```fortran !< type(string)                  :: astring !< type(string)                  :: anotherstring !< character(len=:), allocatable :: acharacter !< integer                       :: istart !< integer                       :: iend !< logical                       :: test_passed(5) !< astring = '<test> <first> hello </first> <first> not the first </first> </test>' !< anotherstring = astring%search(tag_start='<first>', tag_end='</first>') !< test_passed(1) = anotherstring//''=='<first> hello </first>' !< astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' !< anotherstring = astring%search(tag_start='<a>', tag_end='</a>') !< test_passed(2) = anotherstring//''=='<a> <a> <a> the nested a </a> </a> </a>' !< call astring%free !< anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' !< astring = astring%search(in_string=anotherstring, tag_start='<a>', tag_end='</a>') !< test_passed(3) = astring//''=='<a> <a> <a> the nested a </a> </a> </a>' !< call astring%free !< acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' !< astring = astring%search(in_character=acharacter, tag_start='<a>', tag_end='</a>') !< test_passed(4) = astring//''=='<a> <a> <a> the nested a </a> </a> </a>' !< acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' !< astring = astring%search(in_character=acharacter, tag_start='<sec>', tag_end='</sec>', istart=istart, iend=iend) !< test_passed(5) = astring//''==acharacter(31:67) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) raw = self % raw endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % count ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ endfunction search","tags":"","loc":"proc/search.html"},{"title":"slice – StringiFor","text":"private pure function slice(self, istart, iend) result(raw) Return the raw characters data sliced. type ( string ) :: astring astring = 'the Quick Brown fox Jumps over the Lazy Dog.' print \"(A)\" , astring % slice ( 11 , 25 ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK, len=:), allocatable Raw characters data. Called by proc~~slice~~CalledByGraph proc~slice string%slice program~volatile_doctest~96 volatile_doctest program~volatile_doctest~96->proc~slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function slice ( self , istart , iend ) result ( raw ) !< Return the raw characters data sliced. !< !<```fortran !< type(string) :: astring !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< print \"(A)\", astring%slice(11,25) !<``` !=> Brown fox Jumps <<< class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: istart !< Slice start index. integer , intent ( in ) :: iend !< Slice end   index. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. if ( allocated ( self % raw )) then raw = self % raw ( istart : iend ) else raw = '' endif endfunction slice","tags":"","loc":"proc/slice.html"},{"title":"snakecase – StringiFor","text":"private elemental function snakecase(self, sep) Return a string with all words lowercase separated by “_”. @note Note\n      Multiple subsequent separators are collapsed to one occurence. type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % snakecase () // '' == 'the_quick_brown_fox_jumps_over_the_lazy_dog.' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Calls proc~~snakecase~~CallsGraph proc~snakecase string%snakecase none~join string%join proc~snakecase->none~join proc~lower string%lower proc~snakecase->proc~lower proc~split string%split proc~snakecase->proc~split proc~join_characters string%join_characters none~join->proc~join_characters proc~join_strings string%join_strings none~join->proc~join_strings proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~snakecase~~CalledByGraph proc~snakecase string%snakecase program~volatile_doctest~98 volatile_doctest program~volatile_doctest~98->proc~snakecase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function snakecase ( self , sep ) !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< test_passed(1) = astring%snakecase()//''=='the_quick_brown_fox_jumps_over_the_lazy_dog.' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif endfunction snakecase","tags":"","loc":"proc/snakecase.html"},{"title":"startcase – StringiFor","text":"private elemental function startcase(self, sep) Return a string with all words capitalized, e.g. title case. @note Note\n      Multiple subsequent separators are collapsed to one occurence. type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % startcase () // '' == 'The Quick Brown Fox Jumps Over The Lazy Dog.' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Calls proc~~startcase~~CallsGraph proc~startcase string%startcase none~join string%join proc~startcase->none~join proc~capitalize string%capitalize proc~startcase->proc~capitalize proc~split string%split proc~startcase->proc~split proc~join_characters string%join_characters none~join->proc~join_characters proc~join_strings string%join_strings none~join->proc~join_strings proc~lower string%lower proc~capitalize->proc~lower proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~startcase~~CalledByGraph proc~startcase string%startcase program~volatile_doctest~2 volatile_doctest program~volatile_doctest~2->proc~startcase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function startcase ( self , sep ) !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< test_passed(1) = astring%startcase()//''=='The Quick Brown Fox Jumps Over The Lazy Dog.' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif endfunction startcase","tags":"","loc":"proc/startcase.html"},{"title":"strip – StringiFor","text":"private elemental function strip(self, remove_nulls) Return a copy of the string with the leading and trailing characters removed. @note Note\n      Multiple subsequent separators are collapsed to one occurence. type ( string ) :: astring logical :: test_passed ( 1 ) astring = '  Hello World!   ' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. Called by proc~~strip~~CalledByGraph proc~strip string%strip proc~decode string%decode proc~decode->proc~strip program~volatile_doctest~108 volatile_doctest program~volatile_doctest~108->proc~strip program~volatile_doctest~32 volatile_doctest program~volatile_doctest~32->proc~decode Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strip ( self , remove_nulls ) !< Return a copy of the string with the leading and trailing characters removed. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = '  Hello World!   ' !< test_passed(1) = astring%strip()//''=='Hello World!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: remove_nulls !< Remove null characters at the end. type ( string ) :: strip !< The stripped string. integer :: c !< Counter. if ( allocated ( self % raw )) then strip = self % adjustl () strip = strip % trim () if ( present ( remove_nulls )) then if ( remove_nulls ) then c = index ( self % raw , char ( 0 )) if ( c > 0 ) strip % raw = strip % raw ( 1 : c - 1 ) endif endif endif endfunction strip","tags":"","loc":"proc/strip.html"},{"title":"swapcase – StringiFor","text":"private elemental function swapcase(self) Return a copy of the string with uppercase characters converted to lowercase and vice versa. type ( string ) :: astring logical :: test_passed ( 1 ) astring = '  Hello World!   ' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Called by proc~~swapcase~~CalledByGraph proc~swapcase string%swapcase program~volatile_doctest~29 volatile_doctest program~volatile_doctest~29->proc~swapcase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function swapcase ( self ) !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = '  Hello World!   ' !< test_passed(1) = astring%swapcase()//''=='  hELLO wORLD!   ' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif endfunction swapcase","tags":"","loc":"proc/swapcase.html"},{"title":"tempname – StringiFor","text":"private  function tempname(self, is_file, prefix, path) Return a safe temporary name suitable for temporary file or directories. type ( string ) :: astring character ( len = :), allocatable :: tmpname logical :: test_passed ( 5 ) tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 1 )) test_passed ( 1 ) = . not . test_passed ( 1 ) tmpname = astring % tempname ( is_file = . false .) inquire ( file = tmpname , exist = test_passed ( 2 )) test_passed ( 2 ) = . not . test_passed ( 2 ) tmpname = astring % tempname ( path = './' ) inquire ( file = tmpname , exist = test_passed ( 3 )) test_passed ( 3 ) = . not . test_passed ( 3 ) astring = 'me-' tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 4 )) test_passed ( 4 ) = . not . test_passed ( 4 ) tmpname = astring % tempname ( prefix = 'you-' ) inquire ( file = tmpname , exist = test_passed ( 5 )) test_passed ( 5 ) = . not . test_passed ( 5 ) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: is_file True if tempname should be used for file (the default). character(len=*), intent(in), optional :: prefix Name prefix, otherwise self is used (if allocated). character(len=*), intent(in), optional :: path Path where file/directory should be used, default ./ . Return Value character(len=:), allocatable Safe (unique) temporary name. Called by proc~~tempname~~CalledByGraph proc~tempname string%tempname proc~glob_string string%glob_string proc~glob_string->proc~tempname program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->proc~tempname interface~glob glob program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->proc~tempname none~glob string%glob program~volatile_doctest~103->none~glob program~volatile_doctest~19 volatile_doctest program~volatile_doctest~19->proc~tempname program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->proc~tempname program~volatile_doctest~82->none~glob interface~glob->proc~glob_string proc~glob_character string%glob_character interface~glob->proc~glob_character none~glob->proc~glob_string none~glob->proc~glob_character proc~glob_character->none~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function tempname ( self , is_file , prefix , path ) !< Return a safe temporary name suitable for temporary file or directories. !< !<```fortran !< type(string) :: astring !< character(len=:), allocatable :: tmpname !< logical                       :: test_passed(5) !< tmpname = astring%tempname() !< inquire(file=tmpname, exist=test_passed(1)) !< test_passed(1) = .not.test_passed(1) !< tmpname = astring%tempname(is_file=.false.) !< inquire(file=tmpname, exist=test_passed(2)) !< test_passed(2) = .not.test_passed(2) !< tmpname = astring%tempname(path='./') !< inquire(file=tmpname, exist=test_passed(3)) !< test_passed(3) = .not.test_passed(3) !< astring = 'me-' !< tmpname = astring%tempname() !< inquire(file=tmpname, exist=test_passed(4)) !< test_passed(4) = .not.test_passed(4) !< tmpname = astring%tempname(prefix='you-') !< inquire(file=tmpname, exist=test_passed(5)) !< test_passed(5) = .not.test_passed(5) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: is_file !< True if tempname should be used for file (the default). character ( * ), intent ( in ), optional :: prefix !< Name prefix, otherwise self is used (if allocated). character ( * ), intent ( in ), optional :: path !< Path where file/directory should be used, default `./`. character ( len = :), allocatable :: tempname !< Safe (unique) temporary name. logical :: is_file_ !< True if tempname should be used for file (the default). character ( len = :), allocatable :: prefix_ !< Name prefix, otherwise self is used (if allocated). character ( len = :), allocatable :: path_ !< Path where file/directory should be used, default `./`. logical , save :: is_initialized = . false . !< Status of random seed initialization. real ( R4P ) :: random_real !< Random number (real). integer ( I4P ) :: random_integer !< Random number (integer). logical :: is_hold !< Flag to check if a safe tempname has been found. is_file_ = . true . ; if ( present ( is_file )) is_file_ = is_file path_ = '' ; if ( present ( path )) path_ = path prefix_ = '' if ( present ( prefix )) then prefix_ = prefix elseif ( allocated ( self % raw )) then prefix_ = self % raw endif if (. not . is_initialized ) then call random_seed is_initialized = . true . endif tempname = repeat ( ' ' , len ( path_ ) + len ( prefix_ ) + 10 ) ! [path_] + [prefix_] + 6 random chars + [.tmp] do call random_number ( random_real ) random_integer = transfer ( random_real , random_integer ) random_integer = iand ( random_integer , 16777215_I4P ) if ( is_file_ ) then write ( tempname , '(A,Z6.6,A)' ) path_ // prefix_ , random_integer , '.tmp' else write ( tempname , '(A,Z6.6)' ) path_ // prefix_ , random_integer tempname = trim ( tempname ) endif inquire ( file = tempname , exist = is_hold ) if (. not . is_hold ) exit enddo endfunction tempname","tags":"","loc":"proc/tempname.html"},{"title":"to_integer_I1P – StringiFor","text":"private elemental function to_integer_I1P(self, kind) result(to_number) Cast string to integer (I1P). use penf type ( string ) :: astring integer ( I1P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I1P ) test_passed ( 1 ) = integer_ == 127_I1P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Calls proc~~to_integer_i1p~~CallsGraph proc~to_integer_i1p string%to_integer_I1P proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~to_integer_i1p~~CalledByGraph proc~to_integer_i1p string%to_integer_I1P none~to_number string%to_number none~to_number->proc~to_integer_i1p program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->none~to_number program~volatile_doctest~101 volatile_doctest program~volatile_doctest~101->none~to_number program~volatile_doctest~25 volatile_doctest program~volatile_doctest~25->none~to_number program~volatile_doctest~30 volatile_doctest program~volatile_doctest~30->none~to_number program~volatile_doctest~34 volatile_doctest program~volatile_doctest~34->none~to_number program~volatile_doctest~35 volatile_doctest program~volatile_doctest~35->none~to_number program~volatile_doctest~49 volatile_doctest program~volatile_doctest~49->none~to_number program~volatile_doctest~51 volatile_doctest program~volatile_doctest~51->none~to_number program~volatile_doctest~52 volatile_doctest program~volatile_doctest~52->none~to_number program~volatile_doctest~64 volatile_doctest program~volatile_doctest~64->none~to_number program~volatile_doctest~71 volatile_doctest program~volatile_doctest~71->none~to_number program~volatile_doctest~74 volatile_doctest program~volatile_doctest~74->none~to_number program~volatile_doctest~76 volatile_doctest program~volatile_doctest~76->none~to_number program~volatile_doctest~79 volatile_doctest program~volatile_doctest~79->none~to_number program~volatile_doctest~83 volatile_doctest program~volatile_doctest~83->none~to_number Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function to_integer_I1P ( self , kind ) result ( to_number ) !< Cast string to integer (I1P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I1P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I1P) !< test_passed(1) = integer_==127_I1P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I1P","tags":"","loc":"proc/to_integer_i1p.html"},{"title":"to_integer_I2P – StringiFor","text":"private elemental function to_integer_I2P(self, kind) result(to_number) Cast string to integer (I2P). use penf type ( string ) :: astring integer ( I2P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I2P ) test_passed ( 1 ) = integer_ == 127_I2P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Calls proc~~to_integer_i2p~~CallsGraph proc~to_integer_i2p string%to_integer_I2P proc~is_integer string%is_integer proc~to_integer_i2p->proc~is_integer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~to_integer_i2p~~CalledByGraph proc~to_integer_i2p string%to_integer_I2P none~to_number string%to_number none~to_number->proc~to_integer_i2p program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->none~to_number program~volatile_doctest~101 volatile_doctest program~volatile_doctest~101->none~to_number program~volatile_doctest~25 volatile_doctest program~volatile_doctest~25->none~to_number program~volatile_doctest~30 volatile_doctest program~volatile_doctest~30->none~to_number program~volatile_doctest~34 volatile_doctest program~volatile_doctest~34->none~to_number program~volatile_doctest~35 volatile_doctest program~volatile_doctest~35->none~to_number program~volatile_doctest~49 volatile_doctest program~volatile_doctest~49->none~to_number program~volatile_doctest~51 volatile_doctest program~volatile_doctest~51->none~to_number program~volatile_doctest~52 volatile_doctest program~volatile_doctest~52->none~to_number program~volatile_doctest~64 volatile_doctest program~volatile_doctest~64->none~to_number program~volatile_doctest~71 volatile_doctest program~volatile_doctest~71->none~to_number program~volatile_doctest~74 volatile_doctest program~volatile_doctest~74->none~to_number program~volatile_doctest~76 volatile_doctest program~volatile_doctest~76->none~to_number program~volatile_doctest~79 volatile_doctest program~volatile_doctest~79->none~to_number program~volatile_doctest~83 volatile_doctest program~volatile_doctest~83->none~to_number Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function to_integer_I2P ( self , kind ) result ( to_number ) !< Cast string to integer (I2P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I2P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I2P) !< test_passed(1) = integer_==127_I2P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I2P","tags":"","loc":"proc/to_integer_i2p.html"},{"title":"to_integer_I4P – StringiFor","text":"private elemental function to_integer_I4P(self, kind) result(to_number) Cast string to integer (I4P). use penf type ( string ) :: astring integer ( I4P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I4P ) test_passed ( 1 ) = integer_ == 127_I4P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Calls proc~~to_integer_i4p~~CallsGraph proc~to_integer_i4p string%to_integer_I4P proc~is_integer string%is_integer proc~to_integer_i4p->proc~is_integer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~to_integer_i4p~~CalledByGraph proc~to_integer_i4p string%to_integer_I4P none~to_number string%to_number none~to_number->proc~to_integer_i4p program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->none~to_number program~volatile_doctest~101 volatile_doctest program~volatile_doctest~101->none~to_number program~volatile_doctest~25 volatile_doctest program~volatile_doctest~25->none~to_number program~volatile_doctest~30 volatile_doctest program~volatile_doctest~30->none~to_number program~volatile_doctest~34 volatile_doctest program~volatile_doctest~34->none~to_number program~volatile_doctest~35 volatile_doctest program~volatile_doctest~35->none~to_number program~volatile_doctest~49 volatile_doctest program~volatile_doctest~49->none~to_number program~volatile_doctest~51 volatile_doctest program~volatile_doctest~51->none~to_number program~volatile_doctest~52 volatile_doctest program~volatile_doctest~52->none~to_number program~volatile_doctest~64 volatile_doctest program~volatile_doctest~64->none~to_number program~volatile_doctest~71 volatile_doctest program~volatile_doctest~71->none~to_number program~volatile_doctest~74 volatile_doctest program~volatile_doctest~74->none~to_number program~volatile_doctest~76 volatile_doctest program~volatile_doctest~76->none~to_number program~volatile_doctest~79 volatile_doctest program~volatile_doctest~79->none~to_number program~volatile_doctest~83 volatile_doctest program~volatile_doctest~83->none~to_number Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function to_integer_I4P ( self , kind ) result ( to_number ) !< Cast string to integer (I4P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I4P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I4P) !< test_passed(1) = integer_==127_I4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I4P","tags":"","loc":"proc/to_integer_i4p.html"},{"title":"to_integer_I8P – StringiFor","text":"private elemental function to_integer_I8P(self, kind) result(to_number) Cast string to integer (I8P). use penf type ( string ) :: astring integer ( I8P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I8P ) test_passed ( 1 ) = integer_ == 127_I8P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Calls proc~~to_integer_i8p~~CallsGraph proc~to_integer_i8p string%to_integer_I8P proc~is_integer string%is_integer proc~to_integer_i8p->proc~is_integer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~to_integer_i8p~~CalledByGraph proc~to_integer_i8p string%to_integer_I8P none~to_number string%to_number none~to_number->proc~to_integer_i8p program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->none~to_number program~volatile_doctest~101 volatile_doctest program~volatile_doctest~101->none~to_number program~volatile_doctest~25 volatile_doctest program~volatile_doctest~25->none~to_number program~volatile_doctest~30 volatile_doctest program~volatile_doctest~30->none~to_number program~volatile_doctest~34 volatile_doctest program~volatile_doctest~34->none~to_number program~volatile_doctest~35 volatile_doctest program~volatile_doctest~35->none~to_number program~volatile_doctest~49 volatile_doctest program~volatile_doctest~49->none~to_number program~volatile_doctest~51 volatile_doctest program~volatile_doctest~51->none~to_number program~volatile_doctest~52 volatile_doctest program~volatile_doctest~52->none~to_number program~volatile_doctest~64 volatile_doctest program~volatile_doctest~64->none~to_number program~volatile_doctest~71 volatile_doctest program~volatile_doctest~71->none~to_number program~volatile_doctest~74 volatile_doctest program~volatile_doctest~74->none~to_number program~volatile_doctest~76 volatile_doctest program~volatile_doctest~76->none~to_number program~volatile_doctest~79 volatile_doctest program~volatile_doctest~79->none~to_number program~volatile_doctest~83 volatile_doctest program~volatile_doctest~83->none~to_number Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function to_integer_I8P ( self , kind ) result ( to_number ) !< Cast string to integer (I8P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I8P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I8P) !< test_passed(1) = integer_==127_I8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I8P","tags":"","loc":"proc/to_integer_i8p.html"},{"title":"to_real_R4P – StringiFor","text":"private elemental function to_real_R4P(self, kind) result(to_number) Cast string to real (R4P). use penf type ( string ) :: astring real ( R4P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R4P ) test_passed ( 1 ) = real_ == 3.4e9_R4P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Calls proc~~to_real_r4p~~CallsGraph proc~to_real_r4p string%to_real_R4P proc~is_real string%is_real proc~to_real_r4p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~to_real_r4p~~CalledByGraph proc~to_real_r4p string%to_real_R4P none~to_number string%to_number none~to_number->proc~to_real_r4p program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->none~to_number program~volatile_doctest~101 volatile_doctest program~volatile_doctest~101->none~to_number program~volatile_doctest~25 volatile_doctest program~volatile_doctest~25->none~to_number program~volatile_doctest~30 volatile_doctest program~volatile_doctest~30->none~to_number program~volatile_doctest~34 volatile_doctest program~volatile_doctest~34->none~to_number program~volatile_doctest~35 volatile_doctest program~volatile_doctest~35->none~to_number program~volatile_doctest~49 volatile_doctest program~volatile_doctest~49->none~to_number program~volatile_doctest~51 volatile_doctest program~volatile_doctest~51->none~to_number program~volatile_doctest~52 volatile_doctest program~volatile_doctest~52->none~to_number program~volatile_doctest~64 volatile_doctest program~volatile_doctest~64->none~to_number program~volatile_doctest~71 volatile_doctest program~volatile_doctest~71->none~to_number program~volatile_doctest~74 volatile_doctest program~volatile_doctest~74->none~to_number program~volatile_doctest~76 volatile_doctest program~volatile_doctest~76->none~to_number program~volatile_doctest~79 volatile_doctest program~volatile_doctest~79->none~to_number program~volatile_doctest~83 volatile_doctest program~volatile_doctest~83->none~to_number Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function to_real_R4P ( self , kind ) result ( to_number ) !< Cast string to real (R4P). !< !<```fortran !< use penf !< type(string) :: astring !< real(R4P)    :: real_ !< logical      :: test_passed(1) !< astring = '3.4e9' !< real_ = astring%to_number(kind=1._R4P) !< test_passed(1) = real_==3.4e9_R4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R4P","tags":"","loc":"proc/to_real_r4p.html"},{"title":"to_real_R8P – StringiFor","text":"private elemental function to_real_R8P(self, kind) result(to_number) Cast string to real (R8P). use penf type ( string ) :: astring real ( R8P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R8P ) test_passed ( 1 ) = real_ == 3.4e9_R8P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Calls proc~~to_real_r8p~~CallsGraph proc~to_real_r8p string%to_real_R8P proc~is_real string%is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~to_real_r8p~~CalledByGraph proc~to_real_r8p string%to_real_R8P none~to_number string%to_number none~to_number->proc~to_real_r8p program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->none~to_number program~volatile_doctest~101 volatile_doctest program~volatile_doctest~101->none~to_number program~volatile_doctest~25 volatile_doctest program~volatile_doctest~25->none~to_number program~volatile_doctest~30 volatile_doctest program~volatile_doctest~30->none~to_number program~volatile_doctest~34 volatile_doctest program~volatile_doctest~34->none~to_number program~volatile_doctest~35 volatile_doctest program~volatile_doctest~35->none~to_number program~volatile_doctest~49 volatile_doctest program~volatile_doctest~49->none~to_number program~volatile_doctest~51 volatile_doctest program~volatile_doctest~51->none~to_number program~volatile_doctest~52 volatile_doctest program~volatile_doctest~52->none~to_number program~volatile_doctest~64 volatile_doctest program~volatile_doctest~64->none~to_number program~volatile_doctest~71 volatile_doctest program~volatile_doctest~71->none~to_number program~volatile_doctest~74 volatile_doctest program~volatile_doctest~74->none~to_number program~volatile_doctest~76 volatile_doctest program~volatile_doctest~76->none~to_number program~volatile_doctest~79 volatile_doctest program~volatile_doctest~79->none~to_number program~volatile_doctest~83 volatile_doctest program~volatile_doctest~83->none~to_number Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function to_real_R8P ( self , kind ) result ( to_number ) !< Cast string to real (R8P). !< !<```fortran !< use penf !< type(string) :: astring !< real(R8P)    :: real_ !< logical      :: test_passed(1) !< astring = '3.4e9' !< real_ = astring%to_number(kind=1._R8P) !< test_passed(1) = real_==3.4e9_R8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R8P","tags":"","loc":"proc/to_real_r8p.html"},{"title":"to_real_R16P – StringiFor","text":"private elemental function to_real_R16P(self, kind) result(to_number) Cast string to real (R16P). use penf type ( string ) :: astring real ( R16P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R16P ) test_passed ( 1 ) = real_ == 3.4e9_R16P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Calls proc~~to_real_r16p~~CallsGraph proc~to_real_r16p string%to_real_R16P proc~is_real string%is_real proc~to_real_r16p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function to_real_R16P ( self , kind ) result ( to_number ) !< Cast string to real (R16P). !< !<```fortran !< use penf !< type(string) :: astring !< real(R16P)   :: real_ !< logical      :: test_passed(1) !< astring = '3.4e9' !< real_ = astring%to_number(kind=1._R16P) !< test_passed(1) = real_==3.4e9_R16P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R16P","tags":"","loc":"proc/to_real_r16p.html"},{"title":"unescape – StringiFor","text":"private elemental function unescape(self, to_unescape, unesc) result(unescaped) Unescape double backslashes (or custom escaped character). type ( string ) :: astring logical :: test_passed ( 2 ) astring = '&#94;\\\\s \\\\d+\\\\s*' test_passed ( 1 ) = ( astring % unescape ( to_unescape = '\\')//''==' &#94;\\ s \\ d + \\ s * ') test_passed(2) = (astring%unescape(to_unescape=' s ')//''==' &#94;\\ s \\\\ d + \\ s * ') print ' ( L1 ) ' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK, len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. Called by proc~~unescape~~CalledByGraph proc~unescape string%unescape program~volatile_doctest~66 volatile_doctest program~volatile_doctest~66->proc~unescape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function unescape ( self , to_unescape , unesc ) result ( unescaped ) !< Unescape double backslashes (or custom escaped character). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '&#94;\\\\s \\\\d+\\\\s*' !< test_passed(1) = (astring%unescape(to_unescape='\\')//''=='&#94;\\s \\d+\\s*') !< test_passed(2) = (astring%unescape(to_unescape='s')//''=='&#94;\\s \\\\d+\\s*') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_unescape !< Character to be unescaped. character ( kind = CK , len =* ), intent ( in ), optional :: unesc !< Character used to unescape. type ( string ) :: unescaped !< Escaped string. character ( kind = CK , len = :), allocatable :: unesc_ !< Character to unescape, local variable. integer :: c !< Character counter. if ( allocated ( self % raw )) then unesc_ = '' ; if ( present ( unesc )) unesc_ = unesc unescaped % raw = '' c = 1 do if ( c > len ( self % raw )) exit if ( c == len ( self % raw )) then unescaped % raw = unescaped % raw // self % raw ( c : c ) exit else if ( self % raw ( c : c + 1 ) == BACKSLASH // to_unescape ) then unescaped % raw = unescaped % raw // to_unescape c = c + 2 else unescaped % raw = unescaped % raw // self % raw ( c : c ) c = c + 1 endif endif enddo endif endfunction unescape","tags":"","loc":"proc/unescape.html"},{"title":"unique – StringiFor","text":"private elemental function unique(self, substring) result(uniq) Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. For example the string ’ ab-cre-cre-ab’ is reduce to ‘ab-cre-ab’ if the substring is ‘-cre’.\n @note Note\n      Eventual multiple trailing white space are not reduced to one occurrence. type ( string ) :: astring logical :: test_passed ( 1 ) astring = '+++ab-++cre-++cre-ab+++++' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Calls proc~~unique~~CallsGraph proc~unique string%unique proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique~~CalledByGraph proc~unique string%unique proc~split string%split proc~split->proc~unique program~volatile_doctest~41 volatile_doctest program~volatile_doctest~41->proc~unique proc~camelcase string%camelcase proc~camelcase->proc~split proc~glob_string string%glob_string proc~glob_string->proc~split proc~snakecase string%snakecase proc~snakecase->proc~split proc~split_chunked string%split_chunked proc~split_chunked->proc~split proc~startcase string%startcase proc~startcase->proc~split proc~write_lines~2 string%write_lines proc~write_lines~2->proc~split program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~split program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~split program~stringifor_test_parse_large_csv->proc~split_chunked program~volatile_doctest~107 volatile_doctest program~volatile_doctest~107->proc~split program~volatile_doctest~15 volatile_doctest program~volatile_doctest~15->proc~split program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~split program~volatile_doctest~23 volatile_doctest program~volatile_doctest~23->proc~split program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~split proc~write_file~2 string%write_file program~volatile_doctest~44->proc~write_file~2 interface~glob glob interface~glob->proc~glob_string proc~glob_character string%glob_character interface~glob->proc~glob_character none~glob string%glob none~glob->proc~glob_string none~glob->proc~glob_character proc~write_file~2->proc~write_lines~2 program~volatile_doctest~18 volatile_doctest program~volatile_doctest~18->proc~camelcase program~volatile_doctest~2 volatile_doctest program~volatile_doctest~2->proc~startcase program~volatile_doctest~75 volatile_doctest program~volatile_doctest~75->proc~split_chunked program~volatile_doctest~98 volatile_doctest program~volatile_doctest~98->proc~snakecase proc~glob_character->none~glob program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->none~glob program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->none~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function unique ( self , substring ) result ( uniq ) !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = '+++ab-++cre-++cre-ab+++++' !< test_passed(1) = astring%unique(substring='+')//''=='+ab-+cre-+cre-ab+' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. #ifdef _NVF character ( 9999 ) :: nvf_bug !< Work around for NVFortran bug. #endif if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do #ifdef _NVF nvf_bug = substring_ if (. not . uniq % index ( repeat ( trim ( nvf_bug ), 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( trim ( nvf_bug ), 2 ), new = substring_ ) #else if (. not . uniq % index ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) #endif enddo endif endfunction unique","tags":"","loc":"proc/unique.html"},{"title":"upper – StringiFor","text":"private elemental function upper(self) Return a string with all uppercase characters. type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Called by proc~~upper~~CalledByGraph proc~upper string%upper proc~decode string%decode proc~decode->proc~upper proc~encode string%encode proc~encode->proc~upper proc~read_file read_file proc~read_file->proc~upper proc~read_lines read_lines proc~read_file->proc~read_lines proc~read_file~2 string%read_file proc~read_file~2->proc~upper proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~read_line string%read_line proc~read_line->proc~upper proc~read_lines->proc~upper proc~read_lines->proc~read_line proc~write_file write_file proc~write_file->proc~upper proc~write_lines write_lines proc~write_file->proc~write_lines proc~write_file~2 string%write_file proc~write_file~2->proc~upper proc~write_lines~2 string%write_lines proc~write_file~2->proc~write_lines~2 proc~write_line string%write_line proc~write_line->proc~upper program~volatile_doctest~6 volatile_doctest program~volatile_doctest~6->proc~upper proc~glob_string string%glob_string proc~glob_string->proc~read_file~2 proc~read_lines~2->proc~read_line proc~write_lines->proc~write_line proc~write_lines~2->proc~write_line program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~read_file~2 program~stringifor_test_csv_naive_parser->proc~write_file program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~read_file~2 program~volatile_doctest~107 volatile_doctest program~volatile_doctest~107->proc~read_file~2 program~volatile_doctest~16 volatile_doctest program~volatile_doctest~16->proc~encode program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~read_file~2 program~volatile_doctest~17->proc~write_file program~volatile_doctest~32 volatile_doctest program~volatile_doctest~32->proc~decode program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~read_file~2 program~volatile_doctest~44->proc~write_file~2 program~volatile_doctest~54 volatile_doctest program~volatile_doctest~54->proc~read_file program~volatile_doctest~87 volatile_doctest program~volatile_doctest~87->proc~read_line interface~glob glob interface~glob->proc~glob_string proc~glob_character string%glob_character interface~glob->proc~glob_character none~glob string%glob none~glob->proc~glob_string none~glob->proc~glob_character program~volatile_doctest~15 volatile_doctest program~volatile_doctest~15->proc~read_lines~2 proc~glob_character->none~glob program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->none~glob program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->none~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function upper ( self ) !< Return a string with all uppercase characters. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%upper()//''=='HELLO WORLD!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif endfunction upper","tags":"","loc":"proc/upper.html"},{"title":"end_with – StringiFor","text":"private elemental function end_with(self, suffix, start, end, ignore_null_eof) Return true if a string ends with a specified suffix. type ( string ) :: astring logical :: test_passed ( 5 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . test_passed ( 2 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . test_passed ( 3 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . test_passed ( 4 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . test_passed ( 5 ) = astring % end_with ( suffix = '!' ). eqv .. true . print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. logical, intent(in), optional :: ignore_null_eof Ignore null character at the end of file. Return Value logical Result of the test. Called by proc~~end_with~~CalledByGraph proc~end_with string%end_with proc~split_chunked string%split_chunked proc~split_chunked->proc~end_with proc~write_line string%write_line proc~write_line->proc~end_with program~volatile_doctest~105 volatile_doctest program~volatile_doctest~105->proc~end_with proc~write_lines write_lines proc~write_lines->proc~write_line proc~write_lines~2 string%write_lines proc~write_lines~2->proc~write_line program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~split_chunked program~volatile_doctest~75 volatile_doctest program~volatile_doctest~75->proc~split_chunked proc~write_file write_file proc~write_file->proc~write_lines proc~write_file~2 string%write_file proc~write_file~2->proc~write_lines~2 program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~write_file program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~write_file program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~write_file~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function end_with ( self , suffix , start , end , ignore_null_eof ) !< Return true if a string ends with a specified suffix. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(5) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%end_with(suffix='LD!').eqv..true. !< test_passed(2) = astring%end_with(suffix='lD!').eqv..false. !< test_passed(3) = astring%end_with(suffix='orLD!', start=5).eqv..true. !< test_passed(4) = astring%end_with(suffix='orLD!', start=8, end=12).eqv..true. !< test_passed(5) = astring%end_with(suffix='!').eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical , intent ( in ), optional :: ignore_null_eof !< Ignore null character at the end of file. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. logical :: ignore_null_eof_ !< Ignore null character at the end of file, local variable. end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end ignore_null_eof_ = . false . ; if ( present ( ignore_null_eof )) ignore_null_eof_ = ignore_null_eof if ( ignore_null_eof_ . and .( self % raw ( end_ : end_ ) == char ( 0 ))) end_ = end_ - 1 if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = self % raw ( end_ - len ( suffix ) + 1 : end_ ) == suffix endif endif endfunction end_with","tags":"","loc":"proc/end_with.html"},{"title":"is_allocated – StringiFor","text":"private elemental function is_allocated(self) Return true if the string is allocated. type ( string ) :: astring logical :: test_passed ( 2 ) test_passed ( 1 ) = astring % is_allocated (). eqv .. false . astring = 'hello' test_passed ( 2 ) = astring % is_allocated (). eqv .. true . print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Called by proc~~is_allocated~~CalledByGraph proc~is_allocated string%is_allocated program~volatile_doctest~80 volatile_doctest program~volatile_doctest~80->proc~is_allocated program~volatile_doctest~93 volatile_doctest program~volatile_doctest~93->proc~is_allocated Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_allocated ( self ) !< Return true if the string is allocated. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< test_passed(1) = astring%is_allocated().eqv..false. !< astring = 'hello' !< test_passed(2) = astring%is_allocated().eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. is_allocated = allocated ( self % raw ) endfunction is_allocated","tags":"","loc":"proc/is_allocated.html"},{"title":"is_digit – StringiFor","text":"private elemental function is_digit(self) Return true if all characters in the string are digits. type ( string ) :: astring logical :: test_passed ( 2 ) astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Called by proc~~is_digit~~CalledByGraph proc~is_digit string%is_digit program~volatile_doctest volatile_doctest program~volatile_doctest->proc~is_digit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_digit ( self ) !< Return true if all characters in the string are digits. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '   -1212112.3 ' !< test_passed(1) = astring%is_digit().eqv..false. !< astring = '12121123' !< test_passed(2) = astring%is_digit().eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif endfunction is_digit","tags":"","loc":"proc/is_digit.html"},{"title":"is_integer – StringiFor","text":"private elemental function is_integer(self, allow_spaces) Return true if the string contains an integer. The regular expression is \\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s* . The parse algorithm is done in stages: S0 S1 S2 S3 S4 S5 S6 \\s* [\\+\\-]? \\d+ [eE] \\+? \\d+ \\s* Exit on stages-parsing results in: S0 S1 S2 S3 S4 S5 S6 F F T F F T T @note Note\n      This implementation is courtesy of tomedunn type ( string ) :: astring logical :: test_passed ( 6 ) astring = '   -1212112 ' test_passed ( 1 ) = astring % is_integer (). eqv .. true . astring = '   -1212112' test_passed ( 2 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . astring = '-1212112   ' test_passed ( 3 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . astring = '+2e20' test_passed ( 4 ) = astring % is_integer (). eqv .. true . astring = ' -2E13 ' test_passed ( 5 ) = astring % is_integer (). eqv .. true . astring = ' -2 E13 ' test_passed ( 6 ) = astring % is_integer (). eqv .. false . print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Called by proc~~is_integer~~CalledByGraph proc~is_integer string%is_integer proc~is_number string%is_number proc~is_number->proc~is_integer proc~to_integer_i1p string%to_integer_I1P proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p string%to_integer_I2P proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p string%to_integer_I4P proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p string%to_integer_I8P proc~to_integer_i8p->proc~is_integer program~volatile_doctest~60 volatile_doctest program~volatile_doctest~60->proc~is_integer none~to_number string%to_number none~to_number->proc~to_integer_i1p none~to_number->proc~to_integer_i2p none~to_number->proc~to_integer_i4p none~to_number->proc~to_integer_i8p program~volatile_doctest~31 volatile_doctest program~volatile_doctest~31->proc~is_number program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->none~to_number program~volatile_doctest~101 volatile_doctest program~volatile_doctest~101->none~to_number program~volatile_doctest~25 volatile_doctest program~volatile_doctest~25->none~to_number program~volatile_doctest~30 volatile_doctest program~volatile_doctest~30->none~to_number program~volatile_doctest~34 volatile_doctest program~volatile_doctest~34->none~to_number program~volatile_doctest~35 volatile_doctest program~volatile_doctest~35->none~to_number program~volatile_doctest~49 volatile_doctest program~volatile_doctest~49->none~to_number program~volatile_doctest~51 volatile_doctest program~volatile_doctest~51->none~to_number program~volatile_doctest~52 volatile_doctest program~volatile_doctest~52->none~to_number program~volatile_doctest~64 volatile_doctest program~volatile_doctest~64->none~to_number program~volatile_doctest~71 volatile_doctest program~volatile_doctest~71->none~to_number program~volatile_doctest~74 volatile_doctest program~volatile_doctest~74->none~to_number program~volatile_doctest~76 volatile_doctest program~volatile_doctest~76->none~to_number program~volatile_doctest~79 volatile_doctest program~volatile_doctest~79->none~to_number program~volatile_doctest~83 volatile_doctest program~volatile_doctest~83->none~to_number Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_integer ( self , allow_spaces ) !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(6) !< astring = '   -1212112 ' !< test_passed(1) = astring%is_integer().eqv..true. !< astring = '   -1212112' !< test_passed(2) = astring%is_integer(allow_spaces=.false.).eqv..false. !< astring = '-1212112   ' !< test_passed(3) = astring%is_integer(allow_spaces=.false.).eqv..false. !< astring = '+2e20' !< test_passed(4) = astring%is_integer().eqv..true. !< astring = ' -2E13 ' !< test_passed(5) = astring%is_integer().eqv..true. !< astring = ' -2 E13 ' !< test_passed(6) = astring%is_integer().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif endfunction is_integer","tags":"","loc":"proc/is_integer.html"},{"title":"is_lower – StringiFor","text":"private elemental function is_lower(self) Return true if all characters in the string are lowercase. type ( string ) :: astring logical :: test_passed ( 3 ) astring = ' Hello World' test_passed ( 1 ) = astring % is_lower (). eqv .. false . astring = ' HELLO WORLD' test_passed ( 2 ) = astring % is_lower (). eqv .. false . astring = ' hello world' test_passed ( 3 ) = astring % is_lower (). eqv .. true . print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Called by proc~~is_lower~~CalledByGraph proc~is_lower string%is_lower program~volatile_doctest~84 volatile_doctest program~volatile_doctest~84->proc~is_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_lower ( self ) !< Return true if all characters in the string are lowercase. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(3) !< astring = ' Hello World' !< test_passed(1) = astring%is_lower().eqv..false. !< astring = ' HELLO WORLD' !< test_passed(2) = astring%is_lower().eqv..false. !< astring = ' hello world' !< test_passed(3) = astring%is_lower().eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif endfunction is_lower","tags":"","loc":"proc/is_lower.html"},{"title":"is_number – StringiFor","text":"private elemental function is_number(self, allow_spaces) Return true if the string contains a number (real or integer). type ( string ) :: astring logical :: test_passed ( 7 ) astring = '   -1212112 ' test_passed ( 1 ) = astring % is_number (). eqv .. true . astring = '   -121.2112 ' test_passed ( 2 ) = astring % is_number (). eqv .. true . astring = '   -1212112' test_passed ( 3 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . astring = '-12121.12   ' test_passed ( 4 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . astring = '+2e20' test_passed ( 5 ) = astring % is_number (). eqv .. true . astring = ' -2.4E13 ' test_passed ( 6 ) = astring % is_number (). eqv .. true . astring = ' -2 E13 ' test_passed ( 7 ) = astring % is_number (). eqv .. false . print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Calls proc~~is_number~~CallsGraph proc~is_number string%is_number proc~is_integer string%is_integer proc~is_number->proc~is_integer proc~is_real string%is_real proc~is_number->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~is_number~~CalledByGraph proc~is_number string%is_number program~volatile_doctest~31 volatile_doctest program~volatile_doctest~31->proc~is_number Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_number ( self , allow_spaces ) !< Return true if the string contains a number (real or integer). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(7) !< astring = '   -1212112 ' !< test_passed(1) = astring%is_number().eqv..true. !< astring = '   -121.2112 ' !< test_passed(2) = astring%is_number().eqv..true. !< astring = '   -1212112' !< test_passed(3) = astring%is_number(allow_spaces=.false.).eqv..false. !< astring = '-12121.12   ' !< test_passed(4) = astring%is_number(allow_spaces=.false.).eqv..false. !< astring = '+2e20' !< test_passed(5) = astring%is_number().eqv..true. !< astring = ' -2.4E13 ' !< test_passed(6) = astring%is_number().eqv..true. !< astring = ' -2 E13 ' !< test_passed(7) = astring%is_number().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) endfunction is_number","tags":"","loc":"proc/is_number.html"},{"title":"is_real – StringiFor","text":"private elemental function is_real(self, allow_spaces) Return true if the string contains a real. The regular expression is \\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s* . The parse algorithm is done in stages: S0 S1 S2 S3 S4 S5 S6 S7 S8 \\s* [\\+\\-]? \\d* \\.? \\d* [deDE] [\\+\\-]? \\d* \\s* Exit on stages-parsing results in: S0 S1 S2 S3 S4 S5 S6 S7 S8 @note Note\n      This implementation is courtesy of tomedunn type ( string ) :: astring logical :: test_passed ( 6 ) astring = '   -1212112.d0 ' test_passed ( 1 ) = astring % is_real (). eqv .. true . astring = '   -1212112.d0' test_passed ( 2 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . astring = '-1212112.d0   ' test_passed ( 3 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . astring = '+2.e20' test_passed ( 4 ) = astring % is_real (). eqv .. true . astring = ' -2.01E13 ' test_passed ( 5 ) = astring % is_real (). eqv .. true . astring = ' -2.01 E13 ' test_passed ( 6 ) = astring % is_real (). eqv .. false . print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Called by proc~~is_real~~CalledByGraph proc~is_real string%is_real proc~is_number string%is_number proc~is_number->proc~is_real proc~to_real_r16p string%to_real_R16P proc~to_real_r16p->proc~is_real proc~to_real_r4p string%to_real_R4P proc~to_real_r4p->proc~is_real proc~to_real_r8p string%to_real_R8P proc~to_real_r8p->proc~is_real program~volatile_doctest~4 volatile_doctest program~volatile_doctest~4->proc~is_real none~to_number string%to_number none~to_number->proc~to_real_r4p none~to_number->proc~to_real_r8p program~volatile_doctest~31 volatile_doctest program~volatile_doctest~31->proc~is_number program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->none~to_number program~volatile_doctest~101 volatile_doctest program~volatile_doctest~101->none~to_number program~volatile_doctest~25 volatile_doctest program~volatile_doctest~25->none~to_number program~volatile_doctest~30 volatile_doctest program~volatile_doctest~30->none~to_number program~volatile_doctest~34 volatile_doctest program~volatile_doctest~34->none~to_number program~volatile_doctest~35 volatile_doctest program~volatile_doctest~35->none~to_number program~volatile_doctest~49 volatile_doctest program~volatile_doctest~49->none~to_number program~volatile_doctest~51 volatile_doctest program~volatile_doctest~51->none~to_number program~volatile_doctest~52 volatile_doctest program~volatile_doctest~52->none~to_number program~volatile_doctest~64 volatile_doctest program~volatile_doctest~64->none~to_number program~volatile_doctest~71 volatile_doctest program~volatile_doctest~71->none~to_number program~volatile_doctest~74 volatile_doctest program~volatile_doctest~74->none~to_number program~volatile_doctest~76 volatile_doctest program~volatile_doctest~76->none~to_number program~volatile_doctest~79 volatile_doctest program~volatile_doctest~79->none~to_number program~volatile_doctest~83 volatile_doctest program~volatile_doctest~83->none~to_number Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_real ( self , allow_spaces ) !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(6) !< astring = '   -1212112.d0 ' !< test_passed(1) = astring%is_real().eqv..true. !< astring = '   -1212112.d0' !< test_passed(2) = astring%is_real(allow_spaces=.false.).eqv..false. !< astring = '-1212112.d0   ' !< test_passed(3) = astring%is_real(allow_spaces=.false.).eqv..false. !< astring = '+2.e20' !< test_passed(4) = astring%is_real().eqv..true. !< astring = ' -2.01E13 ' !< test_passed(5) = astring%is_real().eqv..true. !< astring = ' -2.01 E13 ' !< test_passed(6) = astring%is_real().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif endfunction is_real","tags":"","loc":"proc/is_real.html"},{"title":"is_upper – StringiFor","text":"private elemental function is_upper(self) Return true if all characters in the string are uppercase. type ( string ) :: astring logical :: test_passed ( 3 ) astring = ' Hello World' test_passed ( 1 ) = astring % is_upper (). eqv .. false . astring = ' HELLO WORLD' test_passed ( 2 ) = astring % is_upper (). eqv .. true . astring = ' hello world' test_passed ( 3 ) = astring % is_upper (). eqv .. false . print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Called by proc~~is_upper~~CalledByGraph proc~is_upper string%is_upper program~volatile_doctest~40 volatile_doctest program~volatile_doctest~40->proc~is_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function is_upper ( self ) !< Return true if all characters in the string are uppercase. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(3) !< astring = ' Hello World' !< test_passed(1) = astring%is_upper().eqv..false. !< astring = ' HELLO WORLD' !< test_passed(2) = astring%is_upper().eqv..true. !< astring = ' hello world' !< test_passed(3) = astring%is_upper().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif endfunction is_upper","tags":"","loc":"proc/is_upper.html"},{"title":"start_with – StringiFor","text":"private elemental function start_with(self, prefix, start, end) Return true if a string starts with a specified prefix. type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Called by proc~~start_with~~CalledByGraph proc~start_with string%start_with proc~split_chunked string%split_chunked proc~split_chunked->proc~start_with program~volatile_doctest~102 volatile_doctest program~volatile_doctest~102->proc~start_with program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~split_chunked program~volatile_doctest~75 volatile_doctest program~volatile_doctest~75->proc~split_chunked Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function start_with ( self , prefix , start , end ) !< Return true if a string starts with a specified prefix. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%start_with(prefix='Hello').eqv..true. !< test_passed(2) = astring%start_with(prefix='hell').eqv..false. !< test_passed(3) = astring%start_with(prefix='llo Wor', start=3).eqv..true. !< test_passed(4) = astring%start_with(prefix='lo W', start=4, end=7).eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif endfunction start_with","tags":"","loc":"proc/start_with.html"},{"title":"string_concat_string – StringiFor","text":"private pure function string_concat_string(lhs, rhs) result(concat) Concatenation with string. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 1 ) astring = 'Hello ' anotherstring = 'Bye bye' test_passed ( 1 ) = astring // anotherstring == 'Hello Bye bye' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK, len=:), allocatable Concatenated string. Source Code pure function string_concat_string ( lhs , rhs ) result ( concat ) !< Concatenation with string. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(1) !< astring = 'Hello ' !< anotherstring = 'Bye bye' !< test_passed(1) = astring//anotherstring=='Hello Bye bye' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw endfunction string_concat_string","tags":"","loc":"proc/string_concat_string.html"},{"title":"string_concat_character – StringiFor","text":"private pure function string_concat_character(lhs, rhs) result(concat) Concatenation with character. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' test_passed ( 1 ) = astring // acharacter == 'Hello World!' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK, len=:), allocatable Concatenated string. Source Code pure function string_concat_character ( lhs , rhs ) result ( concat ) !< Concatenation with character. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< test_passed(1) = astring//acharacter=='Hello World!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif endfunction string_concat_character","tags":"","loc":"proc/string_concat_character.html"},{"title":"character_concat_string – StringiFor","text":"private pure function character_concat_string(lhs, rhs) result(concat) Concatenation with character (inverted). type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' test_passed ( 1 ) = acharacter // astring == 'World!Hello ' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK, len=:), allocatable Concatenated string. Source Code pure function character_concat_string ( lhs , rhs ) result ( concat ) !< Concatenation with character (inverted). !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< test_passed(1) = acharacter//astring=='World!Hello ' !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif endfunction character_concat_string","tags":"","loc":"proc/character_concat_string.html"},{"title":"string_concat_string_string – StringiFor","text":"private elemental function string_concat_string_string(lhs, rhs) result(concat) Concatenation with string. type ( string ) :: astring type ( string ) :: anotherstring type ( string ) :: yetanotherstring logical :: test_passed ( 1 ) astring = 'Hello ' anotherstring = 'Bye bye' yetanotherstring = astring . cat . anotherstring test_passed ( 1 ) = yetanotherstring % chars () == 'Hello Bye bye' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Source Code elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !< Concatenation with string. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< type(string) :: yetanotherstring !< logical      :: test_passed(1) !< astring = 'Hello ' !< anotherstring = 'Bye bye' !< yetanotherstring = astring.cat.anotherstring !< test_passed(1) = yetanotherstring%chars()=='Hello Bye bye' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary endfunction string_concat_string_string","tags":"","loc":"proc/string_concat_string_string.html"},{"title":"string_concat_character_string – StringiFor","text":"private elemental function string_concat_character_string(lhs, rhs) result(concat) Concatenation with character. type ( string ) :: astring type ( string ) :: yetanotherstring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' yetanotherstring = astring . cat . acharacter test_passed ( 1 ) = yetanotherstring % chars () == 'Hello World!' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Source Code elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !< Concatenation with character. !< !<```fortran !< type(string)                  :: astring !< type(string)                  :: yetanotherstring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< yetanotherstring = astring.cat.acharacter !< test_passed(1) = yetanotherstring%chars()=='Hello World!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif endfunction string_concat_character_string","tags":"","loc":"proc/string_concat_character_string.html"},{"title":"character_concat_string_string – StringiFor","text":"private elemental function character_concat_string_string(lhs, rhs) result(concat) Concatenation with character (inverted). type ( string ) :: astring type ( string ) :: yetanotherstring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' yetanotherstring = acharacter . cat . astring test_passed ( 1 ) = yetanotherstring % chars () == 'World!Hello ' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Source Code elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !< Concatenation with character (inverted). !< !<```fortran !< type(string)                  :: astring !< type(string)                  :: yetanotherstring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< yetanotherstring = acharacter.cat.astring !< test_passed(1) = yetanotherstring%chars()=='World!Hello ' !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif endfunction character_concat_string_string","tags":"","loc":"proc/character_concat_string_string.html"},{"title":"string_eq_string – StringiFor","text":"private elemental function string_eq_string(lhs, rhs) result(is_it) Equal to string logical operator. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = '  one ' anotherstring = 'two' test_passed ( 1 ) = (( astring == anotherstring ). eqv .. false .) astring = 'the same ' anotherstring = 'the same ' test_passed ( 2 ) = (( astring == anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function string_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = '  one ' !< anotherstring = 'two' !< test_passed(1) = ((astring==anotherstring).eqv..false.) !< astring = 'the same ' !< anotherstring = 'the same ' !< test_passed(2) = ((astring==anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw == rhs % raw endfunction string_eq_string","tags":"","loc":"proc/string_eq_string.html"},{"title":"string_eq_character – StringiFor","text":"private elemental function string_eq_character(lhs, rhs) result(is_it) Equal to character logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( astring == acharacter ). eqv .. false .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( astring == acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function string_eq_character ( lhs , rhs ) result ( is_it ) !< Equal to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((astring==acharacter).eqv..false.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((astring==acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw == rhs endfunction string_eq_character","tags":"","loc":"proc/string_eq_character.html"},{"title":"character_eq_string – StringiFor","text":"private elemental function character_eq_string(lhs, rhs) result(is_it) Equal to character (inverted) logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( acharacter == astring ). eqv .. false .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( acharacter == astring ). eqv .. true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function character_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((acharacter==astring).eqv..false.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((acharacter==astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = rhs % raw == lhs endfunction character_eq_string","tags":"","loc":"proc/character_eq_string.html"},{"title":"string_ne_string – StringiFor","text":"private elemental function string_ne_string(lhs, rhs) result(is_it) Not equal to string logical operator. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = '  one ' anotherstring = 'two' test_passed ( 1 ) = (( astring /= anotherstring ). eqv .. true .) astring = 'the same ' anotherstring = 'the same ' test_passed ( 2 ) = (( astring /= anotherstring ). eqv .. false .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function string_ne_string ( lhs , rhs ) result ( is_it ) !< Not equal to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = '  one ' !< anotherstring = 'two' !< test_passed(1) = ((astring/=anotherstring).eqv..true.) !< astring = 'the same ' !< anotherstring = 'the same ' !< test_passed(2) = ((astring/=anotherstring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw /= rhs % raw endfunction string_ne_string","tags":"","loc":"proc/string_ne_string.html"},{"title":"string_ne_character – StringiFor","text":"private elemental function string_ne_character(lhs, rhs) result(is_it) Not equal to character logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( astring /= acharacter ). eqv .. true .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( astring /= acharacter ). eqv .. false .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function string_ne_character ( lhs , rhs ) result ( is_it ) !< Not equal to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((astring/=acharacter).eqv..true.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((astring/=acharacter).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw /= rhs endfunction string_ne_character","tags":"","loc":"proc/string_ne_character.html"},{"title":"character_ne_string – StringiFor","text":"private elemental function character_ne_string(lhs, rhs) result(is_it) Not equal to character (inverted) logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( acharacter /= astring ). eqv .. true .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( acharacter /= astring ). eqv .. false .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function character_ne_string ( lhs , rhs ) result ( is_it ) !< Not equal to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((acharacter/=astring).eqv..true.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((acharacter/=astring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = rhs % raw /= lhs endfunction character_ne_string","tags":"","loc":"proc/character_ne_string.html"},{"title":"string_lt_string – StringiFor","text":"private elemental function string_lt_string(lhs, rhs) result(is_it) Lower than to string logical operator. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring < anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring < anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function string_lt_string ( lhs , rhs ) result ( is_it ) !< Lower than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring<anotherstring).eqv..false.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring<anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw < rhs % raw endfunction string_lt_string","tags":"","loc":"proc/string_lt_string.html"},{"title":"string_lt_character – StringiFor","text":"private elemental function string_lt_character(lhs, rhs) result(is_it) Lower than to character logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring < acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring < acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function string_lt_character ( lhs , rhs ) result ( is_it ) !< Lower than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring<acharacter).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring<acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw < rhs endfunction string_lt_character","tags":"","loc":"proc/string_lt_character.html"},{"title":"character_lt_string – StringiFor","text":"private elemental function character_lt_string(lhs, rhs) result(is_it) Lower than to character (inverted) logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter < astring ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter < astring ). eqv .. false .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function character_lt_string ( lhs , rhs ) result ( is_it ) !< Lower than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter<astring).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter<astring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs < rhs % raw endfunction character_lt_string","tags":"","loc":"proc/character_lt_string.html"},{"title":"string_le_string – StringiFor","text":"private elemental function string_le_string(lhs, rhs) result(is_it) Lower equal than to string logical operator. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 3 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring <= anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring <= anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'ONE' test_passed ( 3 ) = (( astring <= anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function string_le_string ( lhs , rhs ) result ( is_it ) !< Lower equal than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(3) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring<=anotherstring).eqv..false.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring<=anotherstring).eqv..true.) !< astring = 'ONE' !< anotherstring = 'ONE' !< test_passed(3) = ((astring<=anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw <= rhs % raw endfunction string_le_string","tags":"","loc":"proc/string_le_string.html"},{"title":"string_le_character – StringiFor","text":"private elemental function string_le_character(lhs, rhs) result(is_it) Lower equal than to character logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring <= acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring <= acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( astring <= acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function string_le_character ( lhs , rhs ) result ( is_it ) !< Lower equal than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring<=acharacter).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring<=acharacter).eqv..true.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((astring<=acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw <= rhs endfunction string_le_character","tags":"","loc":"proc/string_le_character.html"},{"title":"character_le_string – StringiFor","text":"private elemental function character_le_string(lhs, rhs) result(is_it) Lower equal than to character (inverted) logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter <= astring ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter <= astring ). eqv .. false .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( acharacter <= astring ). eqv .. true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function character_le_string ( lhs , rhs ) result ( is_it ) !< Lower equal than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter<=astring).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter<=astring).eqv..false.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((acharacter<=astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs <= rhs % raw endfunction character_le_string","tags":"","loc":"proc/character_le_string.html"},{"title":"string_ge_string – StringiFor","text":"private elemental function string_ge_string(lhs, rhs) result(is_it) Greater equal than to string logical operator. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 3 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring >= anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring >= anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'ONE' test_passed ( 3 ) = (( astring >= anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function string_ge_string ( lhs , rhs ) result ( is_it ) !< Greater equal than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(3) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring>=anotherstring).eqv..true.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring>=anotherstring).eqv..false.) !< astring = 'ONE' !< anotherstring = 'ONE' !< test_passed(3) = ((astring>=anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw >= rhs % raw endfunction string_ge_string","tags":"","loc":"proc/string_ge_string.html"},{"title":"string_ge_character – StringiFor","text":"private elemental function string_ge_character(lhs, rhs) result(is_it) Greater equal than to character logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring >= acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring >= acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( astring >= acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function string_ge_character ( lhs , rhs ) result ( is_it ) !< Greater equal than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring>=acharacter).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring>=acharacter).eqv..false.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((astring>=acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw >= rhs endfunction string_ge_character","tags":"","loc":"proc/string_ge_character.html"},{"title":"character_ge_string – StringiFor","text":"private elemental function character_ge_string(lhs, rhs) result(is_it) Greater equal than to character (inverted) logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter >= astring ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter >= astring ). eqv .. true .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( acharacter >= astring ). eqv .. true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function character_ge_string ( lhs , rhs ) result ( is_it ) !< Greater equal than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter>=astring).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter>=astring).eqv..true.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((acharacter>=astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs >= rhs % raw endfunction character_ge_string","tags":"","loc":"proc/character_ge_string.html"},{"title":"string_gt_string – StringiFor","text":"private elemental function string_gt_string(lhs, rhs) result(is_it) Greater than to string logical operator. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring > anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring > anotherstring ). eqv .. false .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function string_gt_string ( lhs , rhs ) result ( is_it ) !< Greater than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring>anotherstring).eqv..true.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring>anotherstring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw > rhs % raw endfunction string_gt_string","tags":"","loc":"proc/string_gt_string.html"},{"title":"string_gt_character – StringiFor","text":"private elemental function string_gt_character(lhs, rhs) result(is_it) Greater than to character logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring > acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring > acharacter ). eqv .. false .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function string_gt_character ( lhs , rhs ) result ( is_it ) !< Greater than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring>acharacter).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring>acharacter).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw > rhs endfunction string_gt_character","tags":"","loc":"proc/string_gt_character.html"},{"title":"character_gt_string – StringiFor","text":"private elemental function character_gt_string(lhs, rhs) result(is_it) Greater than to character (inverted) logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter > astring ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter > astring ). eqv .. true .) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Source Code elemental function character_gt_string ( lhs , rhs ) result ( is_it ) !< Greater than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter>astring).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter>astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs > rhs % raw endfunction character_gt_string","tags":"","loc":"proc/character_gt_string.html"},{"title":"replace_one_occurrence – StringiFor","text":"private elemental function replace_one_occurrence(self, old, new) result(replaced) Return a string with the first occurrence of substring old replaced by new. Note The doctest is not necessary, this being tested by replace . Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: old Old substring. character(kind=CK, len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Called by proc~~replace_one_occurrence~~CalledByGraph proc~replace_one_occurrence string%replace_one_occurrence proc~replace string%replace proc~replace->proc~replace_one_occurrence proc~unique string%unique proc~unique->proc~replace program~volatile_doctest~62 volatile_doctest program~volatile_doctest~62->proc~replace proc~split string%split proc~split->proc~unique program~volatile_doctest~41 volatile_doctest program~volatile_doctest~41->proc~unique proc~camelcase string%camelcase proc~camelcase->proc~split proc~glob_string string%glob_string proc~glob_string->proc~split proc~snakecase string%snakecase proc~snakecase->proc~split proc~split_chunked string%split_chunked proc~split_chunked->proc~split proc~startcase string%startcase proc~startcase->proc~split proc~write_lines~2 string%write_lines proc~write_lines~2->proc~split program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~split program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~split program~stringifor_test_parse_large_csv->proc~split_chunked program~volatile_doctest~107 volatile_doctest program~volatile_doctest~107->proc~split program~volatile_doctest~15 volatile_doctest program~volatile_doctest~15->proc~split program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~split program~volatile_doctest~23 volatile_doctest program~volatile_doctest~23->proc~split program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~split proc~write_file~2 string%write_file program~volatile_doctest~44->proc~write_file~2 interface~glob glob interface~glob->proc~glob_string proc~glob_character string%glob_character interface~glob->proc~glob_character none~glob string%glob none~glob->proc~glob_string none~glob->proc~glob_character proc~write_file~2->proc~write_lines~2 program~volatile_doctest~18 volatile_doctest program~volatile_doctest~18->proc~camelcase program~volatile_doctest~2 volatile_doctest program~volatile_doctest~2->proc~startcase program~volatile_doctest~75 volatile_doctest program~volatile_doctest~75->proc~split_chunked program~volatile_doctest~98 volatile_doctest program~volatile_doctest~98->proc~snakecase proc~glob_character->none~glob program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->none~glob program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->none~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !< Return a string with the first occurrence of substring old replaced by new. !< !< @note The doctest is not necessary, this being tested by [[string:replace]]. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif endif endif endfunction replace_one_occurrence","tags":"","loc":"proc/replace_one_occurrence.html"},{"title":"free – StringiFor","text":"private elemental subroutine free(self) Free dynamic memory. type ( string ) :: astring astring = 'this is string example....wow!!!' call astring % free print '(L1)' , astring % is_allocated (). eqv .. false . Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Source Code elemental subroutine free ( self ) !< Free dynamic memory. !< !<```fortran !< type(string) :: astring !< astring = 'this is string example....wow!!!' !< call astring%free !< print '(L1)', astring%is_allocated().eqv..false. !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. if ( allocated ( self % raw )) deallocate ( self % raw ) endsubroutine free","tags":"","loc":"proc/free.html"},{"title":"glob_character – StringiFor","text":"private  subroutine glob_character(self, pattern, list) Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. @note Note\n      Method not portable: works only on Unix/GNU Linux OS. type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_chr ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr print '(L1)' , test_passed Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: pattern Given pattern. character(len=:), intent(out), allocatable :: list (:) List of matching pathnames. Calls proc~~glob_character~~CallsGraph proc~glob_character string%glob_character none~glob string%glob proc~glob_character->none~glob proc~chars string%chars proc~glob_character->proc~chars none~glob->proc~glob_character proc~glob_string string%glob_string none~glob->proc~glob_string proc~read_file~2 string%read_file proc~glob_string->proc~read_file~2 proc~split string%split proc~glob_string->proc~split proc~tempname string%tempname proc~glob_string->proc~tempname proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~upper string%upper proc~read_file~2->proc~upper proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~replace string%replace proc~unique->proc~replace proc~read_line->proc~chars proc~read_line->proc~upper proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~glob_character~~CalledByGraph proc~glob_character string%glob_character none~glob string%glob proc~glob_character->none~glob interface~glob glob interface~glob->proc~glob_character none~glob->proc~glob_character program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->none~glob program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->none~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine glob_character ( self , pattern , list ) !< Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. !< !< @note Method not portable: works only on Unix/GNU Linux OS. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: alist_chr(:) !< integer, parameter            :: Nf=5 !< character(14)                 :: files(1:Nf) !< integer                       :: file_unit !< integer                       :: f !< integer                       :: ff !< logical                       :: test_passed !< do f=1, Nf !<    files(f) = astring%tempname(prefix='foo-') !<    open(newunit=file_unit, file=files(f)) !<    write(file_unit, *)f !<    close(unit=file_unit) !< enddo !< call astring%glob(pattern='foo-*', list=alist_chr) !< do f=1, Nf !<    open(newunit=file_unit, file=files(f)) !<    close(unit=file_unit, status='delete') !< enddo !< test_passed = .false. !< outer_chr: do f=1, size(alist_chr, dim=1) !<    do ff=1, Nf !<       test_passed = alist_chr(f) == files(ff) !<       if (test_passed) cycle outer_chr !<    enddo !< enddo outer_chr !< print '(L1)', test_passed !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: pattern !< Given pattern. character ( len = :), allocatable , intent ( out ) :: list (:) !< List of matching pathnames. type ( string ), allocatable :: list_ (:) !< List of matching pathnames. integer ( I4P ) :: max_len !< Maximum length. integer ( I4P ) :: matches_number !< Matches number. integer ( I4P ) :: m !< Counter. call self % glob ( pattern = pattern , list = list_ ) if ( allocated ( list_ )) then matches_number = size ( list_ , dim = 1 ) max_len = 0 do m = 1 , matches_number max_len = max ( max_len , list_ ( m )% len ()) enddo allocate ( character ( max_len ) :: list ( 1 : matches_number )) do m = 1 , matches_number list ( m ) = list_ ( m )% chars () enddo endif endsubroutine glob_character","tags":"","loc":"proc/glob_character.html"},{"title":"glob_string – StringiFor","text":"private  subroutine glob_string(self, pattern, list) Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. @note Note\n      Method not portable: works only on Unix/GNU Linux OS. type ( string ) :: astring type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str print '(L1)' , test_passed Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: pattern Given pattern. type( string ), intent(out), allocatable :: list (:) List of matching pathnames. Calls proc~~glob_string~~CallsGraph proc~glob_string string%glob_string proc~read_file~2 string%read_file proc~glob_string->proc~read_file~2 proc~split string%split proc~glob_string->proc~split proc~tempname string%tempname proc~glob_string->proc~tempname proc~chars string%chars proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~upper string%upper proc~read_file~2->proc~upper proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~replace string%replace proc~unique->proc~replace proc~read_line->proc~chars proc~read_line->proc~upper proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~glob_string~~CalledByGraph proc~glob_string string%glob_string interface~glob glob interface~glob->proc~glob_string proc~glob_character string%glob_character interface~glob->proc~glob_character none~glob string%glob none~glob->proc~glob_string none~glob->proc~glob_character proc~glob_character->none~glob program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->none~glob program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->none~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine glob_string ( self , pattern , list ) !< Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. !< !< @note Method not portable: works only on Unix/GNU Linux OS. !< !<```fortran !< type(string)                  :: astring !< type(string),     allocatable :: alist_str(:) !< integer, parameter            :: Nf=5 !< character(14)                 :: files(1:Nf) !< integer                       :: file_unit !< integer                       :: f !< integer                       :: ff !< logical                       :: test_passed !< !< do f=1, Nf !<    files(f) = astring%tempname(prefix='foo-') !<    open(newunit=file_unit, file=files(f)) !<    write(file_unit, *)f !<    close(unit=file_unit) !< enddo !< call astring%glob(pattern='foo-*', list=alist_str) !< do f=1, Nf !<    open(newunit=file_unit, file=files(f)) !<    close(unit=file_unit, status='delete') !< enddo !< test_passed = .false. !< outer_str: do f=1, size(alist_str, dim=1) !<    do ff=1, Nf !<       test_passed = alist_str(f) == files(ff) !<       if (test_passed) cycle outer_str !<    enddo !< enddo outer_str !< print '(L1)', test_passed !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: pattern !< Given pattern. type ( string ), allocatable , intent ( out ) :: list (:) !< List of matching pathnames. type ( string ) :: tempfile !< Safe temporary file. character ( len = :), allocatable :: tempname !< Safe temporary name. integer ( I4P ) :: tempunit !< Unit of temporary file. tempname = self % tempname () call execute_command_line ( 'ls -1 ' // trim ( adjustl ( pattern )) // ' > ' // tempname ) call tempfile % read_file ( file = tempname ) call tempfile % split ( sep = new_line ( 'a' ), tokens = list ) open ( newunit = tempunit , file = tempname ) close ( unit = tempunit , status = 'delete' ) endsubroutine glob_string","tags":"","loc":"proc/glob_string.html"},{"title":"read_file – StringiFor","text":"private  subroutine read_file(self, file, is_fast, form, iostat, iomsg) Read a file as a single string stream. @note Note\n      All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a new_line character. @note Note\n      For unformatted read only access='stream' is supported with new_line as line terminator. @note Note Fast file reading allows a very efficient reading of streamed file, but it dumps file as single streamed string. type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 9 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) call astring % read_file ( file = 'read_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat ) test_passed ( 9 ) = ( iostat /= 0 ) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. logical, intent(in), optional :: is_fast Flag to enable (super) fast file reading. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Calls proc~~read_file~2~~CallsGraph proc~read_file~2 string%read_file proc~chars string%chars proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~upper string%upper proc~read_file~2->proc~upper proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~read_line->proc~chars proc~read_line->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_file~2~~CalledByGraph proc~read_file~2 string%read_file proc~glob_string string%glob_string proc~glob_string->proc~read_file~2 program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~read_file~2 program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~read_file~2 program~volatile_doctest~107 volatile_doctest program~volatile_doctest~107->proc~read_file~2 program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~read_file~2 program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~read_file~2 interface~glob glob interface~glob->proc~glob_string proc~glob_character string%glob_character interface~glob->proc~glob_character none~glob string%glob none~glob->proc~glob_string none~glob->proc~glob_character proc~glob_character->none~glob program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->none~glob program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->none~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_file ( self , file , is_fast , form , iostat , iomsg ) !< Read a file as a single string stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !< @note *Fast* file reading allows a very efficient reading of streamed file, but it dumps file as single streamed string. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(9) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, file='read_file_test.tmp') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< close(scratch) !< call astring%read_file(file='read_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< close(scratch) !< call astring%read_file(file='read_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< close(scratch, status='DELETE') !< call astring%read_file(file='read_file_test.tmp', iostat=iostat) !< test_passed(9) = (iostat/=0) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. logical , intent ( in ), optional :: is_fast !< Flag to enable (super) fast file reading. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. logical :: is_fast_ !< Flag to enable (super) fast file reading, local variable. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. integer ( I4P ) :: filesize !< Size of the file for fast reading. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then is_fast_ = . false . ; if ( present ( is_fast )) is_fast_ = is_fast if ( is_fast_ ) then open ( newunit = unit , file = file , access = 'STREAM' , form = 'UNFORMATTED' , iomsg = iomsg_ , iostat = iostat_ ) inquire ( file = file , size = filesize ) if ( allocated ( self % raw )) deallocate ( self % raw ) allocate ( character ( len = filesize ) :: self % raw ) read ( unit = unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw close ( unit ) else form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % read_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif else iostat_ = 1 iomsg_ = 'file not found' endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_file","tags":"","loc":"proc/read_file~2.html"},{"title":"read_line – StringiFor","text":"private  subroutine read_line(self, unit, form, iostat, iomsg) Read line (record) from a connected unit. The line is read as an ascii stream read until the eor is reached. @note Note\n      For unformatted read only access='stream' is supported with new_line as line terminator. type ( string ) :: astring type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 6 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then exit else test_passed ( l ) = ( astring == line ( l )) endif enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg , form = 'UnfORMatteD' ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then exit else test_passed ( l + 3 ) = ( astring == line ( l )) endif enddo close ( scratch ) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Calls proc~~read_line~~CallsGraph proc~read_line string%read_line proc~chars string%chars proc~read_line->proc~chars proc~upper string%upper proc~read_line->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_line~~CalledByGraph proc~read_line string%read_line proc~read_lines read_lines proc~read_lines->proc~read_line proc~read_lines~2 string%read_lines proc~read_lines~2->proc~read_line program~volatile_doctest~87 volatile_doctest program~volatile_doctest~87->proc~read_line proc~read_file read_file proc~read_file->proc~read_lines proc~read_file~2 string%read_file proc~read_file~2->proc~read_lines~2 program~volatile_doctest~15 volatile_doctest program~volatile_doctest~15->proc~read_lines~2 proc~glob_string string%glob_string proc~glob_string->proc~read_file~2 program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~read_file~2 program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~read_file~2 program~volatile_doctest~107 volatile_doctest program~volatile_doctest~107->proc~read_file~2 program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~read_file~2 program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~read_file~2 program~volatile_doctest~54 volatile_doctest program~volatile_doctest~54->proc~read_file interface~glob glob interface~glob->proc~glob_string proc~glob_character string%glob_character interface~glob->proc~glob_character none~glob string%glob none~glob->proc~glob_string none~glob->proc~glob_character proc~glob_character->none~glob program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->none~glob program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->none~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_line ( self , unit , form , iostat , iomsg ) !< Read line (record) from a connected unit. !< !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)      :: astring !< type(string)      :: line(3) !< integer           :: iostat !< character(len=99) :: iomsg !< integer           :: scratch !< integer           :: l !< logical           :: test_passed(6) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, status='SCRATCH') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< rewind(scratch) !< l = 0 !< iostat = 0 !< do !<   l = l + 1 !<   call astring%read_line(unit=scratch, iostat=iostat, iomsg=iomsg) !<   if (iostat/=0.and..not.is_iostat_eor(iostat)) then !<     exit !<   else !<     test_passed(l) = (astring==line(l)) !<   endif !< enddo !< close(scratch) !< open(newunit=scratch, status='SCRATCH', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< rewind(scratch) !< l = 0 !< iostat = 0 !< do !<   l = l + 1 !<   call astring%read_line(unit=scratch, iostat=iostat, iomsg=iomsg, form='UnfORMatteD') !<   if (iostat/=0.and..not.is_iostat_eor(iostat)) then !<     exit !<   else !<     test_passed(l+3) = (astring==line(l)) !<   endif !< enddo !< close(scratch) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = :), allocatable :: line !< Line storage. character ( kind = CK , len = 1 ) :: ch !< Character storage. form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg line = '' select case ( form_ % chars ()) case ( 'FORMATTED' ) do read ( unit , \"(A)\" , advance = 'no' , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 , eor = 10 ) ch line = line // ch enddo case ( 'UNFORMATTED' ) do read ( unit , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) then iostat_ = iostat_eor exit endif line = line // ch enddo endselect 10 if ( line /= '' ) self % raw = line if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_line","tags":"","loc":"proc/read_line.html"},{"title":"read_lines – StringiFor","text":"private  subroutine read_lines(self, unit, form, iostat, iomsg) Read (all) lines (records) from a connected unit as a single ascii stream. @note Note\n      All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a new_line character. The line is read as an ascii stream read until the eor is reached. @note Note\n      The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. @note Note\n      For unformatted read only access='stream' is supported with new_line as line terminator. type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) call astring % read_lines ( unit = scratch , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo close ( scratch ) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Calls proc~~read_lines~2~~CallsGraph proc~read_lines~2 string%read_lines proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~chars string%chars proc~read_line->proc~chars proc~upper string%upper proc~read_line->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_lines~2~~CalledByGraph proc~read_lines~2 string%read_lines proc~read_file~2 string%read_file proc~read_file~2->proc~read_lines~2 program~volatile_doctest~15 volatile_doctest program~volatile_doctest~15->proc~read_lines~2 proc~glob_string string%glob_string proc~glob_string->proc~read_file~2 program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~read_file~2 program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~read_file~2 program~volatile_doctest~107 volatile_doctest program~volatile_doctest~107->proc~read_file~2 program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~read_file~2 program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~read_file~2 interface~glob glob interface~glob->proc~glob_string proc~glob_character string%glob_character interface~glob->proc~glob_character none~glob string%glob none~glob->proc~glob_string none~glob->proc~glob_character proc~glob_character->none~glob program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->none~glob program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->none~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_lines ( self , unit , form , iostat , iomsg ) !< Read (all) lines (records) from a connected unit as a single ascii stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. The line is read as an ascii stream read until the eor is reached. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, status='SCRATCH') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< call astring%read_lines(unit=scratch, iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< close(scratch) !< open(newunit=scratch, status='SCRATCH', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< call astring%read_lines(unit=scratch, form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< close(scratch) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. type ( string ) :: lines !< Lines storage. type ( string ) :: line !< Line storage. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) iostat_ = 0 lines % raw = '' do line % raw = '' call line % read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if ( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )) then exit elseif ( line /= '' ) then lines % raw = lines % raw // line % raw // new_line ( 'a' ) endif enddo if ( lines % raw /= '' ) self % raw = lines % raw if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_lines","tags":"","loc":"proc/read_lines~2.html"},{"title":"split – StringiFor","text":"private pure subroutine split(self, tokens, sep, max_tokens) Return a list of substring in the string, using sep as the delimiter string. @note Note\n      Multiple subsequent separators are collapsed to one occurrence. @note Note\n      If max_tokens is passed the returned number of tokens is either max_tokens or max_tokens + 1 . type ( string ) :: astring type ( string ), allocatable :: strings (:) logical :: test_passed ( 11 ) astring = '+ab-++cre-++cre-ab+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'ab-++cre-++cre-ab+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'ab-++cre-++cre-ab' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'Hello ' // new_line ( 'a' ) // 'World!' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) astring = 'Hello World!' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) astring = '+ab-' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 6 ) = ( strings ( 1 ) // '' == 'ab-' ) astring = '+ab-' call astring % split ( tokens = strings , sep = '-' ) test_passed ( 7 ) = ( strings ( 1 ) // '' == '+ab' ) astring = '+ab-+cd-' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 8 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = 'ab-+cd-+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 9 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = '+ab-+cd-+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 10 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = '1-2-3-4-5-6-7-8' call astring % split ( tokens = strings , sep = '-' , max_tokens = 3 ) test_passed ( 11 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4-5-6-7-8' ) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK, len=*), intent(in), optional :: sep Separator. integer, intent(in), optional :: max_tokens Fix the maximum number of returned tokens. Calls proc~~split~~CallsGraph proc~split string%split proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~split~~CalledByGraph proc~split string%split proc~camelcase string%camelcase proc~camelcase->proc~split proc~glob_string string%glob_string proc~glob_string->proc~split proc~snakecase string%snakecase proc~snakecase->proc~split proc~split_chunked string%split_chunked proc~split_chunked->proc~split proc~startcase string%startcase proc~startcase->proc~split proc~write_lines~2 string%write_lines proc~write_lines~2->proc~split program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~split program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~split program~stringifor_test_parse_large_csv->proc~split_chunked program~volatile_doctest~107 volatile_doctest program~volatile_doctest~107->proc~split program~volatile_doctest~15 volatile_doctest program~volatile_doctest~15->proc~split program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~split program~volatile_doctest~23 volatile_doctest program~volatile_doctest~23->proc~split program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~split proc~write_file~2 string%write_file program~volatile_doctest~44->proc~write_file~2 interface~glob glob interface~glob->proc~glob_string proc~glob_character string%glob_character interface~glob->proc~glob_character none~glob string%glob none~glob->proc~glob_string none~glob->proc~glob_character proc~write_file~2->proc~write_lines~2 program~volatile_doctest~18 volatile_doctest program~volatile_doctest~18->proc~camelcase program~volatile_doctest~2 volatile_doctest program~volatile_doctest~2->proc~startcase program~volatile_doctest~75 volatile_doctest program~volatile_doctest~75->proc~split_chunked program~volatile_doctest~98 volatile_doctest program~volatile_doctest~98->proc~snakecase proc~glob_character->none~glob program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->none~glob program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->none~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine split ( self , tokens , sep , max_tokens ) !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurrence. !< !< @note If `max_tokens` is passed the returned number of tokens is either `max_tokens` or `max_tokens + 1`. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< logical                   :: test_passed(11) !< astring = '+ab-++cre-++cre-ab+' !< call astring%split(tokens=strings, sep='+') !< test_passed(1) = (strings(1)//''=='ab-'.and.strings(2)//''=='cre-'.and.strings(3)//''=='cre-ab') !< astring = 'ab-++cre-++cre-ab+' !< call astring%split(tokens=strings, sep='+') !< test_passed(2) = (strings(1)//''=='ab-'.and.strings(2)//''=='cre-'.and.strings(3)//''=='cre-ab') !< astring = 'ab-++cre-++cre-ab' !< call astring%split(tokens=strings, sep='+') !< test_passed(3) = (strings(1)//''=='ab-'.and.strings(2)//''=='cre-'.and.strings(3)//''=='cre-ab') !< astring = 'Hello '//new_line('a')//'World!' !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(4) = (strings(1)//''=='Hello '.and.strings(2)//''=='World!') !< astring = 'Hello World!' !< call astring%split(tokens=strings) !< test_passed(5) = (strings(1)//''=='Hello'.and.strings(2)//''=='World!') !< astring = '+ab-' !< call astring%split(tokens=strings, sep='+') !< test_passed(6) = (strings(1)//''=='ab-') !< astring = '+ab-' !< call astring%split(tokens=strings, sep='-') !< test_passed(7) = (strings(1)//''=='+ab') !< astring = '+ab-+cd-' !< call astring%split(tokens=strings, sep='+') !< test_passed(8) = (strings(1)//''=='ab-'.and.strings(2)//''=='cd-') !< astring = 'ab-+cd-+' !< call astring%split(tokens=strings, sep='+') !< test_passed(9) = (strings(1)//''=='ab-'.and.strings(2)//''=='cd-') !< astring = '+ab-+cd-+' !< call astring%split(tokens=strings, sep='+') !< test_passed(10) = (strings(1)//''=='ab-'.and.strings(2)//''=='cd-') !< astring = '1-2-3-4-5-6-7-8' !< call astring%split(tokens=strings, sep='-', max_tokens=3) !< test_passed(11) = (strings(1)//''=='1'.and.strings(2)//''=='2'.and.strings(3)//''=='3'.and.strings(4)//''=='4-5-6-7-8') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. integer , intent ( in ), optional :: max_tokens !< Fix the maximum number of returned tokens. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % count ( sep_ ) if ( No > 0 ) then if ( present ( max_tokens )) then if ( max_tokens < No . and . max_tokens > 0 ) No = max_tokens endif allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No - 1 tokens ( t ) = temp_toks ( 1 , t + 1 ) enddo tokens ( No ) = temp_toks ( 3 , No ) else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif else allocate ( tokens ( 1 )) tokens ( 1 ) = self endif endif endsubroutine split","tags":"","loc":"proc/split.html"},{"title":"split_chunked – StringiFor","text":"private pure subroutine split_chunked(self, tokens, chunks, sep) Return a list of substring in the string, using sep as the delimiter string, chunked (memory-efficient) algorithm. @note Note\n      Multiple subsequent separators are collapsed to one occurrence. @note Note\n      The split is performed in chunks of #chunks to avoid excessive memory consumption. type ( string ) :: astring type ( string ), allocatable :: strings (:) logical :: test_passed ( 1 ) astring = '-1-2-3-4-5-6-7-8-' call astring % split_chunked ( tokens = strings , sep = '-' , chunks = 3 ) test_passed ( 1 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4' . and . & strings ( 5 ) // '' == '5' . and . strings ( 6 ) // '' == '6' . and . strings ( 7 ) // '' == '7' . and . strings ( 8 ) // '' == '8' ) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. integer, intent(in) :: chunks Number of chunks. character(kind=CK, len=*), intent(in), optional :: sep Separator. Calls proc~~split_chunked~~CallsGraph proc~split_chunked string%split_chunked proc~end_with string%end_with proc~split_chunked->proc~end_with proc~split string%split proc~split_chunked->proc~split proc~start_with string%start_with proc~split_chunked->proc~start_with proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~split_chunked~~CalledByGraph proc~split_chunked string%split_chunked program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->proc~split_chunked program~volatile_doctest~75 volatile_doctest program~volatile_doctest~75->proc~split_chunked Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine split_chunked ( self , tokens , chunks , sep ) !< Return a list of substring in the string, using sep as the delimiter string, chunked (memory-efficient) algorithm. !< !< @note Multiple subsequent separators are collapsed to one occurrence. !< !< @note The split is performed in chunks of `#chunks` to avoid excessive memory consumption. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< logical                   :: test_passed(1) !< astring = '-1-2-3-4-5-6-7-8-' !< call astring%split_chunked(tokens=strings, sep='-', chunks=3) !< test_passed(1) = (strings(1)//''=='1'.and.strings(2)//''=='2'.and.strings(3)//''=='3'.and.strings(4)//''=='4'.and. & !<                   strings(5)//''=='5'.and.strings(6)//''=='6'.and.strings(7)//''=='7'.and.strings(8)//''=='8') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. integer , intent ( in ) :: chunks !< Number of chunks. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: Nt !< Number of actual tokens. integer :: t !< Counter. logical :: isok if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep Nt = self % count ( sep_ ) if ( self % start_with ( prefix = sep_ )) Nt = Nt - 1 if ( self % end_with ( suffix = sep_ )) Nt = Nt - 1 t = 0 call self % split ( tokens = tokens , sep = sep_ , max_tokens = chunks ) do t = size ( tokens , dim = 1 ) if ( t > Nt ) exit call split_last_token ( tokens = tokens , max_tokens = chunks , isok = isok ) if ( isok ) then else exit endif enddo t = size ( tokens , dim = 1 ) if ( tokens ( t )% count ( sep_ ) > 0 ) then call split_last_token ( tokens = tokens , isok = isok ) endif endif contains pure subroutine split_last_token ( tokens , max_tokens , isok ) !< Split last token. type ( string ), allocatable , intent ( inout ) :: tokens (:) !< Tokens substring. integer , intent ( in ), optional :: max_tokens !< Max tokens returned. type ( string ), allocatable :: tokens_ (:) !< Temporary tokens. type ( string ), allocatable :: tokens_swap (:) !< Swap tokens. integer :: Nt_ !< Number of last created tokens. logical , intent ( out ) :: isok isok = . true . call tokens ( t )% split ( tokens = tokens_ , sep = sep_ , max_tokens = max_tokens ) if ( allocated ( tokens_ )) then Nt_ = size ( tokens_ , dim = 1 ) if ( Nt_ >= 1 ) then allocate ( tokens_swap ( 1 : t - 1 + Nt_ )) tokens_swap ( 1 : t - 1 ) = tokens ( 1 : t - 1 ) tokens_swap ( t :) = tokens_ (:) call move_alloc ( from = tokens_swap , to = tokens ) endif if ( Nt_ == 1 ) then isok = . false . end if deallocate ( tokens_ ) endif endsubroutine split_last_token endsubroutine split_chunked","tags":"","loc":"proc/split_chunked.html"},{"title":"write_file – StringiFor","text":"private  subroutine write_file(self, file, form, iostat, iomsg) Write a single string stream into file. @note Note\n      For unformatted read only access='stream' is supported with new_line as line terminator. type ( string ) :: astring type ( string ) :: anotherstring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) call anotherstring % write_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo call anotherstring % write_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( unit = scratch , status = 'delete' ) print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Calls proc~~write_file~2~~CallsGraph proc~write_file~2 string%write_file proc~chars string%chars proc~write_file~2->proc~chars proc~upper string%upper proc~write_file~2->proc~upper proc~write_lines~2 string%write_lines proc~write_file~2->proc~write_lines~2 proc~split string%split proc~write_lines~2->proc~split proc~write_line string%write_line proc~write_lines~2->proc~write_line proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~write_line->proc~chars proc~write_line->proc~upper proc~end_with string%end_with proc~write_line->proc~end_with proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~write_file~2~~CalledByGraph proc~write_file~2 string%write_file program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~write_file~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine write_file ( self , file , form , iostat , iomsg ) !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string)              :: anotherstring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< anotherstring = anotherstring%join(array=line, sep=new_line('a')) !< call anotherstring%write_file(file='write_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< call anotherstring%write_file(file='write_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='write_file_test.tmp') !< close(unit=scratch, status='delete') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % write_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_file","tags":"","loc":"proc/write_file~2.html"},{"title":"write_line – StringiFor","text":"private  subroutine write_line(self, unit, form, iostat, iomsg) Write line (record) to a connected unit. Note If the connected unit is unformatted a new_line() character is added at the end (if necessary) to mark the end of line. Note There is no doctests, this being tested by means of write_file doctests. Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Calls proc~~write_line~~CallsGraph proc~write_line string%write_line proc~chars string%chars proc~write_line->proc~chars proc~end_with string%end_with proc~write_line->proc~end_with proc~upper string%upper proc~write_line->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~write_line~~CalledByGraph proc~write_line string%write_line proc~write_lines write_lines proc~write_lines->proc~write_line proc~write_lines~2 string%write_lines proc~write_lines~2->proc~write_line proc~write_file write_file proc~write_file->proc~write_lines proc~write_file~2 string%write_file proc~write_file~2->proc~write_lines~2 program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~write_file program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->proc~write_file program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~write_file~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine write_line ( self , unit , form , iostat , iomsg ) !< Write line (record) to a connected unit. !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !< !< @note There is no doctests, this being tested by means of [[string:write_file]] doctests. class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. iostat_ = 0 iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg if ( allocated ( self % raw )) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) write ( unit , \"(A)\" , iostat = iostat_ , iomsg = iomsg_ ) self % raw case ( 'UNFORMATTED' ) if ( self % end_with ( new_line ( 'a' ))) then write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw else write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw // new_line ( 'a' ) endif endselect endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_line","tags":"","loc":"proc/write_line.html"},{"title":"write_lines – StringiFor","text":"private  subroutine write_lines(self, unit, form, iostat, iomsg) Write lines (records) to a connected unit. This method checks if self contains more than one line (records) and writes them as lines (records). Note If the connected unit is unformatted a new_line() character is added at the end (if necessary) to mark the end of line. Note There is no doctests, this being tested by means of write_file doctests. Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Calls proc~~write_lines~2~~CallsGraph proc~write_lines~2 string%write_lines proc~split string%split proc~write_lines~2->proc~split proc~write_line string%write_line proc~write_lines~2->proc~write_line proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~chars string%chars proc~write_line->proc~chars proc~end_with string%end_with proc~write_line->proc~end_with proc~upper string%upper proc~write_line->proc~upper proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~write_lines~2~~CalledByGraph proc~write_lines~2 string%write_lines proc~write_file~2 string%write_file proc~write_file~2->proc~write_lines~2 program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->proc~write_file~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine write_lines ( self , unit , form , iostat , iomsg ) !< Write lines (records) to a connected unit. !< !< This method checks if self contains more than one line (records) and writes them as lines (records). !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !< !< @note There is no doctests, this being tested by means of [[string:write_file]] doctests. class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ), allocatable :: lines (:) !< Lines. integer :: l !< Counter. if ( allocated ( self % raw )) then call self % split ( tokens = lines , sep = new_line ( 'a' )) do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endif endsubroutine write_lines","tags":"","loc":"proc/write_lines~2.html"},{"title":"string_assign_string – StringiFor","text":"private pure subroutine string_assign_string(lhs, rhs) Assignment operator from string input. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 1 ) astring = 'hello' anotherstring = astring test_passed ( 1 ) = astring % chars () == anotherstring % chars () print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Source Code pure subroutine string_assign_string ( lhs , rhs ) !< Assignment operator from string input. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(1) !< astring = 'hello' !< anotherstring = astring !< test_passed(1) = astring%chars()==anotherstring%chars() !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( rhs % raw )) lhs % raw = rhs % raw endsubroutine string_assign_string","tags":"","loc":"proc/string_assign_string.html"},{"title":"string_assign_character – StringiFor","text":"private pure subroutine string_assign_character(lhs, rhs) Assignment operator from character input. type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'hello' test_passed ( 1 ) = astring % chars () == 'hello' print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Source Code pure subroutine string_assign_character ( lhs , rhs ) !< Assignment operator from character input. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'hello' !< test_passed(1) = astring%chars()=='hello' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. lhs % raw = rhs endsubroutine string_assign_character","tags":"","loc":"proc/string_assign_character.html"},{"title":"string_assign_integer_I1P – StringiFor","text":"private pure subroutine string_assign_integer_I1P(lhs, rhs) Assignment operator from integer input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I1P test_passed ( 1 ) = astring % to_number ( kind = 1_I1P ) == 127_I1P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_integer_i1p~~CallsGraph proc~string_assign_integer_i1p string%string_assign_integer_I1P str str proc~string_assign_integer_i1p->str Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine string_assign_integer_I1P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I1P !< test_passed(1) = astring%to_number(kind=1_I1P)==127_I1P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I1P","tags":"","loc":"proc/string_assign_integer_i1p.html"},{"title":"string_assign_integer_I2P – StringiFor","text":"private pure subroutine string_assign_integer_I2P(lhs, rhs) Assignment operator from integer input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I2P test_passed ( 1 ) = astring % to_number ( kind = 1_I2P ) == 127_I2P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_integer_i2p~~CallsGraph proc~string_assign_integer_i2p string%string_assign_integer_I2P str str proc~string_assign_integer_i2p->str Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine string_assign_integer_I2P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I2P !< test_passed(1) = astring%to_number(kind=1_I2P)==127_I2P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I2P","tags":"","loc":"proc/string_assign_integer_i2p.html"},{"title":"string_assign_integer_I4P – StringiFor","text":"private pure subroutine string_assign_integer_I4P(lhs, rhs) Assignment operator from integer input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I4P test_passed ( 1 ) = astring % to_number ( kind = 1_I4P ) == 127_I4P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_integer_i4p~~CallsGraph proc~string_assign_integer_i4p string%string_assign_integer_I4P str str proc~string_assign_integer_i4p->str Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine string_assign_integer_I4P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I4P !< test_passed(1) = astring%to_number(kind=1_I4P)==127_I4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I4P","tags":"","loc":"proc/string_assign_integer_i4p.html"},{"title":"string_assign_integer_I8P – StringiFor","text":"private pure subroutine string_assign_integer_I8P(lhs, rhs) Assignment operator from integer input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I8P test_passed ( 1 ) = astring % to_number ( kind = 1_I8P ) == 127_I8P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_integer_i8p~~CallsGraph proc~string_assign_integer_i8p string%string_assign_integer_I8P str str proc~string_assign_integer_i8p->str Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine string_assign_integer_I8P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I8P !< test_passed(1) = astring%to_number(kind=1_I8P)==127_I8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I8P","tags":"","loc":"proc/string_assign_integer_i8p.html"},{"title":"string_assign_real_R4P – StringiFor","text":"private pure subroutine string_assign_real_R4P(lhs, rhs) Assignment operator from real input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R4P test_passed ( 1 ) = astring % to_number ( kind = 1._R4P ) == 3.021e6_R4P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_real_r4p~~CallsGraph proc~string_assign_real_r4p string%string_assign_real_R4P str str proc~string_assign_real_r4p->str Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine string_assign_real_R4P ( lhs , rhs ) !< Assignment operator from real input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 3.021e6_R4P !< test_passed(1) = astring%to_number(kind=1._R4P)==3.021e6_R4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R4P","tags":"","loc":"proc/string_assign_real_r4p.html"},{"title":"string_assign_real_R8P – StringiFor","text":"private pure subroutine string_assign_real_R8P(lhs, rhs) Assignment operator from real input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R8P test_passed ( 1 ) = astring % to_number ( kind = 1._R8P ) == 3.021e6_R8P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_real_r8p~~CallsGraph proc~string_assign_real_r8p string%string_assign_real_R8P str str proc~string_assign_real_r8p->str Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine string_assign_real_R8P ( lhs , rhs ) !< Assignment operator from real input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 3.021e6_R8P !< test_passed(1) = astring%to_number(kind=1._R8P)==3.021e6_R8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R8P","tags":"","loc":"proc/string_assign_real_r8p.html"},{"title":"string_assign_real_R16P – StringiFor","text":"private pure subroutine string_assign_real_R16P(lhs, rhs) Assignment operator from real input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R8P test_passed ( 1 ) = astring % to_number ( kind = 1._R8P ) == 3.021e6_R8P print '(L1)' , all ( test_passed ) Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_real_r16p~~CallsGraph proc~string_assign_real_r16p string%string_assign_real_R16P str str proc~string_assign_real_r16p->str Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine string_assign_real_R16P ( lhs , rhs ) !< Assignment operator from real input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 3.021e6_R8P !< test_passed(1) = astring%to_number(kind=1._R8P)==3.021e6_R8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R16P","tags":"","loc":"proc/string_assign_real_r16p.html"},{"title":"read_formatted – StringiFor","text":"private  subroutine read_formatted(dtv, unit, iotype, v_list, iostat, iomsg) Formatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Bug Read listdirected with and without delimiters does not work. Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Calls proc~~read_formatted~~CallsGraph proc~read_formatted string%read_formatted proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~read_formatted->proc~get_next_non_blank_character_any_record proc~read_delimited string%read_delimited proc~read_formatted->proc~read_delimited proc~read_undelimited_listdirected string%read_undelimited_listdirected proc~read_formatted->proc~read_undelimited_listdirected proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record proc~get_decimal_mode get_decimal_mode proc~read_undelimited_listdirected->proc~get_decimal_mode proc~read_undelimited string%read_undelimited proc~read_undelimited_listdirected->proc~read_undelimited Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !< !< @bug Read listdirected with and without delimiters does not work. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. character ( kind = CK , len = 1 ) :: delim !< String delimiter, if any. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. if ( iotype == 'LISTDIRECTED' ) then call get_next_non_blank_character_any_record ( unit = unit , ch = delim , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return if ( delim == '\"' . OR . delim == \"'\" ) then call dtv % read_delimited ( unit = unit , delim = delim , iostat = iostat , iomsg = local_iomsg ) else ! step back before the non-blank read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited_listdirected ( unit = unit , iostat = iostat , iomsg = local_iomsg ) endif if ( is_iostat_eor ( iostat )) then ! suppress IOSTAT_EOR iostat = 0 elseif ( iostat /= 0 ) then iomsg = local_iomsg endif return else read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endif endsubroutine read_formatted","tags":"","loc":"proc/read_formatted.html"},{"title":"read_delimited – StringiFor","text":"private  subroutine read_delimited(dtv, unit, delim, iostat, iomsg) Read a delimited string from a unit connected for formatted input. If the closing delimiter is followed by end of record, then we return end of record. Note This does not need a doctest, it being tested by [[string::read_formatted]]. Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK, len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. Called by proc~~read_delimited~~CalledByGraph proc~read_delimited string%read_delimited proc~read_formatted string%read_formatted proc~read_formatted->proc~read_delimited Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_delimited ( dtv , unit , delim , iostat , iomsg ) !< Read a delimited string from a unit connected for formatted input. !< !< If the closing delimiter is followed by end of record, then we return end of record. !< !< @note This does not need a doctest, it being tested by [[string::read_formatted]]. class ( string ), intent ( out ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( in ) :: delim !< String delimiter. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. logical :: was_delim !< Indicates that the last character read was a delimiter. was_delim = . false . dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then if ( was_delim ) then ! end of delimited string followed by end of record is end of the string. Pass back the ! end of record condition to the caller return else ! end of record without terminating delimiter - move along cycle endif elseif ( iostat /= 0 ) THEN return endif if ( ch == delim ) then if ( was_delim ) then ! doubled delimiter is one delimiter in the value dtv % raw = dtv % raw // ch was_delim = . false . else ! need to test next character to see what is happening was_delim = . true . endif elseif ( was_delim ) then ! the previous character was actually the delimiter for the end of the string. Put back this character read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) return else dtv % raw = dtv % raw // ch endif enddo endsubroutine read_delimited","tags":"","loc":"proc/read_delimited.html"},{"title":"read_undelimited_listdirected – StringiFor","text":"private  subroutine read_undelimited_listdirected(dtv, unit, iostat, iomsg) Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. If input is terminated by end of record, then this procedure returns an end-of-record condition. Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Calls proc~~read_undelimited_listdirected~~CallsGraph proc~read_undelimited_listdirected string%read_undelimited_listdirected proc~get_decimal_mode get_decimal_mode proc~read_undelimited_listdirected->proc~get_decimal_mode proc~read_undelimited string%read_undelimited proc~read_undelimited_listdirected->proc~read_undelimited Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_undelimited_listdirected~~CalledByGraph proc~read_undelimited_listdirected string%read_undelimited_listdirected proc~read_formatted string%read_formatted proc~read_formatted->proc~read_undelimited_listdirected Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_undelimited_listdirected ( dtv , unit , iostat , iomsg ) !< Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. !< !< A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. !< !< If input is terminated by end of record, then this procedure returns an end-of-record condition. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. logical :: decimal_point !<True if DECIMAL=POINT in effect. call get_decimal_mode ( unit = unit , decimal_point = decimal_point , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited ( unit = unit , terminators = ' ' // '/' // merge ( CK_ ',' , CK_ ';' , decimal_point ), iostat = iostat , iomsg = iomsg ) endsubroutine read_undelimited_listdirected","tags":"","loc":"proc/read_undelimited_listdirected.html"},{"title":"read_undelimited – StringiFor","text":"private  subroutine read_undelimited(dtv, unit, terminators, iostat, iomsg) Read an undelimited string up until end of record or a character from a set of terminators is encountered. If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the\nfile remains at end of record. Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK, len=*), intent(in) :: terminators Characters that are considered to terminate the string.\nBlanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Called by proc~~read_undelimited~~CalledByGraph proc~read_undelimited string%read_undelimited proc~read_undelimited_listdirected string%read_undelimited_listdirected proc~read_undelimited_listdirected->proc~read_undelimited proc~read_formatted string%read_formatted proc~read_formatted->proc~read_undelimited_listdirected Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_undelimited ( dtv , unit , terminators , iostat , iomsg ) !< Read an undelimited string up until end of record or a character from a set of terminators is encountered. !< !< If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the !< file remains at end of record. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: terminators !< Characters that are considered to terminate the string. !< Blanks in this string are meaningful. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then ! end of record just means end of string. We pass on the condition return elseif ( iostat /= 0 ) then ! something odd happened return endif if ( scan ( ch , terminators ) /= 0 ) then ! change the file position so that the next read sees the terminator read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return iostat = 0 return endif ! we got a character - append it dtv % raw = dtv % raw // ch enddo endsubroutine read_undelimited","tags":"","loc":"proc/read_undelimited.html"},{"title":"write_formatted – StringiFor","text":"private  subroutine write_formatted(dtv, unit, iotype, v_list, iostat, iomsg) Formatted output. Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK, len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. Source Code subroutine write_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !< Formatted output. class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif endsubroutine write_formatted","tags":"","loc":"proc/write_formatted.html"},{"title":"read_unformatted – StringiFor","text":"private  subroutine read_unformatted(dtv, unit, iostat, iomsg) Unformatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. Source Code subroutine read_unformatted ( dtv , unit , iostat , iomsg ) !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endsubroutine read_unformatted","tags":"","loc":"proc/read_unformatted.html"},{"title":"write_unformatted – StringiFor","text":"private  subroutine write_unformatted(dtv, unit, iostat, iomsg) Unformatted output. Type Bound string Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. Source Code subroutine write_unformatted ( dtv , unit , iostat , iomsg ) !< Unformatted output. class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif endsubroutine write_unformatted","tags":"","loc":"proc/write_unformatted.html"},{"title":"get_delimiter_mode – StringiFor","text":"private  subroutine get_delimiter_mode(unit, delim, iostat, iomsg) Uses iso_fortran_env proc~~get_delimiter_mode~~UsesGraph proc~get_delimiter_mode get_delimiter_mode iso_fortran_env iso_fortran_env proc~get_delimiter_mode->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Get the DELIM changeable connection mode for the given unit. If the unit is connected to an internal file, then the default value of NONE is always returned. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit The unit for the connection. character(kind=CK, len=1), intent(out) :: delim Represents the value of the DELIM mode. integer, intent(out) :: iostat IOSTAT error code, non-zero on error. character(len=*), intent(inout) :: iomsg IOMSG explanatory message - only defined if iostat is non-zero. Source Code subroutine get_delimiter_mode ( unit , delim , iostat , iomsg ) !< Get the DELIM changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of NONE is always returned. use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit integer , intent ( in ) :: unit !< The unit for the connection. character ( len = 1 , kind = CK ), intent ( out ) :: delim !< Represents the value of the DELIM mode. integer , intent ( out ) :: iostat !< IOSTAT error code, non-zero on error. character ( * ), intent ( inout ) :: iomsg !< IOMSG explanatory message - only defined if iostat is non-zero. character ( 10 ) :: delim_buffer !< Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. ! get the string representation of the changeable mode inquire ( unit , delim = delim_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the DELIM mode for an internal file iostat = 0 delim = '' return elseif ( iostat /= 0 ) then iomsg = local_iomsg return endif ! interpret the DELIM string if ( delim_buffer == 'QUOTE' ) then delim = '\"' elseif ( delim_buffer == 'APOSTROPHE' ) then delim = '''' else delim = '\"' endif endsubroutine get_delimiter_mode","tags":"","loc":"proc/get_delimiter_mode.html"},{"title":"get_next_non_blank_character_this_record – StringiFor","text":"private  subroutine get_next_non_blank_character_this_record(unit, ch, iostat, iomsg) Get the next non-blank character in the current record. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK, len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. Called by proc~~get_next_non_blank_character_this_record~~CalledByGraph proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record proc~read_formatted string%read_formatted proc~read_formatted->proc~get_next_non_blank_character_any_record Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_next_non_blank_character_this_record ( unit , ch , iostat , iomsg ) !< Get the next non-blank character in the current record. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. do ! we spcify non-advancing, just in case we want this callable outside the context of a child input statement ! the PAD specifier simply saves the need for the READ statement to define ch if EOR is hit ! read(unit, \"(A)\", iostat=iostat, iomsg=iomsg, advance='NO') ch ! ...but that causes ifort to blow up at runtime read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg , pad = 'NO' ) ch if ( iostat /= 0 ) return if ( ch /= '' ) exit enddo endsubroutine get_next_non_blank_character_this_record","tags":"","loc":"proc/get_next_non_blank_character_this_record.html"},{"title":"get_next_non_blank_character_any_record – StringiFor","text":"private  subroutine get_next_non_blank_character_any_record(unit, ch, iostat, iomsg) Get the next non-blank character, advancing records if necessary. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK, len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. Calls proc~~get_next_non_blank_character_any_record~~CallsGraph proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_next_non_blank_character_any_record~~CalledByGraph proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~read_formatted string%read_formatted proc~read_formatted->proc~get_next_non_blank_character_any_record Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_next_non_blank_character_any_record ( unit , ch , iostat , iomsg ) !< Get the next non-blank character, advancing records if necessary. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. do call get_next_non_blank_character_this_record ( unit = unit , ch = ch , iostat = iostat , iomsg = local_iomsg ) if ( is_iostat_eor ( iostat )) then ! try again on the next record read ( unit , \"(/)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return elseif ( iostat /= 0 ) then ! some sort of problem iomsg = local_iomsg return else ! got it exit endif enddo endsubroutine get_next_non_blank_character_any_record","tags":"","loc":"proc/get_next_non_blank_character_any_record.html"},{"title":"get_decimal_mode – StringiFor","text":"private  subroutine get_decimal_mode(unit, decimal_point, iostat, iomsg) Uses iso_fortran_env proc~~get_decimal_mode~~UsesGraph proc~get_decimal_mode get_decimal_mode iso_fortran_env iso_fortran_env proc~get_decimal_mode->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Get the DECIMAL changeable connection mode for the given unit. If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the\nactual value in force at the time of the call to this procedure. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. logical, intent(out) :: decimal_point True if the decimal mode is POINT, false otherwise. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. Called by proc~~get_decimal_mode~~CalledByGraph proc~get_decimal_mode get_decimal_mode proc~read_undelimited_listdirected string%read_undelimited_listdirected proc~read_undelimited_listdirected->proc~get_decimal_mode proc~read_formatted string%read_formatted proc~read_formatted->proc~read_undelimited_listdirected Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_decimal_mode ( unit , decimal_point , iostat , iomsg ) !< Get the DECIMAL changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the !< actual value in force at the time of the call to this procedure. use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit integer , intent ( in ) :: unit !< Logical unit. logical , intent ( out ) :: decimal_point !< True if the decimal mode is POINT, false otherwise. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( 5 ) :: decimal_buffer !< Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character ( len ( iomsg )) :: local_iomsg !< Local iomsg, so it doesn't get inappropriately redefined. inquire ( unit , decimal = decimal_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the decimal mode for an internal file iostat = 0 decimal_point = . true . return else if ( iostat /= 0 ) then iomsg = local_iomsg return endif decimal_point = decimal_buffer == 'POINT' endsubroutine get_decimal_mode","tags":"","loc":"proc/get_decimal_mode.html"},{"title":"glob – StringiFor","text":"public interface glob Overloading glob procedure. type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call glob ( self = astring , pattern = 'foo-*' , list = alist_chr ) call glob ( self = astring , pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr if ( test_passed ) then test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str endif print '(L1)' , test_passed Calls interface~~glob~~CallsGraph interface~glob glob proc~glob_character string%glob_character interface~glob->proc~glob_character proc~glob_string string%glob_string interface~glob->proc~glob_string none~glob string%glob proc~glob_character->none~glob proc~chars string%chars proc~glob_character->proc~chars proc~read_file~2 string%read_file proc~glob_string->proc~read_file~2 proc~split string%split proc~glob_string->proc~split proc~tempname string%tempname proc~glob_string->proc~tempname none~glob->proc~glob_character none~glob->proc~glob_string proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~upper string%upper proc~read_file~2->proc~upper proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~replace string%replace proc~unique->proc~replace proc~read_line->proc~chars proc~read_line->proc~upper proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~glob~~CalledByGraph interface~glob glob program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->interface~glob Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine glob_character (self, pattern, list) Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: pattern Given pattern. character(len=:), intent(out), allocatable :: list (:) List of matching pathnames. private  subroutine glob_string (self, pattern, list) Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: pattern Given pattern. type( string ), intent(out), allocatable :: list (:) List of matching pathnames.","tags":"","loc":"interface/glob.html"},{"title":"strjoin – StringiFor","text":"public interface strjoin Calls interface~~strjoin~~CallsGraph interface~strjoin strjoin proc~strjoin_characters string%strjoin_characters interface~strjoin->proc~strjoin_characters proc~strjoin_characters_array string%strjoin_characters_array interface~strjoin->proc~strjoin_characters_array proc~strjoin_strings string%strjoin_strings interface~strjoin->proc~strjoin_strings proc~strjoin_strings_array string%strjoin_strings_array interface~strjoin->proc~strjoin_strings_array proc~strjoin_characters_array->proc~strjoin_characters proc~strjoin_strings_array->proc~strjoin_strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function strjoin_strings (array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function strjoin_characters (array, sep, is_trim) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not Return Value type( string ) The join of array. private pure function strjoin_strings_array (array, sep, is_col) result(join) Return a string that is a join of columns or rows of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ), allocatable, (:) The join of array. private pure function strjoin_characters_array (array, sep, is_trim, is_col) result(join) Return a string that is a join of columns or rows of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ), allocatable, (:) The join of array.","tags":"","loc":"interface/strjoin.html"},{"title":"adjustl – StringiFor","text":"public interface adjustl Builtin adjustl overloading. Calls interface~~adjustl~~CallsGraph interface~adjustl adjustl proc~sadjustl_character sadjustl_character interface~adjustl->proc~sadjustl_character Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function sadjustl_character (s) result(adjusted) Left adjust a string by removing leading spaces (character output). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK, len=:), allocatable Adjusted string.","tags":"","loc":"interface/adjustl.html"},{"title":"adjustr – StringiFor","text":"public interface adjustr Builtin adjustr overloading. Calls interface~~adjustr~~CallsGraph interface~adjustr adjustr proc~sadjustr_character sadjustr_character interface~adjustr->proc~sadjustr_character Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function sadjustr_character (s) result(adjusted) Right adjust a string by removing leading spaces (character output). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK, len=:), allocatable Adjusted string.","tags":"","loc":"interface/adjustr.html"},{"title":"count – StringiFor","text":"public interface count Builtin count overloading. Calls interface~~count~~CallsGraph interface~count count proc~count_substring count_substring interface~count->proc~count_substring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function count_substring (s, substring) result(No) Count the number of occurences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences.","tags":"","loc":"interface/count.html"},{"title":"index – StringiFor","text":"public interface index Builtin index overloading. Calls interface~~index~~CallsGraph interface~index index proc~sindex_character_string sindex_character_string interface~index->proc~sindex_character_string proc~sindex_string_character string%sindex_string_character interface~index->proc~sindex_string_character proc~sindex_string_string string%sindex_string_string interface~index->proc~sindex_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function sindex_string_string (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sindex_string_character (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sindex_character_string (s, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: s String. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search.","tags":"","loc":"interface/index.html"},{"title":"len_trim – StringiFor","text":"public interface len_trim Builtin len_trim overloading. Calls interface~~len_trim~~CallsGraph interface~len_trim len_trim proc~slen_trim string%slen_trim interface~len_trim->proc~slen_trim Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function slen_trim (self) result(l) Return the length of a string, ignoring any trailing blanks. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length.","tags":"","loc":"interface/len_trim.html"},{"title":"repeat – StringiFor","text":"public interface repeat Builtin repeat overloading. Calls interface~~repeat~~CallsGraph interface~repeat repeat proc~srepeat_string_string string%srepeat_string_string interface~repeat->proc~srepeat_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function srepeat_string_string (self, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string.","tags":"","loc":"interface/repeat.html"},{"title":"scan – StringiFor","text":"public interface scan Builtin scan overloading. Calls interface~~scan~~CallsGraph interface~scan scan proc~sscan_character_string sscan_character_string interface~scan->proc~sscan_character_string proc~sscan_string_character string%sscan_string_character interface~scan->proc~sscan_string_character proc~sscan_string_string string%sscan_string_string interface~scan->proc~sscan_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function sscan_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_character_string (s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search.","tags":"","loc":"interface/scan.html"},{"title":"trim – StringiFor","text":"public interface trim Builtin trim overloading. Calls interface~~trim~~CallsGraph interface~trim trim proc~strim string%strim interface~trim->proc~strim Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strim (self) result(trimmed) Remove trailing spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string.","tags":"","loc":"interface/trim.html"},{"title":"verify – StringiFor","text":"public interface verify Builtin verify overloading. Calls interface~~verify~~CallsGraph interface~verify verify proc~sverify_character_string sverify_character_string interface~verify->proc~sverify_character_string proc~sverify_string_character string%sverify_string_character interface~verify->proc~sverify_string_character proc~sverify_string_string string%sverify_string_string interface~verify->proc~sverify_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function sverify_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_character_string (s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search.","tags":"","loc":"interface/verify.html"},{"title":"stringifor – StringiFor","text":"StringiFor, Strings Fortran Manipulator with steroids. Uses stringifor_string_t penf module~~stringifor~~UsesGraph module~stringifor stringifor module~stringifor_string_t stringifor_string_t module~stringifor->module~stringifor_string_t penf penf module~stringifor->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~stringifor~~UsedByGraph module~stringifor stringifor program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->module~stringifor program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->module~stringifor program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->module~stringifor program~volatile_doctest~54 volatile_doctest program~volatile_doctest~54->module~stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine read_file (file, lines, form, iostat, iomsg) Read a file as a single string stream. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. public  subroutine read_lines (unit, lines, form, iostat, iomsg) Read lines (records) from a connected-formatted unit. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. public  subroutine write_file (file, lines, form, iostat, iomsg) Write a single string stream into file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. public  subroutine write_lines (unit, lines, form, iostat, iomsg) Write lines (records) to a connected-formatted unit. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message.","tags":"","loc":"module/stringifor.html"},{"title":"stringifor_string_t – StringiFor","text":"StringiFor, definition of string type. Uses penf iso_fortran_env befor64 face module~~stringifor_string_t~~UsesGraph module~stringifor_string_t stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~stringifor_string_t~~UsedByGraph module~stringifor_string_t stringifor_string_t module~stringifor stringifor module~stringifor->module~stringifor_string_t program~volatile_doctest volatile_doctest program~volatile_doctest->module~stringifor_string_t program~volatile_doctest~10 volatile_doctest program~volatile_doctest~10->module~stringifor_string_t program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->module~stringifor_string_t program~volatile_doctest~101 volatile_doctest program~volatile_doctest~101->module~stringifor_string_t program~volatile_doctest~102 volatile_doctest program~volatile_doctest~102->module~stringifor_string_t program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->module~stringifor_string_t program~volatile_doctest~104 volatile_doctest program~volatile_doctest~104->module~stringifor_string_t program~volatile_doctest~105 volatile_doctest program~volatile_doctest~105->module~stringifor_string_t program~volatile_doctest~106 volatile_doctest program~volatile_doctest~106->module~stringifor_string_t program~volatile_doctest~107 volatile_doctest program~volatile_doctest~107->module~stringifor_string_t program~volatile_doctest~108 volatile_doctest program~volatile_doctest~108->module~stringifor_string_t program~volatile_doctest~109 volatile_doctest program~volatile_doctest~109->module~stringifor_string_t program~volatile_doctest~11 volatile_doctest program~volatile_doctest~11->module~stringifor_string_t program~volatile_doctest~110 volatile_doctest program~volatile_doctest~110->module~stringifor_string_t program~volatile_doctest~111 volatile_doctest program~volatile_doctest~111->module~stringifor_string_t program~volatile_doctest~12 volatile_doctest program~volatile_doctest~12->module~stringifor_string_t program~volatile_doctest~13 volatile_doctest program~volatile_doctest~13->module~stringifor_string_t program~volatile_doctest~14 volatile_doctest program~volatile_doctest~14->module~stringifor_string_t program~volatile_doctest~15 volatile_doctest program~volatile_doctest~15->module~stringifor_string_t program~volatile_doctest~16 volatile_doctest program~volatile_doctest~16->module~stringifor_string_t program~volatile_doctest~18 volatile_doctest program~volatile_doctest~18->module~stringifor_string_t program~volatile_doctest~19 volatile_doctest program~volatile_doctest~19->module~stringifor_string_t program~volatile_doctest~2 volatile_doctest program~volatile_doctest~2->module~stringifor_string_t program~volatile_doctest~20 volatile_doctest program~volatile_doctest~20->module~stringifor_string_t program~volatile_doctest~21 volatile_doctest program~volatile_doctest~21->module~stringifor_string_t program~volatile_doctest~22 volatile_doctest program~volatile_doctest~22->module~stringifor_string_t program~volatile_doctest~23 volatile_doctest program~volatile_doctest~23->module~stringifor_string_t program~volatile_doctest~24 volatile_doctest program~volatile_doctest~24->module~stringifor_string_t program~volatile_doctest~25 volatile_doctest program~volatile_doctest~25->module~stringifor_string_t program~volatile_doctest~26 volatile_doctest program~volatile_doctest~26->module~stringifor_string_t program~volatile_doctest~27 volatile_doctest program~volatile_doctest~27->module~stringifor_string_t program~volatile_doctest~28 volatile_doctest program~volatile_doctest~28->module~stringifor_string_t program~volatile_doctest~29 volatile_doctest program~volatile_doctest~29->module~stringifor_string_t program~volatile_doctest~3 volatile_doctest program~volatile_doctest~3->module~stringifor_string_t program~volatile_doctest~30 volatile_doctest program~volatile_doctest~30->module~stringifor_string_t program~volatile_doctest~31 volatile_doctest program~volatile_doctest~31->module~stringifor_string_t program~volatile_doctest~32 volatile_doctest program~volatile_doctest~32->module~stringifor_string_t program~volatile_doctest~33 volatile_doctest program~volatile_doctest~33->module~stringifor_string_t program~volatile_doctest~34 volatile_doctest program~volatile_doctest~34->module~stringifor_string_t program~volatile_doctest~35 volatile_doctest program~volatile_doctest~35->module~stringifor_string_t program~volatile_doctest~36 volatile_doctest program~volatile_doctest~36->module~stringifor_string_t program~volatile_doctest~37 volatile_doctest program~volatile_doctest~37->module~stringifor_string_t program~volatile_doctest~38 volatile_doctest program~volatile_doctest~38->module~stringifor_string_t program~volatile_doctest~39 volatile_doctest program~volatile_doctest~39->module~stringifor_string_t program~volatile_doctest~4 volatile_doctest program~volatile_doctest~4->module~stringifor_string_t program~volatile_doctest~40 volatile_doctest program~volatile_doctest~40->module~stringifor_string_t program~volatile_doctest~41 volatile_doctest program~volatile_doctest~41->module~stringifor_string_t program~volatile_doctest~42 volatile_doctest program~volatile_doctest~42->module~stringifor_string_t program~volatile_doctest~43 volatile_doctest program~volatile_doctest~43->module~stringifor_string_t program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->module~stringifor_string_t program~volatile_doctest~45 volatile_doctest program~volatile_doctest~45->module~stringifor_string_t program~volatile_doctest~46 volatile_doctest program~volatile_doctest~46->module~stringifor_string_t program~volatile_doctest~47 volatile_doctest program~volatile_doctest~47->module~stringifor_string_t program~volatile_doctest~48 volatile_doctest program~volatile_doctest~48->module~stringifor_string_t program~volatile_doctest~49 volatile_doctest program~volatile_doctest~49->module~stringifor_string_t program~volatile_doctest~5 volatile_doctest program~volatile_doctest~5->module~stringifor_string_t program~volatile_doctest~50 volatile_doctest program~volatile_doctest~50->module~stringifor_string_t program~volatile_doctest~51 volatile_doctest program~volatile_doctest~51->module~stringifor_string_t program~volatile_doctest~52 volatile_doctest program~volatile_doctest~52->module~stringifor_string_t program~volatile_doctest~53 volatile_doctest program~volatile_doctest~53->module~stringifor_string_t program~volatile_doctest~55 volatile_doctest program~volatile_doctest~55->module~stringifor_string_t program~volatile_doctest~56 volatile_doctest program~volatile_doctest~56->module~stringifor_string_t program~volatile_doctest~57 volatile_doctest program~volatile_doctest~57->module~stringifor_string_t program~volatile_doctest~58 volatile_doctest program~volatile_doctest~58->module~stringifor_string_t program~volatile_doctest~59 volatile_doctest program~volatile_doctest~59->module~stringifor_string_t program~volatile_doctest~6 volatile_doctest program~volatile_doctest~6->module~stringifor_string_t program~volatile_doctest~60 volatile_doctest program~volatile_doctest~60->module~stringifor_string_t program~volatile_doctest~61 volatile_doctest program~volatile_doctest~61->module~stringifor_string_t program~volatile_doctest~62 volatile_doctest program~volatile_doctest~62->module~stringifor_string_t program~volatile_doctest~63 volatile_doctest program~volatile_doctest~63->module~stringifor_string_t program~volatile_doctest~64 volatile_doctest program~volatile_doctest~64->module~stringifor_string_t program~volatile_doctest~65 volatile_doctest program~volatile_doctest~65->module~stringifor_string_t program~volatile_doctest~66 volatile_doctest program~volatile_doctest~66->module~stringifor_string_t program~volatile_doctest~67 volatile_doctest program~volatile_doctest~67->module~stringifor_string_t program~volatile_doctest~68 volatile_doctest program~volatile_doctest~68->module~stringifor_string_t program~volatile_doctest~69 volatile_doctest program~volatile_doctest~69->module~stringifor_string_t program~volatile_doctest~7 volatile_doctest program~volatile_doctest~7->module~stringifor_string_t program~volatile_doctest~70 volatile_doctest program~volatile_doctest~70->module~stringifor_string_t program~volatile_doctest~71 volatile_doctest program~volatile_doctest~71->module~stringifor_string_t program~volatile_doctest~72 volatile_doctest program~volatile_doctest~72->module~stringifor_string_t program~volatile_doctest~73 volatile_doctest program~volatile_doctest~73->module~stringifor_string_t program~volatile_doctest~74 volatile_doctest program~volatile_doctest~74->module~stringifor_string_t program~volatile_doctest~75 volatile_doctest program~volatile_doctest~75->module~stringifor_string_t program~volatile_doctest~76 volatile_doctest program~volatile_doctest~76->module~stringifor_string_t program~volatile_doctest~77 volatile_doctest program~volatile_doctest~77->module~stringifor_string_t program~volatile_doctest~78 volatile_doctest program~volatile_doctest~78->module~stringifor_string_t program~volatile_doctest~79 volatile_doctest program~volatile_doctest~79->module~stringifor_string_t program~volatile_doctest~8 volatile_doctest program~volatile_doctest~8->module~stringifor_string_t program~volatile_doctest~80 volatile_doctest program~volatile_doctest~80->module~stringifor_string_t program~volatile_doctest~81 volatile_doctest program~volatile_doctest~81->module~stringifor_string_t program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->module~stringifor_string_t program~volatile_doctest~83 volatile_doctest program~volatile_doctest~83->module~stringifor_string_t program~volatile_doctest~84 volatile_doctest program~volatile_doctest~84->module~stringifor_string_t program~volatile_doctest~85 volatile_doctest program~volatile_doctest~85->module~stringifor_string_t program~volatile_doctest~86 volatile_doctest program~volatile_doctest~86->module~stringifor_string_t program~volatile_doctest~87 volatile_doctest program~volatile_doctest~87->module~stringifor_string_t program~volatile_doctest~88 volatile_doctest program~volatile_doctest~88->module~stringifor_string_t program~volatile_doctest~89 volatile_doctest program~volatile_doctest~89->module~stringifor_string_t program~volatile_doctest~9 volatile_doctest program~volatile_doctest~9->module~stringifor_string_t program~volatile_doctest~90 volatile_doctest program~volatile_doctest~90->module~stringifor_string_t program~volatile_doctest~91 volatile_doctest program~volatile_doctest~91->module~stringifor_string_t program~volatile_doctest~92 volatile_doctest program~volatile_doctest~92->module~stringifor_string_t program~volatile_doctest~93 volatile_doctest program~volatile_doctest~93->module~stringifor_string_t program~volatile_doctest~94 volatile_doctest program~volatile_doctest~94->module~stringifor_string_t program~volatile_doctest~95 volatile_doctest program~volatile_doctest~95->module~stringifor_string_t program~volatile_doctest~96 volatile_doctest program~volatile_doctest~96->module~stringifor_string_t program~volatile_doctest~97 volatile_doctest program~volatile_doctest~97->module~stringifor_string_t program~volatile_doctest~98 volatile_doctest program~volatile_doctest~98->module~stringifor_string_t program~volatile_doctest~99 volatile_doctest program~volatile_doctest~99->module~stringifor_string_t program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->module~stringifor program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->module~stringifor program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->module~stringifor program~volatile_doctest~54 volatile_doctest program~volatile_doctest~54->module~stringifor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: CK = selected_char_kind('DEFAULT') Default character kind. character(kind=CK, len=26), private, parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(kind=CK, len=26), private, parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. character(kind=CK, len=1), private, parameter :: SPACE = ' ' Space character. character(kind=CK, len=1), private, parameter :: TAB = achar(9) Tab character. character(kind=CK, len=1), private, parameter :: UIX_DIR_SEP = char(47) Unix/Linux directories separator (/). character(kind=CK, len=1), private, parameter :: BACKSLASH = char(92) Backslash character. Interfaces public        interface glob Overloading glob procedure. type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call glob ( self = astring , pattern = 'foo-*' , list = alist_chr ) call glob ( self = astring , pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr if ( test_passed ) then test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str endif print '(L1)' , test_passed private  subroutine glob_character (self, pattern, list) Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. @note Note\n      Method not portable: works only on Unix/GNU Linux OS. type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_chr ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr print '(L1)' , test_passed Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: pattern Given pattern. character(len=:), intent(out), allocatable :: list (:) List of matching pathnames. private  subroutine glob_string (self, pattern, list) Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. @note Note\n      Method not portable: works only on Unix/GNU Linux OS. type ( string ) :: astring type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str print '(L1)' , test_passed Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: pattern Given pattern. type( string ), intent(out), allocatable :: list (:) List of matching pathnames. public        interface strjoin private pure function strjoin_strings (array, sep) result(join) Return a string that is a join of an array of strings. The join-separator is set equals to a null string ‘’ if custom separator isn’t specified. type ( string ) :: strings ( 3 ) logical :: test_passed ( 5 ) strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 1 ) = ( strjoin ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) test_passed ( 2 ) = ( strjoin ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 3 ) = ( strjoin ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free test_passed ( 4 ) = ( strjoin ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' test_passed ( 5 ) = ( strjoin ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function strjoin_characters (array, sep, is_trim) result(join) Return a string that is a join of an array of characters. The join-separator is set equals to a null string ‘’ if custom separator isn’t specified.\n The trim function is applied to array items if optional logical is_trim variable isn’t set to .false. character ( 5 ) :: characters ( 3 ) logical :: test_passed ( 13 ) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 1 ) = ( strjoin ( array = characters ) // '' == trim ( characters ( 1 )) // trim ( characters ( 2 )) // trim ( characters ( 3 ))) test_passed ( 2 ) = ( strjoin ( array = characters , sep = '-' ) // '' == trim ( characters ( 1 )) // '-' // trim ( characters ( 2 )) // '-' // trim ( characters ( 3 ))) test_passed ( 3 ) = ( strjoin ( array = characters , is_trim = . false .) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) test_passed ( 4 ) = ( strjoin ( array = characters , sep = '-' , is_trim = . false .) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 5 ) = ( strjoin ( array = characters ) // '' == trim ( characters ( 2 )) // trim ( characters ( 3 ))) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 6 ) = ( strjoin ( array = characters ) // '' == trim ( characters ( 1 )) // trim ( characters ( 2 ))) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 7 ) = ( strjoin ( array = characters ) // '' == trim ( characters ( 1 )) // trim ( characters ( 3 ))) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 8 ) = ( strjoin ( array = characters , sep = '-' ) // '' == trim ( characters ( 2 )) // '-' // trim ( characters ( 3 ))) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 9 ) = ( strjoin ( array = characters , sep = '-' ) // '' == trim ( characters ( 1 )) // '-' // trim ( characters ( 2 ))) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 10 ) = ( strjoin ( array = characters , sep = '-' ) // '' == trim ( characters ( 1 )) // '-' // trim ( characters ( 3 ))) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 11 ) = ( strjoin ( array = characters , sep = '-' , is_trim = . false .) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 12 ) = ( strjoin ( array = characters , sep = '-' , is_trim = . false .) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 13 ) = ( strjoin ( array = characters , sep = '-' , is_trim = . false .) // '' == characters ( 1 ) // '-' // characters ( 3 )) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not Return Value type( string ) The join of array. private pure function strjoin_strings_array (array, sep, is_col) result(join) Return a string that is a join of columns or rows of an array of strings. The join-separator is set equals to a null string ‘’ if custom separator isn’t specified.\n The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). type ( string ), allocatable :: strings_arr (:, :) logical :: test_passed ( 5 ) strings_arr = reshape ( source = & [ string ( 'one' ), string ( 'two' ), string ( 'three' ), & string ( 'ONE' ), string ( 'TWO' ), string ( 'THREE' )], & shape = [ 3 , 2 ] ) test_passed ( 1 ) = all ( strjoin ( array = strings_arr ) == & reshape ([ string ( 'onetwothree' ), string ( 'ONETWOTHREE' )], & shape = [ 2 ]) ) test_passed ( 2 ) = all ( strjoin ( array = strings_arr , sep = '_' ) == & reshape ([ string ( 'one_two_three' ), string ( 'ONE_TWO_THREE' )], & shape = [ 2 ]) ) test_passed ( 3 ) = all ( strjoin ( array = strings_arr , is_col = . false .) == & reshape ([ string ( 'oneONE' ), string ( 'twoTWO' ), string ( 'threeTHREE' )], & shape = [ 3 ]) ) test_passed ( 4 ) = all ( strjoin ( array = strings_arr , sep = '_' , is_col = . false .) == & reshape ([ string ( 'one_ONE' ), string ( 'two_TWO' ), string ( 'three_THREE' )], & shape = [ 3 ]) ) call strings_arr ( 2 , 1 )% free test_passed ( 5 ) = all ( strjoin ( array = strings_arr , sep = '_' , is_col = . false .) == & reshape ([ string ( 'one_ONE' ), string ( 'TWO' ), string ( 'three_THREE' )], & shape = [ 3 ]) ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ), allocatable, (:) The join of array. private pure function strjoin_characters_array (array, sep, is_trim, is_col) result(join) Return a string that is a join of columns or rows of an array of characters. The join-separator is set equals to a null string ‘’ if custom separator isn’t specified.\n The trim function is applied to array items if optional logical is_trim variable isn’t set to .false.\n The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). character ( len = 10 ) :: chars_arr ( 3 , 2 ) logical :: test_passed ( 9 ) chars_arr (:, 1 ) = [ 'one       ' , 'two       ' , 'three     ' ] chars_arr (:, 2 ) = [ 'ONE       ' , 'TWO       ' , 'THREE     ' ] test_passed ( 1 ) = all ( strjoin ( array = chars_arr ) == & reshape ([ string ( 'onetwothree' ), string ( 'ONETWOTHREE' )], & shape = [ 2 ]) ) test_passed ( 2 ) = all ( strjoin ( array = chars_arr , is_trim = . false .) == & reshape ([ string ( 'one       two       three     ' ), & string ( 'ONE       TWO       THREE     ' )], & shape = [ 2 ]) ) test_passed ( 3 ) = all ( strjoin ( array = chars_arr , sep = '_' ) == & reshape ([ string ( 'one_two_three' ), string ( 'ONE_TWO_THREE' )], & shape = [ 2 ]) ) test_passed ( 4 ) = all ( strjoin ( array = chars_arr , sep = '_' , is_trim = . false .) == & reshape ([ string ( 'one       _two       _three     ' ), & string ( 'ONE       _TWO       _THREE     ' )], & shape = [ 2 ]) ) test_passed ( 5 ) = all ( strjoin ( array = chars_arr , is_col = . false .) == & reshape ([ string ( 'oneONE' ), string ( 'twoTWO' ), string ( 'threeTHREE' )], & shape = [ 3 ]) ) test_passed ( 6 ) = all ( strjoin ( array = chars_arr , is_trim = . false ., is_col = . false .) == & reshape ([ string ( 'one       ONE       ' ), & string ( 'two       TWO       ' ), & string ( 'three     THREE     ' )], & shape = [ 3 ]) ) test_passed ( 7 ) = all ( strjoin ( array = chars_arr , sep = '_' , is_col = . false .) == & reshape ([ string ( 'one_ONE' ), string ( 'two_TWO' ), string ( 'three_THREE' )], & shape = [ 3 ]) ) test_passed ( 8 ) = all ( strjoin ( array = chars_arr , sep = '_' , is_trim = . false ., is_col = . false .) == & reshape ([ string ( 'one       _ONE       ' ), & string ( 'two       _TWO       ' ), & string ( 'three     _THREE     ' )], & shape = [ 3 ]) ) chars_arr ( 2 , 1 ) = '' test_passed ( 9 ) = all ( strjoin ( array = chars_arr , sep = '_' , is_col = . false .) == & reshape ([ string ( 'one_ONE' ), & string ( 'TWO' ), & string ( 'three_THREE' )], & shape = [ 3 ]) ) print '(L1)' , all ( test_passed ) all items of character array have equal lengths Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ), allocatable, (:) The join of array. public        interface adjustl Builtin adjustl overloading. private pure function sadjustl_character (s) result(adjusted) Left adjust a string by removing leading spaces (character output). type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , adjustl ( astring ) == 'Hello World!   ' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK, len=:), allocatable Adjusted string. public        interface adjustr Builtin adjustr overloading. private pure function sadjustr_character (s) result(adjusted) Right adjust a string by removing leading spaces (character output). type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , adjustr ( astring ) == '   Hello World!' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK, len=:), allocatable Adjusted string. public        interface count Builtin count overloading. private elemental function count_substring (s, substring) result(No) Count the number of occurences of a substring into a string. print \"(L1)\" , count ( 'hello' , substring = 'll' ) == 1 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. public        interface index Builtin index overloading. private elemental function sindex_string_string (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % index ( substring = string2 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = string2 , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sindex_string_character (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % index ( substring = 'llo' ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = 'llo' , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sindex_character_string (s, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = index ( s = 'Hello World Hello!' , substring = string1 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = index ( s = 'Hello World Hello!' , substring = string1 , back = . true .) == index ( string = 'Hello World Hello!' , & substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: s String. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. public        interface len_trim Builtin len_trim overloading. private elemental function slen_trim (self) result(l) Return the length of a string, ignoring any trailing blanks. type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len_trim () == len_trim ( 'Hello World!   ' ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. public        interface repeat Builtin repeat overloading. private elemental function srepeat_string_string (self, ncopies) result(repeated) Concatenates several copies of an input string. type ( string ) :: astring astring = 'x' print \"(L1)\" , astring % repeat ( 5 ) // '' == 'xxxxx' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. public        interface scan Builtin scan overloading. private elemental function sscan_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % scan ( set = string2 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = string2 , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % scan ( set = 'llo' ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = 'llo' , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_character_string (s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = scan ( s = 'Hello World Hello!' , set = string1 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = scan ( s = 'Hello World Hello!' , set = string1 , back = . true .) == scan ( string = 'Hello World Hello!' , & set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. public        interface trim Builtin trim overloading. private elemental function strim (self) result(trimmed) Remove trailing spaces. type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % trim () == trim ( 'Hello World!   ' ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. public        interface verify Builtin verify overloading. private elemental function sverify_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % verify ( set = string2 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = string2 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % verify ( set = 'llo' ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = 'llo' , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_character_string (s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'ell' test_passed ( 1 ) = verify ( s = 'Hello World Hello!' , set = string1 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = verify ( s = 'Hello World Hello!' , set = string1 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Derived Types type, public :: string OOP designed string class. Components Type Visibility Attributes Name Initial character(kind=CK, len=:), public, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: adjustl => sadjustl ../../../../ Adjustl replacement. procedure, public, pass(self) :: adjustr => sadjustr ../../../../ Adjustr replacement. procedure, public, pass(self) :: count => scount ../../../../ Count replacement. generic, public :: index => sindex_string_string , sindex_string_character ../../../../ Index replacement. procedure, public, pass(self) :: len => slen ../../../../ Len replacement. procedure, public, pass(self) :: len_trim => slen_trim ../../../../ Len_trim replacement. generic, public :: repeat => srepeat_string_string , srepeat_character_string ../../../../ Repeat replacement. generic, public :: scan => sscan_string_string , sscan_string_character ../../../../ Scan replacement. procedure, public, pass(self) :: trim => strim ../../../../ Trim replacement. generic, public :: verify => sverify_string_string , sverify_string_character ../../../../ Verify replacement. procedure, public, pass(self) :: basedir ../../../../ Return the base directory name of a string containing a file name. procedure, public, pass(self) :: basename ../../../../ Return the base file name of a string containing a file name. procedure, public, pass(self) :: camelcase ../../../../ Return a string with all words capitalized without spaces. procedure, public, pass(self) :: capitalize ../../../../ Return a string with its first character capitalized and the rest lowercased. procedure, public, pass(self) :: chars ../../../../ Return the raw characters data. generic, public :: colorize => colorize_str ../../../../ Colorize and stylize strings. procedure, public, pass(self) :: decode ../../../../ Decode string. procedure, public, pass(self) :: encode ../../../../ Encode string. procedure, public, pass(self) :: escape ../../../../ Escape backslashes (or custom escape character). procedure, public, pass(self) :: extension ../../../../ Return the extension of a string containing a file name. procedure, public, pass(self) :: fill ../../../../ Pad string on the left (or right) with zeros (or other char) to fill width. procedure, public, pass(self) :: free ../../../../ Free dynamic memory. generic, public :: glob => glob_character , glob_string ../../../../ Glob search, finds all the pathnames matching a given pattern. generic, public :: insert => insert_string , insert_character ../../../../ Insert substring into string at a specified position. generic, public :: join => join_strings , join_characters ../../../../ Return a string that is a join of an array of strings or characters. generic, public :: strjoin => strjoin_strings , strjoin_characters , strjoin_strings_array , strjoin_characters_array ../../../../ Return a string that is a join of an array of strings or characters;\nReturn join 1D string array of an 2D array of strings or characters in columns or rows. procedure, public, pass(self) :: lower ../../../../ Return a string with all lowercase characters. procedure, public, pass(self) :: partition ../../../../ Split string at separator and return the 3 parts (before, the separator and after). procedure, public, pass(self) :: read_file ../../../../ Read a file a single string stream. procedure, public, pass(self) :: read_line ../../../../ Read line (record) from a connected unit. procedure, public, pass(self) :: read_lines ../../../../ Read (all) lines (records) from a connected unit as a single ascii stream. procedure, public, pass(self) :: replace ../../../../ Return a string with all occurrences of substring old replaced by new. procedure, public, pass(self) :: reverse ../../../../ Return a reversed string. procedure, public, pass(self) :: search ../../../../ Search for tagged record into string. procedure, public, pass(self) :: slice ../../../../ Return the raw characters data sliced. procedure, public, pass(self) :: snakecase ../../../../ Return a string with all words lowercase separated by “_”. procedure, public, pass(self) :: split ../../../../ Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: split_chunked ../../../../ Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: startcase ../../../../ Return a string with all words capitalized, e.g. title case. procedure, public, pass(self) :: strip ../../../../ Return a string with the leading and trailing characters removed. procedure, public, pass(self) :: swapcase ../../../../ Return a string with uppercase chars converted to lowercase and vice versa. procedure, public, pass(self) :: tempname ../../../../ Return a safe temporary name suitable for temporary file or directories. generic, public :: to_number => to_integer_I1P , to_integer_I2P , to_integer_I4P , to_integer_I8P , to_real_R8P , to_real_R4P ../../../../ Cast string to number. procedure, public, pass(self) :: unescape ../../../../ Unescape double backslashes (or custom escaped character). procedure, public, pass(self) :: unique ../../../../ Reduce to one (unique) multiple occurrences of a substring into a string. procedure, public, pass(self) :: upper ../../../../ Return a string with all uppercase characters. procedure, public, pass(self) :: write_file ../../../../ Write a single string stream into file. procedure, public, pass(self) :: write_line ../../../../ Write line (record) to a connected unit. procedure, public, pass(self) :: write_lines ../../../../ Write lines (records) to a connected unit. procedure, public, pass(self) :: end_with ../../../../ Return true if a string ends with a specified suffix. procedure, public, pass(self) :: is_allocated ../../../../ Return true if the string is allocated. procedure, public, pass(self) :: is_digit ../../../../ Return true if all characters in the string are digits. procedure, public, pass(self) :: is_integer ../../../../ Return true if the string contains an integer. procedure, public, pass(self) :: is_lower ../../../../ Return true if all characters in the string are lowercase. procedure, public, pass(self) :: is_number ../../../../ Return true if the string contains a number (real or integer). procedure, public, pass(self) :: is_real ../../../../ Return true if the string contains an real. procedure, public, pass(self) :: is_upper ../../../../ Return true if all characters in the string are uppercase. procedure, public, pass(self) :: start_with ../../../../ Return true if a string starts with a specified prefix. generic, public :: assignment(=) => string_assign_string , string_assign_character , string_assign_integer_I1P , string_assign_integer_I2P , string_assign_integer_I4P , string_assign_integer_I8P , string_assign_real_R8P , string_assign_real_R4P ../../../../ Assignment operator overloading. generic, public :: operator(//) => string_concat_string , string_concat_character , character_concat_string ../../../../ Concatenation operator overloading. generic, public :: operator(.cat.) => string_concat_string_string , string_concat_character_string , character_concat_string_string ../../../../ Concatenation operator (string output) overloading. generic, public :: operator(==) => string_eq_string , string_eq_character , character_eq_string ../../../../ Equal operator overloading. generic, public :: operator(/=) => string_ne_string , string_ne_character , character_ne_string ../../../../ Not equal operator overloading. generic, public :: operator(<) => string_lt_string , string_lt_character , character_lt_string ../../../../ Lower than operator overloading. generic, public :: operator(<=) => string_le_string , string_le_character , character_le_string ../../../../ Lower equal than operator overloading. generic, public :: operator(>=) => string_ge_string , string_ge_character , character_ge_string ../../../../ Greater equal than operator overloading. generic, public :: operator(>) => string_gt_string , string_gt_character , character_gt_string ../../../../ Greater than operator overloading. generic, public :: read(formatted) => read_formatted ../../../../ Formatted input. generic, public :: write(formatted) => write_formatted ../../../../ Formatted output. generic, public :: read(unformatted) => read_unformatted ../../../../ Unformatted input. generic, public :: write(unformatted) => write_unformatted ../../../../ Unformatted output. procedure, private, pass(self) :: sindex_string_string ../../../../ Index replacement. procedure, private, pass(self) :: sindex_string_character ../../../../ Index replacement. procedure, private, pass(self) :: srepeat_string_string ../../../../ Repeat replacement. procedure, private, nopass :: srepeat_character_string ../../../../ Repeat replacement. procedure, private, pass(self) :: sscan_string_string ../../../../ Scan replacement. procedure, private, pass(self) :: sscan_string_character ../../../../ Scan replacement. procedure, private, pass(self) :: sverify_string_string ../../../../ Verify replacement. procedure, private, pass(self) :: sverify_string_character ../../../../ Verify replacement. procedure, private, pass(self) :: colorize_str ../../../../ Colorize and stylize strings. procedure, private, pass(self) :: glob_character ../../../../ Glob search (character output). procedure, private, pass(self) :: glob_string ../../../../ Glob search (string output). procedure, private, pass(self) :: insert_string ../../../../ Insert substring into string at a specified position. procedure, private, pass(self) :: insert_character ../../../../ Insert substring into string at a specified position. procedure, private, pass(self) :: join_strings ../../../../ Return join string of an array of strings. procedure, private, pass(self) :: join_characters ../../../../ Return join string of an array of characters. procedure, private, nopass :: strjoin_strings ../../../../ Return join string of an array of strings. procedure, private, nopass :: strjoin_characters ../../../../ Return join string of an array of strings. procedure, private, nopass :: strjoin_strings_array ../../../../ Return join 1D string array of an 2D array of strings in columns or rows. procedure, private, nopass :: strjoin_characters_array ../../../../ Return join 1D string array of an 2D array of characters in columns or rows. procedure, private, pass(self) :: to_integer_I1P ../../../../ Cast string to integer. procedure, private, pass(self) :: to_integer_I2P ../../../../ Cast string to integer. procedure, private, pass(self) :: to_integer_I4P ../../../../ Cast string to integer. procedure, private, pass(self) :: to_integer_I8P ../../../../ Cast string to integer. procedure, private, pass(self) :: to_real_R4P ../../../../ Cast string to real. procedure, private, pass(self) :: to_real_R8P ../../../../ Cast string to real. procedure, private, pass(self) :: to_real_R16P ../../../../ Cast string to real. procedure, private, pass(lhs) :: string_assign_string ../../../../ Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character ../../../../ Assignment operator from character input. procedure, private, pass(lhs) :: string_assign_integer_I1P ../../../../ Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I2P ../../../../ Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I4P ../../../../ Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I8P ../../../../ Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_real_R4P ../../../../ Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R8P ../../../../ Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R16P ../../../../ Assignment operator from real input. procedure, private, pass(lhs) :: string_concat_string ../../../../ Concatenation with string. procedure, private, pass(lhs) :: string_concat_character ../../../../ Concatenation with character. procedure, private, pass(rhs) :: character_concat_string ../../../../ Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string ../../../../ Concatenation with string (string output). procedure, private, pass(lhs) :: string_concat_character_string ../../../../ Concatenation with character (string output). procedure, private, pass(rhs) :: character_concat_string_string ../../../../ Concatenation with character (inverted, string output). procedure, private, pass(lhs) :: string_eq_string ../../../../ Equal to string logical operator. procedure, private, pass(lhs) :: string_eq_character ../../../../ Equal to character logical operator. procedure, private, pass(rhs) :: character_eq_string ../../../../ Equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ne_string ../../../../ Not equal to string logical operator. procedure, private, pass(lhs) :: string_ne_character ../../../../ Not equal to character logical operator. procedure, private, pass(rhs) :: character_ne_string ../../../../ Not equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_lt_string ../../../../ Lower than to string logical operator. procedure, private, pass(lhs) :: string_lt_character ../../../../ Lower than to character logical operator. procedure, private, pass(rhs) :: character_lt_string ../../../../ Lower than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_le_string ../../../../ Lower equal than to string logical operator. procedure, private, pass(lhs) :: string_le_character ../../../../ Lower equal than to character logical operator. procedure, private, pass(rhs) :: character_le_string ../../../../ Lower equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ge_string ../../../../ Greater equal than to string logical operator. procedure, private, pass(lhs) :: string_ge_character ../../../../ Greater equal than to character logical operator. procedure, private, pass(rhs) :: character_ge_string ../../../../ Greater equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_gt_string ../../../../ Greater than to string logical operator. procedure, private, pass(lhs) :: string_gt_character ../../../../ Greater than to character logical operator. procedure, private, pass(rhs) :: character_gt_string ../../../../ Greater than to character (inverted) logical operator. procedure, private, pass(dtv) :: read_formatted ../../../../ Formatted input. procedure, private, pass(dtv) :: read_delimited ../../../../ Read a delimited input. procedure, private, pass(dtv) :: read_undelimited ../../../../ Read an undelimited input. procedure, private, pass(dtv) :: read_undelimited_listdirected ../../../../ Read an undelimited list directed input. procedure, private, pass(dtv) :: write_formatted ../../../../ Formatted output. procedure, private, pass(dtv) :: read_unformatted ../../../../ Unformatted input. procedure, private, pass(dtv) :: write_unformatted ../../../../ Unformatted output. procedure, private, pass(self) :: replace_one_occurrence ../../../../ Replace the first occurrence of substring old by new. Functions private pure function string_ (c) Return a string given a character input. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character. Return Value type( string ) String. private pure function sadjustl_character (s) result(adjusted) Left adjust a string by removing leading spaces (character output). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK, len=:), allocatable Adjusted string. private pure function sadjustr_character (s) result(adjusted) Right adjust a string by removing leading spaces (character output). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK, len=:), allocatable Adjusted string. private elemental function count_substring (s, substring) result(No) Count the number of occurences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. private elemental function sindex_character_string (s, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: s String. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_character_string (s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_character_string (s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sadjustl (self) result(adjusted) Left adjust a string by removing leading spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. private elemental function sadjustr (self) result(adjusted) Right adjust a string by removing leading spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. private elemental function scount (self, substring, ignore_isolated) result(No) Count the number of occurences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore “isolated” occurrences. Return Value integer Number of occurrences. private elemental function sindex_string_string (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sindex_string_character (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function slen (self) result(l) Return the length of a string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. private elemental function slen_trim (self) result(l) Return the length of a string, ignoring any trailing blanks. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. private elemental function srepeat_string_string (self, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. private elemental function srepeat_character_string (rstring, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. private elemental function sscan_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function strim (self) result(trimmed) Remove trailing spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. private elemental function sverify_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function basedir (self, sep) Return the base directory name of a string containing a file name. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. private elemental function basename (self, sep, extension, strip_last_extension) Return the base file name of a string containing a file name. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Directory separator. character(kind=CK, len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. private elemental function camelcase (self, sep) Return a string with all words capitalized without spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. private elemental function capitalize (self) result(capitalized) Return a string with its first character capitalized and the rest lowercased. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. private pure function chars (self) result(raw) Return the raw characters data. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK, len=:), allocatable Raw characters data. private pure function colorize_str (self, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, DEFAULT kind. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:), allocatable Colorized string. private elemental function decode (self, codec) result(decoded) Return a string decoded accordingly the codec. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. private elemental function encode (self, codec) result(encoded) Return a string encoded accordingly the codec. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. private elemental function escape (self, to_escape, esc) result(escaped) Escape backslashes (or custom escape character). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK, len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. private elemental function extension (self) Return the extension of a string containing a file name. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. private elemental function fill (self, width, right, filling_char) result(filled) Pad string on the left (or right) with zeros (or other char) to fill width. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK, len=1), intent(in), optional :: filling_char Filling character (default “0”). Return Value type( string ) Filled string. private elemental function insert_character (self, substring, pos) result(inserted) Insert substring into string at a specified position. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. private elemental function insert_string (self, substring, pos) result(inserted) Insert substring into string at a specified position. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. private pure function join_strings (self, array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function join_characters (self, array, sep) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function strjoin_strings (array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function strjoin_characters (array, sep, is_trim) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not Return Value type( string ) The join of array. private pure function strjoin_strings_array (array, sep, is_col) result(join) Return a string that is a join of columns or rows of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ), allocatable, (:) The join of array. private pure function strjoin_characters_array (array, sep, is_trim, is_col) result(join) Return a string that is a join of columns or rows of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK, len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ), allocatable, (:) The join of array. private elemental function lower (self) Return a string with all lowercase characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. private pure function partition (self, sep) result(partitions) Split string at separator and return the 3 parts (before, the separator and after). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ), (1:3) after the separator. private elemental function replace (self, old, new, count) result(replaced) Return a string with all occurrences of substring old replaced by new. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: old Old substring. character(kind=CK, len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. private elemental function reverse (self) result(reversed) Return a reversed string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. private  function search (self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Search for tagged record into string, return the first record found (if any) matching the tags. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: tag_start Start tag. character(kind=CK, len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK, len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. private pure function slice (self, istart, iend) result(raw) Return the raw characters data sliced. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK, len=:), allocatable Raw characters data. private elemental function snakecase (self, sep) Return a string with all words lowercase separated by “_”. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. private elemental function startcase (self, sep) Return a string with all words capitalized, e.g. title case. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. private elemental function strip (self, remove_nulls) Return a copy of the string with the leading and trailing characters removed. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. private elemental function swapcase (self) Return a copy of the string with uppercase characters converted to lowercase and vice versa. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. private  function tempname (self, is_file, prefix, path) Return a safe temporary name suitable for temporary file or directories. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: is_file True if tempname should be used for file (the default). character(len=*), intent(in), optional :: prefix Name prefix, otherwise self is used (if allocated). character(len=*), intent(in), optional :: path Path where file/directory should be used, default ./ . Return Value character(len=:), allocatable Safe (unique) temporary name. private elemental function to_integer_I1P (self, kind) result(to_number) Cast string to integer (I1P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. private elemental function to_integer_I2P (self, kind) result(to_number) Cast string to integer (I2P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. private elemental function to_integer_I4P (self, kind) result(to_number) Cast string to integer (I4P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. private elemental function to_integer_I8P (self, kind) result(to_number) Cast string to integer (I8P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. private elemental function to_real_R4P (self, kind) result(to_number) Cast string to real (R4P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. private elemental function to_real_R8P (self, kind) result(to_number) Cast string to real (R8P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. private elemental function to_real_R16P (self, kind) result(to_number) Cast string to real (R16P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. private elemental function unescape (self, to_unescape, unesc) result(unescaped) Unescape double backslashes (or custom escaped character). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK, len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. private elemental function unique (self, substring) result(uniq) Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. private elemental function upper (self) Return a string with all uppercase characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. private elemental function end_with (self, suffix, start, end, ignore_null_eof) Return true if a string ends with a specified suffix. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. logical, intent(in), optional :: ignore_null_eof Ignore null character at the end of file. Return Value logical Result of the test. private elemental function is_allocated (self) Return true if the string is allocated. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. private elemental function is_digit (self) Return true if all characters in the string are digits. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. private elemental function is_integer (self, allow_spaces) Return true if the string contains an integer. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. private elemental function is_lower (self) Return true if all characters in the string are lowercase. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. private elemental function is_number (self, allow_spaces) Return true if the string contains a number (real or integer). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. private elemental function is_real (self, allow_spaces) Return true if the string contains a real. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. private elemental function is_upper (self) Return true if all characters in the string are uppercase. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. private elemental function start_with (self, prefix, start, end) Return true if a string starts with a specified prefix. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. private pure function string_concat_string (lhs, rhs) result(concat) Concatenation with string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK, len=:), allocatable Concatenated string. private pure function string_concat_character (lhs, rhs) result(concat) Concatenation with character. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK, len=:), allocatable Concatenated string. private pure function character_concat_string (lhs, rhs) result(concat) Concatenation with character (inverted). Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK, len=:), allocatable Concatenated string. private elemental function string_concat_string_string (lhs, rhs) result(concat) Concatenation with string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Concatenation with character. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. private elemental function character_concat_string_string (lhs, rhs) result(concat) Concatenation with character (inverted). Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. private elemental function string_eq_string (lhs, rhs) result(is_it) Equal to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_eq_character (lhs, rhs) result(is_it) Equal to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_eq_string (lhs, rhs) result(is_it) Equal to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_ne_string (lhs, rhs) result(is_it) Not equal to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_ne_character (lhs, rhs) result(is_it) Not equal to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_ne_string (lhs, rhs) result(is_it) Not equal to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_lt_string (lhs, rhs) result(is_it) Lower than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_lt_character (lhs, rhs) result(is_it) Lower than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_lt_string (lhs, rhs) result(is_it) Lower than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_le_string (lhs, rhs) result(is_it) Lower equal than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_le_character (lhs, rhs) result(is_it) Lower equal than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_le_string (lhs, rhs) result(is_it) Lower equal than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_ge_string (lhs, rhs) result(is_it) Greater equal than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_ge_character (lhs, rhs) result(is_it) Greater equal than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_ge_string (lhs, rhs) result(is_it) Greater equal than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_gt_string (lhs, rhs) result(is_it) Greater than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_gt_character (lhs, rhs) result(is_it) Greater than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_gt_string (lhs, rhs) result(is_it) Greater than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK, len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function replace_one_occurrence (self, old, new) result(replaced) Return a string with the first occurrence of substring old replaced by new. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK, len=*), intent(in) :: old Old substring. character(kind=CK, len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Subroutines private elemental subroutine free (self) Free dynamic memory. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. private  subroutine glob_character (self, pattern, list) Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: pattern Given pattern. character(len=:), intent(out), allocatable :: list (:) List of matching pathnames. private  subroutine glob_string (self, pattern, list) Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: pattern Given pattern. type( string ), intent(out), allocatable :: list (:) List of matching pathnames. private  subroutine read_file (self, file, is_fast, form, iostat, iomsg) Read a file as a single string stream. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. logical, intent(in), optional :: is_fast Flag to enable (super) fast file reading. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. private  subroutine read_line (self, unit, form, iostat, iomsg) Read line (record) from a connected unit. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. private  subroutine read_lines (self, unit, form, iostat, iomsg) Read (all) lines (records) from a connected unit as a single ascii stream. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. private pure subroutine split (self, tokens, sep, max_tokens) Return a list of substring in the string, using sep as the delimiter string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK, len=*), intent(in), optional :: sep Separator. integer, intent(in), optional :: max_tokens Fix the maximum number of returned tokens. private pure subroutine split_chunked (self, tokens, chunks, sep) Return a list of substring in the string, using sep as the delimiter string, chunked (memory-efficient) algorithm. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. integer, intent(in) :: chunks Number of chunks. character(kind=CK, len=*), intent(in), optional :: sep Separator. private  subroutine write_file (self, file, form, iostat, iomsg) Write a single string stream into file. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. private  subroutine write_line (self, unit, form, iostat, iomsg) Write line (record) to a connected unit. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. private  subroutine write_lines (self, unit, form, iostat, iomsg) Write lines (records) to a connected unit. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. private pure subroutine string_assign_string (lhs, rhs) Assignment operator from string input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. private pure subroutine string_assign_character (lhs, rhs) Assignment operator from character input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK, len=*), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I1P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I2P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I4P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I8P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_real_R4P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_real_R8P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_real_R16P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. private  subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Formatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. private  subroutine read_delimited (dtv, unit, delim, iostat, iomsg) Read a delimited string from a unit connected for formatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK, len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. private  subroutine read_undelimited_listdirected (dtv, unit, iostat, iomsg) Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. private  subroutine read_undelimited (dtv, unit, terminators, iostat, iomsg) Read an undelimited string up until end of record or a character from a set of terminators is encountered. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK, len=*), intent(in) :: terminators Characters that are considered to terminate the string.\nBlanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. private  subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Formatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK, len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. private  subroutine read_unformatted (dtv, unit, iostat, iomsg) Unformatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. private  subroutine write_unformatted (dtv, unit, iostat, iomsg) Unformatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. private  subroutine get_delimiter_mode (unit, delim, iostat, iomsg) Get the DELIM changeable connection mode for the given unit. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit The unit for the connection. character(kind=CK, len=1), intent(out) :: delim Represents the value of the DELIM mode. integer, intent(out) :: iostat IOSTAT error code, non-zero on error. character(len=*), intent(inout) :: iomsg IOMSG explanatory message - only defined if iostat is non-zero. private  subroutine get_next_non_blank_character_this_record (unit, ch, iostat, iomsg) Get the next non-blank character in the current record. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK, len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. private  subroutine get_next_non_blank_character_any_record (unit, ch, iostat, iomsg) Get the next non-blank character, advancing records if necessary. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK, len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message. private  subroutine get_decimal_mode (unit, decimal_point, iostat, iomsg) Get the DECIMAL changeable connection mode for the given unit. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. logical, intent(out) :: decimal_point True if the decimal mode is POINT, false otherwise. integer, intent(out) :: iostat IO status code. character(kind=CK, len=*), intent(inout) :: iomsg IO status message.","tags":"","loc":"module/stringifor_string_t.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~~UsesGraph program~volatile_doctest volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~~CallsGraph program~volatile_doctest volatile_doctest proc~is_digit string%is_digit program~volatile_doctest->proc~is_digit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~2~~UsesGraph program~volatile_doctest~2 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~2->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~2~~CallsGraph program~volatile_doctest~2 volatile_doctest proc~startcase string%startcase program~volatile_doctest~2->proc~startcase none~join string%join proc~startcase->none~join proc~capitalize string%capitalize proc~startcase->proc~capitalize proc~split string%split proc~startcase->proc~split proc~join_characters string%join_characters none~join->proc~join_characters proc~join_strings string%join_strings none~join->proc~join_strings proc~lower string%lower proc~capitalize->proc~lower proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % startcase () // '' == 'The Quick Brown Fox Jumps Over The Lazy Dog.' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~2.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~3~~UsesGraph program~volatile_doctest~3 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~3->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring <= acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring <= acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( astring <= acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~3.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~4~~UsesGraph program~volatile_doctest~4 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~4->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~4~~CallsGraph program~volatile_doctest~4 volatile_doctest proc~is_real string%is_real program~volatile_doctest~4->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (6) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 6 ) astring = '   -1212112.d0 ' test_passed ( 1 ) = astring % is_real (). eqv .. true . astring = '   -1212112.d0' test_passed ( 2 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . astring = '-1212112.d0   ' test_passed ( 3 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . astring = '+2.e20' test_passed ( 4 ) = astring % is_real (). eqv .. true . astring = ' -2.01E13 ' test_passed ( 5 ) = astring % is_real (). eqv .. true . astring = ' -2.01 E13 ' test_passed ( 6 ) = astring % is_real (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~4.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~5~~UsesGraph program~volatile_doctest~5 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~5->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % verify ( set = 'llo' ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = 'llo' , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~5.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~6~~UsesGraph program~volatile_doctest~6 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~6->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~6~~CallsGraph program~volatile_doctest~6 volatile_doctest proc~upper string%upper program~volatile_doctest~6->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~6.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~7~~UsesGraph program~volatile_doctest~7 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~7->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~7~~CallsGraph program~volatile_doctest~7 volatile_doctest proc~fill string%fill program~volatile_doctest~7->proc~fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (4) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'this is string example....wow!!!' test_passed ( 1 ) = astring % fill ( width = 40 ) // '' == '00000000this is string example....wow!!!' test_passed ( 2 ) = astring % fill ( width = 50 ) // '' == '000000000000000000this is string example....wow!!!' test_passed ( 3 ) = astring % fill ( width = 50 , right = . true .) // '' == 'this is string example....wow!!!000000000000000000' test_passed ( 4 ) = astring % fill ( width = 40 , filling_char = '*' ) // '' == '********this is string example....wow!!!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~7.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~8~~UsesGraph program~volatile_doctest~8 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~8->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % index ( substring = 'llo' ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = 'llo' , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~8.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~9~~UsesGraph program~volatile_doctest~9 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~9->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'ell' test_passed ( 1 ) = verify ( s = 'Hello World Hello!' , set = string1 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = verify ( s = 'Hello World Hello!' , set = string1 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~9.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~10~~UsesGraph program~volatile_doctest~10 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~10->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring > acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring > acharacter ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~10.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~11~~UsesGraph program~volatile_doctest~11 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~11->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = '  one ' anotherstring = 'two' test_passed ( 1 ) = (( astring /= anotherstring ). eqv .. true .) astring = 'the same ' anotherstring = 'the same ' test_passed ( 2 ) = (( astring /= anotherstring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~11.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~12~~UsesGraph program~volatile_doctest~12 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~12->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring > anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring > anotherstring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~12.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~13~~UsesGraph program~volatile_doctest~13 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~13->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: string1 type( string ) :: string2 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % verify ( set = string2 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = string2 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~13.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~14~~UsesGraph program~volatile_doctest~14 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~14->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter >= astring ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter >= astring ). eqv .. true .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( acharacter >= astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~14.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~15~~UsesGraph program~volatile_doctest~15 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~15->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~15~~CallsGraph program~volatile_doctest~15 volatile_doctest proc~chars string%chars program~volatile_doctest~15->proc~chars proc~read_lines~2 string%read_lines program~volatile_doctest~15->proc~read_lines~2 proc~split string%split program~volatile_doctest~15->proc~split proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~read_line->proc~chars proc~upper string%upper proc~read_line->proc~upper proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (8) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) call astring % read_lines ( unit = scratch , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo close ( scratch ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~15.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~16~~UsesGraph program~volatile_doctest~16 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~16->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~16~~CallsGraph program~volatile_doctest~16 volatile_doctest proc~encode string%encode program~volatile_doctest~16->proc~encode b64_encode b64_encode proc~encode->b64_encode proc~upper string%upper proc~encode->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'How are you?' print '(L1)' , astring % encode ( codec = 'base64' ) // '' == 'SG93IGFyZSB5b3U/' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~16.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor program~~volatile_doctest~17~~UsesGraph program~volatile_doctest~17 volatile_doctest module~stringifor stringifor program~volatile_doctest~17->module~stringifor module~stringifor_string_t stringifor_string_t module~stringifor->module~stringifor_string_t penf penf module~stringifor->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~17~~CallsGraph program~volatile_doctest~17 volatile_doctest none~join string%join program~volatile_doctest~17->none~join proc~read_file~2 string%read_file program~volatile_doctest~17->proc~read_file~2 proc~split string%split program~volatile_doctest~17->proc~split proc~write_file write_file program~volatile_doctest~17->proc~write_file proc~join_characters string%join_characters none~join->proc~join_characters proc~join_strings string%join_strings none~join->proc~join_strings proc~chars string%chars proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~upper string%upper proc~read_file~2->proc~upper proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~write_file->proc~chars proc~write_file->proc~upper proc~write_lines write_lines proc~write_file->proc~write_lines proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~replace string%replace proc~unique->proc~replace proc~write_line string%write_line proc~write_lines->proc~write_line proc~read_line->proc~chars proc~read_line->proc~upper proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence proc~write_line->proc~chars proc~write_line->proc~upper proc~end_with string%end_with proc~write_line->proc~end_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (8) Source Code program volatile_doctest use stringifor type ( string ) :: astring type ( string ) :: anotherstring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) call write_file ( file = 'write_file_test.tmp' , lines = line , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo call write_file ( file = 'write_file_test.tmp' , lines = line , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( scratch , status = 'DELETE' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~17.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~18~~UsesGraph program~volatile_doctest~18 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~18->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~18~~CallsGraph program~volatile_doctest~18 volatile_doctest proc~camelcase string%camelcase program~volatile_doctest~18->proc~camelcase none~join string%join proc~camelcase->none~join proc~capitalize string%capitalize proc~camelcase->proc~capitalize proc~split string%split proc~camelcase->proc~split proc~join_characters string%join_characters none~join->proc~join_characters proc~join_strings string%join_strings none~join->proc~join_strings proc~lower string%lower proc~capitalize->proc~lower proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'caMeL caSe var' print '(L1)' , astring % camelcase () // '' == 'CamelCaseVar' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~18.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~19~~UsesGraph program~volatile_doctest~19 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~19->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~19~~CallsGraph program~volatile_doctest~19 volatile_doctest proc~tempname string%tempname program~volatile_doctest~19->proc~tempname Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: tmpname logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: tmpname logical :: test_passed ( 5 ) tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 1 )) test_passed ( 1 ) = . not . test_passed ( 1 ) tmpname = astring % tempname ( is_file = . false .) inquire ( file = tmpname , exist = test_passed ( 2 )) test_passed ( 2 ) = . not . test_passed ( 2 ) tmpname = astring % tempname ( path = './' ) inquire ( file = tmpname , exist = test_passed ( 3 )) test_passed ( 3 ) = . not . test_passed ( 3 ) astring = 'me-' tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 4 )) test_passed ( 4 ) = . not . test_passed ( 4 ) tmpname = astring % tempname ( prefix = 'you-' ) inquire ( file = tmpname , exist = test_passed ( 5 )) test_passed ( 5 ) = . not . test_passed ( 5 ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~19.html"},{"title":"stringifor_test_parse_large_csv – StringiFor","text":"Uses stringifor program~~stringifor_test_parse_large_csv~~UsesGraph program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv module~stringifor stringifor program~stringifor_test_parse_large_csv->module~stringifor module~stringifor_string_t stringifor_string_t module~stringifor->module~stringifor_string_t penf penf module~stringifor->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. StringiFor csv_naive_parser test. Calls program~~stringifor_test_parse_large_csv~~CallsGraph program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv none~join string%join program~stringifor_test_parse_large_csv->none~join proc~read_file~2 string%read_file program~stringifor_test_parse_large_csv->proc~read_file~2 proc~split string%split program~stringifor_test_parse_large_csv->proc~split proc~split_chunked string%split_chunked program~stringifor_test_parse_large_csv->proc~split_chunked proc~join_characters string%join_characters none~join->proc~join_characters proc~join_strings string%join_strings none~join->proc~join_strings proc~chars string%chars proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~upper string%upper proc~read_file~2->proc~upper proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~split_chunked->proc~split proc~end_with string%end_with proc~split_chunked->proc~end_with proc~start_with string%start_with proc~split_chunked->proc~start_with proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~replace string%replace proc~unique->proc~replace proc~read_line->proc~chars proc~read_line->proc~upper proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: csv The CSV file as a single stream. type( string ), allocatable :: rows (:) The CSV table rows. type( string ), allocatable :: columns (:) The CSV table columns. type( string ), allocatable :: cells (:,:) The CSV table cells. integer :: rows_number The CSV file rows number. integer :: columns_number The CSV file columns number. integer :: c Counter. integer :: r Counter. logical :: test_passed (1) List of passed tests. Source Code program stringifor_test_parse_large_csv !< StringiFor `csv_naive_parser` test. use stringifor implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: c , r !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . call csv % read_file ( file = 'src/tests/stringifor/stringifor_test_parse_large_csv.csv' , is_fast = . true .) call csv % split_chunked ( tokens = rows , sep = new_line ( 'a' ), chunks = 10 ) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' do c = 1 , columns_number columns ( c ) = '----' ! re-use columns for printing separators enddo print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' test_passed = . true . print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram stringifor_test_parse_large_csv","tags":"","loc":"program/stringifor_test_parse_large_csv.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~20~~UsesGraph program~volatile_doctest~20 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~20->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~20~~CallsGraph program~volatile_doctest~20 volatile_doctest proc~lower string%lower program~volatile_doctest~20->proc~lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % lower () // '' == 'hello world!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~20.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~21~~UsesGraph program~volatile_doctest~21 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~21->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~21~~CallsGraph program~volatile_doctest~21 volatile_doctest proc~chars string%chars program~volatile_doctest~21->proc~chars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'hello' test_passed ( 1 ) = astring % chars () == 'hello' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~21.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~22~~UsesGraph program~volatile_doctest~22 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~22->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~22~~CallsGraph program~volatile_doctest~22 volatile_doctest proc~extension string%extension program~volatile_doctest~22->proc~extension Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = '/bar/foo.tar.bz2' print '(L1)' , astring % extension () // '' == '.bz2' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~22.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~23~~UsesGraph program~volatile_doctest~23 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~23->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~23~~CallsGraph program~volatile_doctest~23 volatile_doctest proc~split string%split program~volatile_doctest~23->proc~split proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) logical :: test_passed (11) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) logical :: test_passed ( 11 ) astring = '+ab-++cre-++cre-ab+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'ab-++cre-++cre-ab+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'ab-++cre-++cre-ab' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'Hello ' // new_line ( 'a' ) // 'World!' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) astring = 'Hello World!' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) astring = '+ab-' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 6 ) = ( strings ( 1 ) // '' == 'ab-' ) astring = '+ab-' call astring % split ( tokens = strings , sep = '-' ) test_passed ( 7 ) = ( strings ( 1 ) // '' == '+ab' ) astring = '+ab-+cd-' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 8 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = 'ab-+cd-+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 9 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = '+ab-+cd-+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 10 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = '1-2-3-4-5-6-7-8' call astring % split ( tokens = strings , sep = '-' , max_tokens = 3 ) test_passed ( 11 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4-5-6-7-8' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~23.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~24~~UsesGraph program~volatile_doctest~24 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~24->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = '  one ' anotherstring = 'two' test_passed ( 1 ) = (( astring == anotherstring ). eqv .. false .) astring = 'the same ' anotherstring = 'the same ' test_passed ( 2 ) = (( astring == anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~24.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~25~~UsesGraph program~volatile_doctest~25 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~25->module~stringifor_string_t penf penf program~volatile_doctest~25->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~25~~CallsGraph program~volatile_doctest~25 volatile_doctest none~to_number string%to_number program~volatile_doctest~25->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring integer(kind=I1P) :: integer_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I1P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I1P ) test_passed ( 1 ) = integer_ == 127_I1P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~25.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~26~~UsesGraph program~volatile_doctest~26 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~26->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring >= acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring >= acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( astring >= acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~26.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~27~~UsesGraph program~volatile_doctest~27 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~27->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring < anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring < anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~27.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~28~~UsesGraph program~volatile_doctest~28 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~28->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter < astring ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter < astring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~28.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~29~~UsesGraph program~volatile_doctest~29 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~29->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~29~~CallsGraph program~volatile_doctest~29 volatile_doctest proc~swapcase string%swapcase program~volatile_doctest~29->proc~swapcase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = '  Hello World!   ' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~29.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~30~~UsesGraph program~volatile_doctest~30 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~30->module~stringifor_string_t penf penf program~volatile_doctest~30->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~30~~CallsGraph program~volatile_doctest~30 volatile_doctest none~to_number string%to_number program~volatile_doctest~30->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring integer(kind=I8P) :: integer_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I8P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I8P ) test_passed ( 1 ) = integer_ == 127_I8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~30.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~31~~UsesGraph program~volatile_doctest~31 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~31->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~31~~CallsGraph program~volatile_doctest~31 volatile_doctest proc~is_number string%is_number program~volatile_doctest~31->proc~is_number proc~is_integer string%is_integer proc~is_number->proc~is_integer proc~is_real string%is_real proc~is_number->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (7) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 7 ) astring = '   -1212112 ' test_passed ( 1 ) = astring % is_number (). eqv .. true . astring = '   -121.2112 ' test_passed ( 2 ) = astring % is_number (). eqv .. true . astring = '   -1212112' test_passed ( 3 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . astring = '-12121.12   ' test_passed ( 4 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . astring = '+2e20' test_passed ( 5 ) = astring % is_number (). eqv .. true . astring = ' -2.4E13 ' test_passed ( 6 ) = astring % is_number (). eqv .. true . astring = ' -2 E13 ' test_passed ( 7 ) = astring % is_number (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~31.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~32~~UsesGraph program~volatile_doctest~32 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~32->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~32~~CallsGraph program~volatile_doctest~32 volatile_doctest proc~decode string%decode program~volatile_doctest~32->proc~decode b64_decode b64_decode proc~decode->b64_decode proc~strip string%strip proc~decode->proc~strip proc~upper string%upper proc~decode->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'SG93IGFyZSB5b3U/' print '(L1)' , astring % decode ( codec = 'base64' ) // '' == 'How are you?' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~32.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~33~~UsesGraph program~volatile_doctest~33 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~33->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' test_passed ( 1 ) = astring // acharacter == 'Hello World!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~33.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~34~~UsesGraph program~volatile_doctest~34 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~34->module~stringifor_string_t penf penf program~volatile_doctest~34->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~34~~CallsGraph program~volatile_doctest~34 volatile_doctest none~to_number string%to_number program~volatile_doctest~34->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R8P test_passed ( 1 ) = astring % to_number ( kind = 1._R8P ) == 3.021e6_R8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~34.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~35~~UsesGraph program~volatile_doctest~35 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~35->module~stringifor_string_t penf penf program~volatile_doctest~35->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~35~~CallsGraph program~volatile_doctest~35 volatile_doctest none~to_number string%to_number program~volatile_doctest~35->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R8P test_passed ( 1 ) = astring % to_number ( kind = 1._R8P ) == 3.021e6_R8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~35.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~36~~UsesGraph program~volatile_doctest~36 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~36->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Source Code program volatile_doctest use stringifor_string_t print \"(L1)\" , string ( 'Hello World' ) // '' == 'Hello World' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~36.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~37~~UsesGraph program~volatile_doctest~37 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~37->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( acharacter == astring ). eqv .. false .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( acharacter == astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~37.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~38~~UsesGraph program~volatile_doctest~38 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~38->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = scan ( s = 'Hello World Hello!' , set = string1 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = scan ( s = 'Hello World Hello!' , set = string1 , back = . true .) == scan ( string = 'Hello World Hello!' , & set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~38.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~39~~UsesGraph program~volatile_doctest~39 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~39->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'y' print \"(L1)\" , astring % repeat ( 'x' , 5 ) // '' == 'xxxxx' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~39.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~40~~UsesGraph program~volatile_doctest~40 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~40->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~40~~CallsGraph program~volatile_doctest~40 volatile_doctest proc~is_upper string%is_upper program~volatile_doctest~40->proc~is_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 3 ) astring = ' Hello World' test_passed ( 1 ) = astring % is_upper (). eqv .. false . astring = ' HELLO WORLD' test_passed ( 2 ) = astring % is_upper (). eqv .. true . astring = ' hello world' test_passed ( 3 ) = astring % is_upper (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~40.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~41~~UsesGraph program~volatile_doctest~41 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~41->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~41~~CallsGraph program~volatile_doctest~41 volatile_doctest proc~unique string%unique program~volatile_doctest~41->proc~unique proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = '+++ab-++cre-++cre-ab+++++' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~41.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~42~~UsesGraph program~volatile_doctest~42 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~42->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % adjustr () // '' == '   Hello World!' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~42.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~43~~UsesGraph program~volatile_doctest~43 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~43->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = index ( s = 'Hello World Hello!' , substring = string1 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = index ( s = 'Hello World Hello!' , substring = string1 , back = . true .) == index ( string = 'Hello World Hello!' , & substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~43.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~44~~UsesGraph program~volatile_doctest~44 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~44->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~44~~CallsGraph program~volatile_doctest~44 volatile_doctest none~join string%join program~volatile_doctest~44->none~join proc~read_file~2 string%read_file program~volatile_doctest~44->proc~read_file~2 proc~split string%split program~volatile_doctest~44->proc~split proc~write_file~2 string%write_file program~volatile_doctest~44->proc~write_file~2 proc~join_characters string%join_characters none~join->proc~join_characters proc~join_strings string%join_strings none~join->proc~join_strings proc~chars string%chars proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~upper string%upper proc~read_file~2->proc~upper proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~write_file~2->proc~chars proc~write_file~2->proc~upper proc~write_lines~2 string%write_lines proc~write_file~2->proc~write_lines~2 proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~replace string%replace proc~unique->proc~replace proc~write_lines~2->proc~split proc~write_line string%write_line proc~write_lines~2->proc~write_line proc~read_line->proc~chars proc~read_line->proc~upper proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence proc~write_line->proc~chars proc~write_line->proc~upper proc~end_with string%end_with proc~write_line->proc~end_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (8) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) call anotherstring % write_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo call anotherstring % write_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( unit = scratch , status = 'delete' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~44.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~45~~UsesGraph program~volatile_doctest~45 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~45->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( astring == acharacter ). eqv .. false .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( astring == acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~45.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~46~~UsesGraph program~volatile_doctest~46 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~46->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~46~~CallsGraph program~volatile_doctest~46 volatile_doctest none~insert string%insert program~volatile_doctest~46->none~insert proc~insert_character string%insert_character none~insert->proc~insert_character proc~insert_string string%insert_string none~insert->proc~insert_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 5 ) astring = 'this is string example wow!!!' anotherstring = '... ' test_passed ( 1 ) = astring % insert ( substring = anotherstring , pos = 1 ) // '' == '... this is string example wow!!!' test_passed ( 2 ) = astring % insert ( substring = anotherstring , pos = 23 ) // '' == 'this is string example...  wow!!!' test_passed ( 3 ) = astring % insert ( substring = anotherstring , pos = 29 ) // '' == 'this is string example wow!!!... ' test_passed ( 4 ) = astring % insert ( substring = anotherstring , pos =- 1 ) // '' == '... this is string example wow!!!' test_passed ( 5 ) = astring % insert ( substring = anotherstring , pos = 100 ) // '' == 'this is string example wow!!!... ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~46.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~47~~UsesGraph program~volatile_doctest~47 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~47->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (4) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 4 ) astring = '   Hello World  !    ' test_passed ( 1 ) = astring % count ( substring = ' ' ) == 10 astring = 'Hello World  !    ' test_passed ( 2 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 6 astring = '    Hello World  !' test_passed ( 3 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 6 astring = '   Hello World  !    ' test_passed ( 4 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 8 print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~47.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~48~~UsesGraph program~volatile_doctest~48 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~48->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: string1 type( string ) :: string2 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % index ( substring = string2 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = string2 , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~48.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~49~~UsesGraph program~volatile_doctest~49 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~49->module~stringifor_string_t penf penf program~volatile_doctest~49->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~49~~CallsGraph program~volatile_doctest~49 volatile_doctest none~to_number string%to_number program~volatile_doctest~49->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring real(kind=R4P) :: real_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring real ( R4P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R4P ) test_passed ( 1 ) = real_ == 3.4e9_R4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~49.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~50~~UsesGraph program~volatile_doctest~50 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~50->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~50~~CallsGraph program~volatile_doctest~50 volatile_doctest proc~chars string%chars program~volatile_doctest~50->proc~chars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: yetanotherstring character(len=:), allocatable :: acharacter logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: yetanotherstring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' yetanotherstring = astring . cat . acharacter test_passed ( 1 ) = yetanotherstring % chars () == 'Hello World!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~50.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~51~~UsesGraph program~volatile_doctest~51 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~51->module~stringifor_string_t penf penf program~volatile_doctest~51->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~51~~CallsGraph program~volatile_doctest~51 volatile_doctest none~to_number string%to_number program~volatile_doctest~51->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring real(kind=R8P) :: real_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring real ( R8P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R8P ) test_passed ( 1 ) = real_ == 3.4e9_R8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~51.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~52~~UsesGraph program~volatile_doctest~52 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~52->module~stringifor_string_t penf penf program~volatile_doctest~52->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~52~~CallsGraph program~volatile_doctest~52 volatile_doctest none~to_number string%to_number program~volatile_doctest~52->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I4P test_passed ( 1 ) = astring % to_number ( kind = 1_I4P ) == 127_I4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~52.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~53~~UsesGraph program~volatile_doctest~53 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~53->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , adjustl ( astring ) == 'Hello World!   ' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~53.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor program~~volatile_doctest~54~~UsesGraph program~volatile_doctest~54 volatile_doctest module~stringifor stringifor program~volatile_doctest~54->module~stringifor module~stringifor_string_t stringifor_string_t module~stringifor->module~stringifor_string_t penf penf module~stringifor->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~54~~CallsGraph program~volatile_doctest~54 volatile_doctest proc~chars string%chars program~volatile_doctest~54->proc~chars proc~read_file read_file program~volatile_doctest~54->proc~read_file proc~read_file->proc~chars proc~read_lines read_lines proc~read_file->proc~read_lines proc~upper string%upper proc~read_file->proc~upper proc~read_lines->proc~chars proc~read_lines->proc~upper proc~read_line string%read_line proc~read_lines->proc~read_line proc~read_line->proc~chars proc~read_line->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (8) Source Code program volatile_doctest use stringifor type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) call read_file ( file = 'read_file_test.tmp' , lines = strings , iostat = iostat , iomsg = iomsg ) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) call read_file ( file = 'read_file_test.tmp' , lines = strings , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~54.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~55~~UsesGraph program~volatile_doctest~55 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~55->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len_trim () == len_trim ( 'Hello World!   ' ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~55.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~56~~UsesGraph program~volatile_doctest~56 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~56->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Source Code program volatile_doctest use stringifor_string_t print \"(L1)\" , count ( 'hello' , substring = 'll' ) == 1 endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~56.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~57~~UsesGraph program~volatile_doctest~57 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~57->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~57~~CallsGraph program~volatile_doctest~57 volatile_doctest none~join string%join program~volatile_doctest~57->none~join proc~join_characters string%join_characters none~join->proc~join_characters proc~join_strings string%join_strings none~join->proc~join_strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: strings (3) logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: strings ( 3 ) logical :: test_passed ( 5 ) strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 1 ) = ( astring % join ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) test_passed ( 2 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 3 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free test_passed ( 4 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' test_passed ( 5 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~57.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~58~~UsesGraph program~volatile_doctest~58 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~58->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'x' print \"(L1)\" , astring % repeat ( 5 ) // '' == 'xxxxx' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~58.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~59~~UsesGraph program~volatile_doctest~59 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~59->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len () == len ( 'Hello World!   ' ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~59.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~60~~UsesGraph program~volatile_doctest~60 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~60->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~60~~CallsGraph program~volatile_doctest~60 volatile_doctest proc~is_integer string%is_integer program~volatile_doctest~60->proc~is_integer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (6) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 6 ) astring = '   -1212112 ' test_passed ( 1 ) = astring % is_integer (). eqv .. true . astring = '   -1212112' test_passed ( 2 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . astring = '-1212112   ' test_passed ( 3 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . astring = '+2e20' test_passed ( 4 ) = astring % is_integer (). eqv .. true . astring = ' -2E13 ' test_passed ( 5 ) = astring % is_integer (). eqv .. true . astring = ' -2 E13 ' test_passed ( 6 ) = astring % is_integer (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~60.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~61~~UsesGraph program~volatile_doctest~61 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~61->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~61~~CallsGraph program~volatile_doctest~61 volatile_doctest none~join string%join program~volatile_doctest~61->none~join proc~join_characters string%join_characters none~join->proc~join_characters proc~join_strings string%join_strings none~join->proc~join_strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring character(len=5) :: characters (3) logical :: test_passed (6) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( 5 ) :: characters ( 3 ) logical :: test_passed ( 6 ) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 1 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) test_passed ( 2 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 3 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 4 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 5 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' astring = '_' test_passed ( 6 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // '_' // characters ( 2 ) // '_' // characters ( 3 )) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~61.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~62~~UsesGraph program~volatile_doctest~62 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~62->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~62~~CallsGraph program~volatile_doctest~62 volatile_doctest proc~replace string%replace program~volatile_doctest~62->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 3 ) astring = 'When YOU are sad YOU should think to me :-)' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) astring = repeat ( new_line ( 'a' ) // 'abcd' , 20 ) astring = astring % replace ( old = new_line ( 'a' ), new = '|cr|' ) astring = astring % replace ( old = '|cr|' , new = new_line ( 'a' ) // '    ' ) test_passed ( 3 ) = ( astring // '' == repeat ( new_line ( 'a' ) // '    ' // 'abcd' , 20 )) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~62.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~63~~UsesGraph program~volatile_doctest~63 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~63->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~63~~CallsGraph program~volatile_doctest~63 volatile_doctest proc~escape string%escape program~volatile_doctest~63->proc~escape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = '&#94;\\s \\d+\\s*' test_passed ( 1 ) = astring % escape ( to_escape = '\\')//''==' &#94;\\\\ s \\\\ d + \\\\ s * ' test_passed(2) = astring%escape(to_escape=' \\ ', esc=' | ')//''==' &#94;|\\ s |\\ d + |\\ s * ' print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~63.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~64~~UsesGraph program~volatile_doctest~64 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~64->module~stringifor_string_t penf penf program~volatile_doctest~64->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~64~~CallsGraph program~volatile_doctest~64 volatile_doctest none~to_number string%to_number program~volatile_doctest~64->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring integer(kind=I2P) :: integer_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I2P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I2P ) test_passed ( 1 ) = integer_ == 127_I2P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~64.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~65~~UsesGraph program~volatile_doctest~65 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~65->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter > astring ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter > astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~65.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~66~~UsesGraph program~volatile_doctest~66 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~66->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~66~~CallsGraph program~volatile_doctest~66 volatile_doctest proc~unescape string%unescape program~volatile_doctest~66->proc~unescape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = '&#94;\\\\s \\\\d+\\\\s*' test_passed ( 1 ) = ( astring % unescape ( to_unescape = '\\')//''==' &#94;\\ s \\ d + \\ s * ') test_passed(2) = (astring%unescape(to_unescape=' s ')//''==' &#94;\\ s \\\\ d + \\ s * ') print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~66.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~67~~UsesGraph program~volatile_doctest~67 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~67->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter <= astring ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter <= astring ). eqv .. false .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( acharacter <= astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~67.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~68~~UsesGraph program~volatile_doctest~68 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~68->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~68~~CallsGraph program~volatile_doctest~68 volatile_doctest proc~chars string%chars program~volatile_doctest~68->proc~chars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % chars () == 'say all Hello WorLD!' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~68.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~69~~UsesGraph program~volatile_doctest~69 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~69->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~69~~CallsGraph program~volatile_doctest~69 volatile_doctest proc~search string%search program~volatile_doctest~69->proc~search Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring character(len=:), allocatable :: acharacter integer :: istart integer :: iend logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring character ( len = :), allocatable :: acharacter integer :: istart integer :: iend logical :: test_passed ( 5 ) astring = '<test> <first> hello </first> <first> not the first </first> </test>' anotherstring = astring % search ( tag_start = '<first>' , tag_end = '</first>' ) test_passed ( 1 ) = anotherstring // '' == '<first> hello </first>' astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' anotherstring = astring % search ( tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 2 ) = anotherstring // '' == '<a> <a> <a> the nested a </a> </a> </a>' call astring % free anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_string = anotherstring , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 3 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' call astring % free acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 4 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<sec>' , tag_end = '</sec>' , istart = istart , iend = iend ) test_passed ( 5 ) = astring // '' == acharacter ( 31 : 67 ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~69.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~70~~UsesGraph program~volatile_doctest~70 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~70->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: string1 type( string ) :: string2 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % scan ( set = string2 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = string2 , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~70.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~71~~UsesGraph program~volatile_doctest~71 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~71->module~stringifor_string_t penf penf program~volatile_doctest~71->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~71~~CallsGraph program~volatile_doctest~71 volatile_doctest none~to_number string%to_number program~volatile_doctest~71->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I8P test_passed ( 1 ) = astring % to_number ( kind = 1_I8P ) == 127_I8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~71.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~72~~UsesGraph program~volatile_doctest~72 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~72->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~72~~CallsGraph program~volatile_doctest~72 volatile_doctest proc~chars string%chars program~volatile_doctest~72->proc~chars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: yetanotherstring character(len=:), allocatable :: acharacter logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: yetanotherstring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' yetanotherstring = acharacter . cat . astring test_passed ( 1 ) = yetanotherstring % chars () == 'World!Hello ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~72.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~73~~UsesGraph program~volatile_doctest~73 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~73->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( astring /= acharacter ). eqv .. true .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( astring /= acharacter ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~73.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~74~~UsesGraph program~volatile_doctest~74 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~74->module~stringifor_string_t penf penf program~volatile_doctest~74->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~74~~CallsGraph program~volatile_doctest~74 volatile_doctest none~to_number string%to_number program~volatile_doctest~74->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R4P test_passed ( 1 ) = astring % to_number ( kind = 1._R4P ) == 3.021e6_R4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~74.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~75~~UsesGraph program~volatile_doctest~75 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~75->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~75~~CallsGraph program~volatile_doctest~75 volatile_doctest proc~split_chunked string%split_chunked program~volatile_doctest~75->proc~split_chunked proc~end_with string%end_with proc~split_chunked->proc~end_with proc~split string%split proc~split_chunked->proc~split proc~start_with string%start_with proc~split_chunked->proc~start_with proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) logical :: test_passed ( 1 ) astring = '-1-2-3-4-5-6-7-8-' call astring % split_chunked ( tokens = strings , sep = '-' , chunks = 3 ) test_passed ( 1 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4' . and . & strings ( 5 ) // '' == '5' . and . strings ( 6 ) // '' == '6' . and . strings ( 7 ) // '' == '7' . and . strings ( 8 ) // '' == '8' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~75.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~76~~UsesGraph program~volatile_doctest~76 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~76->module~stringifor_string_t penf penf program~volatile_doctest~76->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~76~~CallsGraph program~volatile_doctest~76 volatile_doctest none~to_number string%to_number program~volatile_doctest~76->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring integer(kind=I4P) :: integer_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I4P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I4P ) test_passed ( 1 ) = integer_ == 127_I4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~76.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~77~~UsesGraph program~volatile_doctest~77 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~77->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 3 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring >= anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring >= anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'ONE' test_passed ( 3 ) = (( astring >= anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~77.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~78~~UsesGraph program~volatile_doctest~78 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~78->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 1 ) astring = 'Hello ' anotherstring = 'Bye bye' test_passed ( 1 ) = astring // anotherstring == 'Hello Bye bye' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~78.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~79~~UsesGraph program~volatile_doctest~79 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~79->module~stringifor_string_t penf penf program~volatile_doctest~79->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~79~~CallsGraph program~volatile_doctest~79 volatile_doctest none~to_number string%to_number program~volatile_doctest~79->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I1P test_passed ( 1 ) = astring % to_number ( kind = 1_I1P ) == 127_I1P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~79.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~80~~UsesGraph program~volatile_doctest~80 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~80->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~80~~CallsGraph program~volatile_doctest~80 volatile_doctest proc~is_allocated string%is_allocated program~volatile_doctest~80->proc~is_allocated Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'this is string example....wow!!!' call astring % free print '(L1)' , astring % is_allocated (). eqv .. false . endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~80.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~81~~UsesGraph program~volatile_doctest~81 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~81->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~81~~CallsGraph program~volatile_doctest~81 volatile_doctest proc~capitalize string%capitalize program~volatile_doctest~81->proc~capitalize proc~lower string%lower proc~capitalize->proc~lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % capitalize () // '' == 'Say all hello world!' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~81.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~82~~UsesGraph program~volatile_doctest~82 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~82->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~82~~CallsGraph program~volatile_doctest~82 volatile_doctest none~glob string%glob program~volatile_doctest~82->none~glob proc~tempname string%tempname program~volatile_doctest~82->proc~tempname proc~glob_character string%glob_character none~glob->proc~glob_character proc~glob_string string%glob_string none~glob->proc~glob_string proc~glob_character->none~glob proc~chars string%chars proc~glob_character->proc~chars proc~glob_string->proc~tempname proc~read_file~2 string%read_file proc~glob_string->proc~read_file~2 proc~split string%split proc~glob_string->proc~split proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~upper string%upper proc~read_file~2->proc~upper proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~replace string%replace proc~unique->proc~replace proc~read_line->proc~chars proc~read_line->proc~upper proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: alist_chr (:) integer, parameter :: Nf = 5 character(len=14) :: files (1:Nf) integer :: file_unit integer :: f integer :: ff logical :: test_passed Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_chr ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr print '(L1)' , test_passed endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~82.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~83~~UsesGraph program~volatile_doctest~83 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~83->module~stringifor_string_t penf penf program~volatile_doctest~83->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~83~~CallsGraph program~volatile_doctest~83 volatile_doctest none~to_number string%to_number program~volatile_doctest~83->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring real(kind=R16P) :: real_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring real ( R16P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R16P ) test_passed ( 1 ) = real_ == 3.4e9_R16P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~83.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~84~~UsesGraph program~volatile_doctest~84 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~84->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~84~~CallsGraph program~volatile_doctest~84 volatile_doctest proc~is_lower string%is_lower program~volatile_doctest~84->proc~is_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 3 ) astring = ' Hello World' test_passed ( 1 ) = astring % is_lower (). eqv .. false . astring = ' HELLO WORLD' test_passed ( 2 ) = astring % is_lower (). eqv .. false . astring = ' hello world' test_passed ( 3 ) = astring % is_lower (). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~84.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~85~~UsesGraph program~volatile_doctest~85 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~85->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , astring % adjustl () // '' == 'Hello World!   ' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~85.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~86~~UsesGraph program~volatile_doctest~86 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~86->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring < acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring < acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~86.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~87~~UsesGraph program~volatile_doctest~87 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~87->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~87~~CallsGraph program~volatile_doctest~87 volatile_doctest proc~chars string%chars program~volatile_doctest~87->proc~chars proc~read_line string%read_line program~volatile_doctest~87->proc~read_line proc~read_line->proc~chars proc~upper string%upper proc~read_line->proc~upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (6) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 6 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then exit else test_passed ( l ) = ( astring == line ( l )) endif enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg , form = 'UnfORMatteD' ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then exit else test_passed ( l + 3 ) = ( astring == line ( l )) endif enddo close ( scratch ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~87.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~88~~UsesGraph program~volatile_doctest~88 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~88->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~88~~CallsGraph program~volatile_doctest~88 volatile_doctest proc~basename string%basename program~volatile_doctest~88->proc~basename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 5 ) astring = 'bar/foo.tar.bz2' test_passed ( 1 ) = astring % basename () // '' == 'foo.tar.bz2' test_passed ( 2 ) = astring % basename ( extension = '.tar.bz2' ) // '' == 'foo' test_passed ( 3 ) = astring % basename ( strip_last_extension = . true .) // '' == 'foo.tar' astring = '\\bar\\foo.tar.bz2' test_passed ( 4 ) = astring % basename ( sep = '\\')//''==' foo . tar . bz2 ' astring = ' bar ' test_passed(5) = astring%basename(strip_last_extension=.true.)//''==' bar ' print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~88.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~89~~UsesGraph program~volatile_doctest~89 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~89->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , adjustr ( astring ) == '   Hello World!' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~89.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~90~~UsesGraph program~volatile_doctest~90 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~90->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~90~~CallsGraph program~volatile_doctest~90 volatile_doctest none~colorize string%colorize program~volatile_doctest~90->none~colorize proc~colorize_str string%colorize_str none~colorize->proc~colorize_str colorize colorize proc~colorize_str->colorize proc~chars string%chars proc~colorize_str->proc~chars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % colorize ( color_fg = 'red' ) == '\u001b[31msay all Hello WorLD!\u001b[0m' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~90.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~91~~UsesGraph program~volatile_doctest~91 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~91->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( acharacter /= astring ). eqv .. true .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( acharacter /= astring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~91.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~92~~UsesGraph program~volatile_doctest~92 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~92->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~92~~CallsGraph program~volatile_doctest~92 volatile_doctest proc~partition string%partition program~volatile_doctest~92->proc~partition Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: strings (3) logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: strings ( 3 ) logical :: test_passed ( 3 ) astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~92.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~93~~UsesGraph program~volatile_doctest~93 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~93->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~93~~CallsGraph program~volatile_doctest~93 volatile_doctest proc~is_allocated string%is_allocated program~volatile_doctest~93->proc~is_allocated Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) test_passed ( 1 ) = astring % is_allocated (). eqv .. false . astring = 'hello' test_passed ( 2 ) = astring % is_allocated (). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~93.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~94~~UsesGraph program~volatile_doctest~94 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~94->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~94~~CallsGraph program~volatile_doctest~94 volatile_doctest proc~chars string%chars program~volatile_doctest~94->proc~chars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 1 ) astring = 'hello' anotherstring = astring test_passed ( 1 ) = astring % chars () == anotherstring % chars () print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~94.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~95~~UsesGraph program~volatile_doctest~95 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~95->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' test_passed ( 1 ) = acharacter // astring == 'World!Hello ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~95.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~96~~UsesGraph program~volatile_doctest~96 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~96->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~96~~CallsGraph program~volatile_doctest~96 volatile_doctest proc~slice string%slice program~volatile_doctest~96->proc~slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'the Quick Brown fox Jumps over the Lazy Dog.' print \"(A)\" , astring % slice ( 11 , 25 ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~96.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~97~~UsesGraph program~volatile_doctest~97 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~97->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % trim () == trim ( 'Hello World!   ' ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~97.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~98~~UsesGraph program~volatile_doctest~98 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~98->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~98~~CallsGraph program~volatile_doctest~98 volatile_doctest proc~snakecase string%snakecase program~volatile_doctest~98->proc~snakecase none~join string%join proc~snakecase->none~join proc~lower string%lower proc~snakecase->proc~lower proc~split string%split proc~snakecase->proc~split proc~join_characters string%join_characters none~join->proc~join_characters proc~join_strings string%join_strings none~join->proc~join_strings proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~replace string%replace proc~unique->proc~replace proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % snakecase () // '' == 'the_quick_brown_fox_jumps_over_the_lazy_dog.' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~98.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~99~~UsesGraph program~volatile_doctest~99 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~99->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~99~~CallsGraph program~volatile_doctest~99 volatile_doctest proc~basedir string%basedir program~volatile_doctest~99->proc~basedir Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (4) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 4 ) string1 = '/bar/foo.tar.bz2' test_passed ( 1 ) = string1 % basedir () // '' == '/bar' string1 = './bar/foo.tar.bz2' test_passed ( 2 ) = string1 % basedir () // '' == './bar' string1 = 'bar/foo.tar.bz2' test_passed ( 3 ) = string1 % basedir () // '' == 'bar' string1 = '\\bar\\foo.tar.bz2' test_passed ( 4 ) = string1 % basedir ( sep = '\\')//''==' \\ bar ' print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~99.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~100~~UsesGraph program~volatile_doctest~100 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~100->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~100~~CallsGraph program~volatile_doctest~100 volatile_doctest interface~glob glob program~volatile_doctest~100->interface~glob proc~tempname string%tempname program~volatile_doctest~100->proc~tempname proc~glob_character string%glob_character interface~glob->proc~glob_character proc~glob_string string%glob_string interface~glob->proc~glob_string none~glob string%glob proc~glob_character->none~glob proc~chars string%chars proc~glob_character->proc~chars proc~glob_string->proc~tempname proc~read_file~2 string%read_file proc~glob_string->proc~read_file~2 proc~split string%split proc~glob_string->proc~split none~glob->proc~glob_character none~glob->proc~glob_string proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~upper string%upper proc~read_file~2->proc~upper proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~replace string%replace proc~unique->proc~replace proc~read_line->proc~chars proc~read_line->proc~upper proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: alist_chr (:) type( string ), allocatable :: alist_str (:) integer, parameter :: Nf = 5 character(len=14) :: files (1:Nf) integer :: file_unit integer :: f integer :: ff logical :: test_passed Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call glob ( self = astring , pattern = 'foo-*' , list = alist_chr ) call glob ( self = astring , pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr if ( test_passed ) then test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str endif print '(L1)' , test_passed endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~100.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~101~~UsesGraph program~volatile_doctest~101 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~101->module~stringifor_string_t penf penf program~volatile_doctest~101->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~101~~CallsGraph program~volatile_doctest~101 volatile_doctest none~to_number string%to_number program~volatile_doctest~101->none~to_number proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I2P test_passed ( 1 ) = astring % to_number ( kind = 1_I2P ) == 127_I2P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~101.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~102~~UsesGraph program~volatile_doctest~102 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~102->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~102~~CallsGraph program~volatile_doctest~102 volatile_doctest proc~start_with string%start_with program~volatile_doctest~102->proc~start_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (4) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~102.html"},{"title":"stringifor_test_csv_naive_parser – StringiFor","text":"Uses stringifor program~~stringifor_test_csv_naive_parser~~UsesGraph program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser module~stringifor stringifor program~stringifor_test_csv_naive_parser->module~stringifor module~stringifor_string_t stringifor_string_t module~stringifor->module~stringifor_string_t penf penf module~stringifor->penf module~stringifor_string_t->penf befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. StringiFor csv naive parser test. This is an example of the usefulness of StringiFor. Calls program~~stringifor_test_csv_naive_parser~~CallsGraph program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser none~join string%join program~stringifor_test_csv_naive_parser->none~join none~to_number string%to_number program~stringifor_test_csv_naive_parser->none~to_number proc~read_file~2 string%read_file program~stringifor_test_csv_naive_parser->proc~read_file~2 proc~split string%split program~stringifor_test_csv_naive_parser->proc~split proc~write_file write_file program~stringifor_test_csv_naive_parser->proc~write_file proc~join_characters string%join_characters none~join->proc~join_characters proc~join_strings string%join_strings none~join->proc~join_strings proc~to_integer_i1p string%to_integer_I1P none~to_number->proc~to_integer_i1p proc~to_integer_i2p string%to_integer_I2P none~to_number->proc~to_integer_i2p proc~to_integer_i4p string%to_integer_I4P none~to_number->proc~to_integer_i4p proc~to_integer_i8p string%to_integer_I8P none~to_number->proc~to_integer_i8p proc~to_real_r4p string%to_real_R4P none~to_number->proc~to_real_r4p proc~to_real_r8p string%to_real_R8P none~to_number->proc~to_real_r8p proc~chars string%chars proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~upper string%upper proc~read_file~2->proc~upper proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~write_file->proc~chars proc~write_file->proc~upper proc~write_lines write_lines proc~write_file->proc~write_lines proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~is_integer string%is_integer proc~to_integer_i1p->proc~is_integer proc~to_integer_i2p->proc~is_integer proc~to_integer_i4p->proc~is_integer proc~to_integer_i8p->proc~is_integer proc~is_real string%is_real proc~to_real_r4p->proc~is_real proc~to_real_r8p->proc~is_real proc~replace string%replace proc~unique->proc~replace proc~write_line string%write_line proc~write_lines->proc~write_line proc~read_line->proc~chars proc~read_line->proc~upper proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence proc~write_line->proc~chars proc~write_line->proc~upper proc~end_with string%end_with proc~write_line->proc~end_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: csv The CSV file as a single stream. type( string ), allocatable :: rows (:) The CSV table rows. type( string ), allocatable :: columns (:) The CSV table columns. type( string ), allocatable :: cells (:,:) The CSV table cells. type( string ) :: lines (4) The CSV file lines. type( string ) :: most_expensive The most expensive car. real(kind=R8P) :: highest_cost The highest cost. integer :: rows_number The CSV file rows number. integer :: columns_number The CSV file columns number. integer :: c Counter. integer :: r Counter. logical :: test_passed (1) List of passed tests. Source Code program stringifor_test_csv_naive_parser !< StringiFor *csv naive parser* test. !< !< This is an example of the usefulness of StringiFor. use stringifor implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. type ( string ) :: lines ( 4 ) !< The CSV file lines. type ( string ) :: most_expensive !< The most expensive car. real ( R8P ) :: highest_cost !< The highest cost. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: c , r !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . ! a cars database lines ( 1 ) = 'Year,Make,Model,Description,Price' lines ( 2 ) = '1997,Ford,E350,ac abs moon,3000.00' lines ( 3 ) = '1999,Chevy,Venture \"Extended Edition\", ,4900.00' lines ( 4 ) = '1999,Chevy,Venture \"Extended Edition Very Large\", ,5000.00' ! preparing a CSV file test call write_file ( file = 'file_test_temp.csv' , lines = lines ) ! parsing the just created CSV file call csv % read_file ( file = 'file_test_temp.csv' ) ! read the CSV file as a single stream call csv % split ( tokens = rows , sep = new_line ( 'a' )) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! eliminating the file open ( newunit = r , file = 'file_test_temp.csv' ) ; close ( unit = r , status = 'DELETE' ) ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' do c = 1 , columns_number columns ( c ) = '----' ! re-use columns for printing separators enddo print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' ! find the most expensive car print \"(A)\" , 'Searching for the most expensive car' most_expensive = 'unknown' highest_cost = - 1._R8P do r = 2 , rows_number if ( cells ( 5 , r )% to_number ( kind = 1._R8P ) >= highest_cost ) then highest_cost = cells ( 5 , r )% to_number ( kind = 1._R8P ) most_expensive = csv % join ( array = [ cells ( 2 , r ), cells ( 3 , r )], sep = ' ' ) endif enddo test_passed ( 1 ) = most_expensive // '' == 'Chevy Venture \"Extended Edition Very Large\"' print \"(A,L1)\" , 'The most expensive car is : ' // most_expensive // ', is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram stringifor_test_csv_naive_parser","tags":"","loc":"program/stringifor_test_csv_naive_parser.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~103~~UsesGraph program~volatile_doctest~103 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~103->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~103~~CallsGraph program~volatile_doctest~103 volatile_doctest none~glob string%glob program~volatile_doctest~103->none~glob proc~tempname string%tempname program~volatile_doctest~103->proc~tempname proc~glob_character string%glob_character none~glob->proc~glob_character proc~glob_string string%glob_string none~glob->proc~glob_string proc~glob_character->none~glob proc~chars string%chars proc~glob_character->proc~chars proc~glob_string->proc~tempname proc~read_file~2 string%read_file proc~glob_string->proc~read_file~2 proc~split string%split proc~glob_string->proc~split proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~upper string%upper proc~read_file~2->proc~upper proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~replace string%replace proc~unique->proc~replace proc~read_line->proc~chars proc~read_line->proc~upper proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: alist_str (:) integer, parameter :: Nf = 5 character(len=14) :: files (1:Nf) integer :: file_unit integer :: f integer :: ff logical :: test_passed Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str print '(L1)' , test_passed endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~103.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~104~~UsesGraph program~volatile_doctest~104 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~104->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~104~~CallsGraph program~volatile_doctest~104 volatile_doctest none~insert string%insert program~volatile_doctest~104->none~insert proc~insert_character string%insert_character none~insert->proc~insert_character proc~insert_string string%insert_string none~insert->proc~insert_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 5 ) astring = 'this is string example wow!!!' acharacter = '... ' test_passed ( 1 ) = astring % insert ( substring = acharacter , pos = 1 ) // '' == '... this is string example wow!!!' test_passed ( 2 ) = astring % insert ( substring = acharacter , pos = 23 ) // '' == 'this is string example...  wow!!!' test_passed ( 3 ) = astring % insert ( substring = acharacter , pos = 29 ) // '' == 'this is string example wow!!!... ' test_passed ( 4 ) = astring % insert ( substring = acharacter , pos =- 1 ) // '' == '... this is string example wow!!!' test_passed ( 5 ) = astring % insert ( substring = acharacter , pos = 100 ) // '' == 'this is string example wow!!!... ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~104.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~105~~UsesGraph program~volatile_doctest~105 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~105->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~105~~CallsGraph program~volatile_doctest~105 volatile_doctest proc~end_with string%end_with program~volatile_doctest~105->proc~end_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 5 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . test_passed ( 2 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . test_passed ( 3 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . test_passed ( 4 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . test_passed ( 5 ) = astring % end_with ( suffix = '!' ). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~105.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~106~~UsesGraph program~volatile_doctest~106 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~106->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % scan ( set = 'llo' ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = 'llo' , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~106.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~107~~UsesGraph program~volatile_doctest~107 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~107->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~107~~CallsGraph program~volatile_doctest~107 volatile_doctest proc~chars string%chars program~volatile_doctest~107->proc~chars proc~read_file~2 string%read_file program~volatile_doctest~107->proc~read_file~2 proc~split string%split program~volatile_doctest~107->proc~split proc~read_file~2->proc~chars proc~read_lines~2 string%read_lines proc~read_file~2->proc~read_lines~2 proc~upper string%upper proc~read_file~2->proc~upper proc~partition string%partition proc~split->proc~partition proc~unique string%unique proc~split->proc~unique proc~read_line string%read_line proc~read_lines~2->proc~read_line proc~replace string%replace proc~unique->proc~replace proc~read_line->proc~chars proc~read_line->proc~upper proc~replace_one_occurrence string%replace_one_occurrence proc~replace->proc~replace_one_occurrence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (9) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 9 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) call astring % read_file ( file = 'read_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat ) test_passed ( 9 ) = ( iostat /= 0 ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~107.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~108~~UsesGraph program~volatile_doctest~108 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~108->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~108~~CallsGraph program~volatile_doctest~108 volatile_doctest proc~strip string%strip program~volatile_doctest~108->proc~strip Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = '  Hello World!   ' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~108.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~109~~UsesGraph program~volatile_doctest~109 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~109->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~109~~CallsGraph program~volatile_doctest~109 volatile_doctest proc~reverse string%reverse program~volatile_doctest~109->proc~reverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = 'abcdefghilmnopqrstuvz' test_passed ( 1 ) = ( astring % reverse () // '' == 'zvutsrqponmlihgfedcba' ) astring = '0123456789' test_passed ( 2 ) = ( astring % reverse () // '' == '9876543210' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~109.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~110~~UsesGraph program~volatile_doctest~110 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~110->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 3 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring <= anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring <= anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'ONE' test_passed ( 3 ) = (( astring <= anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~110.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~111~~UsesGraph program~volatile_doctest~111 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~111->module~stringifor_string_t befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env penf penf module~stringifor_string_t->penf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~volatile_doctest~111~~CallsGraph program~volatile_doctest~111 volatile_doctest proc~chars string%chars program~volatile_doctest~111->proc~chars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring type( string ) :: yetanotherstring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring type ( string ) :: yetanotherstring logical :: test_passed ( 1 ) astring = 'Hello ' anotherstring = 'Bye bye' yetanotherstring = astring . cat . anotherstring test_passed ( 1 ) = yetanotherstring % chars () == 'Hello Bye bye' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~111.html"},{"title":"stringifor_string_t-doctest-70.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-70.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-70.f90 stringifor_string_t-doctest-70.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-70.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-70.f90.html"},{"title":"stringifor_string_t-doctest-53.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-53.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-53.f90 stringifor_string_t-doctest-53.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-53.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % startcase () // '' == 'The Quick Brown Fox Jumps Over The Lazy Dog.' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-53.f90.html"},{"title":"stringifor_string_t-doctest-102.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-102.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-102.f90 stringifor_string_t-doctest-102.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-102.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring <= acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring <= acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( astring <= acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-102.f90.html"},{"title":"stringifor_string_t-doctest-74.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-74.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-74.f90 stringifor_string_t-doctest-74.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-74.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 6 ) astring = '   -1212112.d0 ' test_passed ( 1 ) = astring % is_real (). eqv .. true . astring = '   -1212112.d0' test_passed ( 2 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . astring = '-1212112.d0   ' test_passed ( 3 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . astring = '+2.e20' test_passed ( 4 ) = astring % is_real (). eqv .. true . astring = ' -2.01E13 ' test_passed ( 5 ) = astring % is_real (). eqv .. true . astring = ' -2.01 E13 ' test_passed ( 6 ) = astring % is_real (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-74.f90.html"},{"title":"stringifor_string_t-doctest-22.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-22.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-22.f90 stringifor_string_t-doctest-22.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-22.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % verify ( set = 'llo' ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = 'llo' , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-22.f90.html"},{"title":"stringifor_string_t-doctest-66.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-66.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-66.f90 stringifor_string_t-doctest-66.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-66.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-66.f90.html"},{"title":"stringifor_string_t-doctest-33.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-33.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-33.f90 stringifor_string_t-doctest-33.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-33.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'this is string example....wow!!!' test_passed ( 1 ) = astring % fill ( width = 40 ) // '' == '00000000this is string example....wow!!!' test_passed ( 2 ) = astring % fill ( width = 50 ) // '' == '000000000000000000this is string example....wow!!!' test_passed ( 3 ) = astring % fill ( width = 50 , right = . true .) // '' == 'this is string example....wow!!!000000000000000000' test_passed ( 4 ) = astring % fill ( width = 40 , filling_char = '*' ) // '' == '********this is string example....wow!!!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-33.f90.html"},{"title":"stringifor_string_t-doctest-13.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-13.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-13.f90 stringifor_string_t-doctest-13.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-13.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % index ( substring = 'llo' ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = 'llo' , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-13.f90.html"},{"title":"stringifor_string_t-doctest-8.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-8.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-8.f90 stringifor_string_t-doctest-8.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-8.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'ell' test_passed ( 1 ) = verify ( s = 'Hello World Hello!' , set = string1 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = verify ( s = 'Hello World Hello!' , set = string1 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-8.f90.html"},{"title":"stringifor_string_t-doctest-108.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-108.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-108.f90 stringifor_string_t-doctest-108.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-108.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring > acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring > acharacter ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-108.f90.html"},{"title":"stringifor_string_t-doctest-95.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-95.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-95.f90 stringifor_string_t-doctest-95.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-95.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = '  one ' anotherstring = 'two' test_passed ( 1 ) = (( astring /= anotherstring ). eqv .. true .) astring = 'the same ' anotherstring = 'the same ' test_passed ( 2 ) = (( astring /= anotherstring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-95.f90.html"},{"title":"stringifor_string_t-doctest-107.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-107.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-107.f90 stringifor_string_t-doctest-107.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-107.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring > anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring > anotherstring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-107.f90.html"},{"title":"stringifor_string_t-doctest-21.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-21.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-21.f90 stringifor_string_t-doctest-21.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-21.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % verify ( set = string2 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = string2 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-21.f90.html"},{"title":"stringifor_string_t-doctest-106.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-106.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-106.f90 stringifor_string_t-doctest-106.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-106.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter >= astring ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter >= astring ). eqv .. true .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( acharacter >= astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-106.f90.html"},{"title":"stringifor_string_t-doctest-45.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-45.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-45.f90 stringifor_string_t-doctest-45.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-45.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) call astring % read_lines ( unit = scratch , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo close ( scratch ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-45.f90.html"},{"title":"stringifor_string_t-doctest-30.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-30.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-30.f90 stringifor_string_t-doctest-30.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-30.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'How are you?' print '(L1)' , astring % encode ( codec = 'base64' ) // '' == 'SG93IGFyZSB5b3U/' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-30.f90.html"},{"title":"stringifor-doctest-2.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor-doctest-2.f90~~EfferentGraph sourcefile~stringifor-doctest-2.f90 stringifor-doctest-2.f90 sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor-doctest-2.f90->sourcefile~stringifor.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor type ( string ) :: astring type ( string ) :: anotherstring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) call write_file ( file = 'write_file_test.tmp' , lines = line , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo call write_file ( file = 'write_file_test.tmp' , lines = line , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( scratch , status = 'DELETE' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor-doctest-2.f90.html"},{"title":"stringifor_string_t-doctest-25.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-25.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-25.f90 stringifor_string_t-doctest-25.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-25.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'caMeL caSe var' print '(L1)' , astring % camelcase () // '' == 'CamelCaseVar' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-25.f90.html"},{"title":"stringifor_string_t-doctest-56.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-56.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-56.f90 stringifor_string_t-doctest-56.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-56.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: tmpname logical :: test_passed ( 5 ) tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 1 )) test_passed ( 1 ) = . not . test_passed ( 1 ) tmpname = astring % tempname ( is_file = . false .) inquire ( file = tmpname , exist = test_passed ( 2 )) test_passed ( 2 ) = . not . test_passed ( 2 ) tmpname = astring % tempname ( path = './' ) inquire ( file = tmpname , exist = test_passed ( 3 )) test_passed ( 3 ) = . not . test_passed ( 3 ) astring = 'me-' tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 4 )) test_passed ( 4 ) = . not . test_passed ( 4 ) tmpname = astring % tempname ( prefix = 'you-' ) inquire ( file = tmpname , exist = test_passed ( 5 )) test_passed ( 5 ) = . not . test_passed ( 5 ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-56.f90.html"},{"title":"stringifor_test_parse_large_csv.f90 – StringiFor","text":"StringiFor csv_naive_parser test. This file depends on sourcefile~~stringifor_test_parse_large_csv.f90~~EfferentGraph sourcefile~stringifor_test_parse_large_csv.f90 stringifor_test_parse_large_csv.f90 sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor_test_parse_large_csv.f90->sourcefile~stringifor.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< StringiFor `csv_naive_parser` test. program stringifor_test_parse_large_csv !< StringiFor `csv_naive_parser` test. use stringifor implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: c , r !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . call csv % read_file ( file = 'src/tests/stringifor/stringifor_test_parse_large_csv.csv' , is_fast = . true .) call csv % split_chunked ( tokens = rows , sep = new_line ( 'a' ), chunks = 10 ) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' do c = 1 , columns_number columns ( c ) = '----' ! re-use columns for printing separators enddo print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' test_passed = . true . print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram stringifor_test_parse_large_csv","tags":"","loc":"sourcefile/stringifor_test_parse_large_csv.f90.html"},{"title":"stringifor_string_t-doctest-41.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-41.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-41.f90 stringifor_string_t-doctest-41.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-41.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % lower () // '' == 'hello world!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-41.f90.html"},{"title":"stringifor_string_t-doctest-78.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-78.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-78.f90 stringifor_string_t-doctest-78.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-78.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'hello' test_passed ( 1 ) = astring % chars () == 'hello' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-78.f90.html"},{"title":"stringifor_string_t-doctest-32.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-32.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-32.f90 stringifor_string_t-doctest-32.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-32.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = '/bar/foo.tar.bz2' print '(L1)' , astring % extension () // '' == '.bz2' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-32.f90.html"},{"title":"stringifor_string_t-doctest-51.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-51.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-51.f90 stringifor_string_t-doctest-51.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-51.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) logical :: test_passed ( 11 ) astring = '+ab-++cre-++cre-ab+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'ab-++cre-++cre-ab+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'ab-++cre-++cre-ab' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'Hello ' // new_line ( 'a' ) // 'World!' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) astring = 'Hello World!' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) astring = '+ab-' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 6 ) = ( strings ( 1 ) // '' == 'ab-' ) astring = '+ab-' call astring % split ( tokens = strings , sep = '-' ) test_passed ( 7 ) = ( strings ( 1 ) // '' == '+ab' ) astring = '+ab-+cd-' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 8 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = 'ab-+cd-+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 9 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = '+ab-+cd-+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 10 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = '1-2-3-4-5-6-7-8' call astring % split ( tokens = strings , sep = '-' , max_tokens = 3 ) test_passed ( 11 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4-5-6-7-8' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-51.f90.html"},{"title":"stringifor_string_t-doctest-92.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-92.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-92.f90 stringifor_string_t-doctest-92.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-92.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = '  one ' anotherstring = 'two' test_passed ( 1 ) = (( astring == anotherstring ). eqv .. false .) astring = 'the same ' anotherstring = 'the same ' test_passed ( 2 ) = (( astring == anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-92.f90.html"},{"title":"stringifor_string_t-doctest-57.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-57.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-57.f90 stringifor_string_t-doctest-57.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-57.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I1P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I1P ) test_passed ( 1 ) = integer_ == 127_I1P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-57.f90.html"},{"title":"stringifor_string_t-doctest-105.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-105.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-105.f90 stringifor_string_t-doctest-105.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-105.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring >= acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring >= acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( astring >= acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-105.f90.html"},{"title":"stringifor_string_t-doctest-98.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-98.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-98.f90 stringifor_string_t-doctest-98.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-98.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring < anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring < anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-98.f90.html"},{"title":"stringifor_string_t-doctest-100.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-100.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-100.f90 stringifor_string_t-doctest-100.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-100.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter < astring ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter < astring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-100.f90.html"},{"title":"stringifor_string_t-doctest-55.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-55.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-55.f90 stringifor_string_t-doctest-55.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-55.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = '  Hello World!   ' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-55.f90.html"},{"title":"stringifor_string_t-doctest-60.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-60.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-60.f90 stringifor_string_t-doctest-60.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-60.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I8P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I8P ) test_passed ( 1 ) = integer_ == 127_I8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-60.f90.html"},{"title":"stringifor_string_t-doctest-73.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-73.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-73.f90 stringifor_string_t-doctest-73.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-73.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 7 ) astring = '   -1212112 ' test_passed ( 1 ) = astring % is_number (). eqv .. true . astring = '   -121.2112 ' test_passed ( 2 ) = astring % is_number (). eqv .. true . astring = '   -1212112' test_passed ( 3 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . astring = '-12121.12   ' test_passed ( 4 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . astring = '+2e20' test_passed ( 5 ) = astring % is_number (). eqv .. true . astring = ' -2.4E13 ' test_passed ( 6 ) = astring % is_number (). eqv .. true . astring = ' -2 E13 ' test_passed ( 7 ) = astring % is_number (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-73.f90.html"},{"title":"stringifor_string_t-doctest-29.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-29.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-29.f90 stringifor_string_t-doctest-29.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-29.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'SG93IGFyZSB5b3U/' print '(L1)' , astring % decode ( codec = 'base64' ) // '' == 'How are you?' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-29.f90.html"},{"title":"stringifor_string_t-doctest-87.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-87.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-87.f90 stringifor_string_t-doctest-87.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-87.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' test_passed ( 1 ) = astring // acharacter == 'Hello World!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-87.f90.html"},{"title":"stringifor_string_t-doctest-85.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-85.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-85.f90 stringifor_string_t-doctest-85.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-85.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R8P test_passed ( 1 ) = astring % to_number ( kind = 1._R8P ) == 3.021e6_R8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-85.f90.html"},{"title":"stringifor_string_t-doctest-84.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-84.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-84.f90 stringifor_string_t-doctest-84.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-84.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R8P test_passed ( 1 ) = astring % to_number ( kind = 1._R8P ) == 3.021e6_R8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-84.f90.html"},{"title":"stringifor_string_t-doctest-2.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-2.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-2.f90 stringifor_string_t-doctest-2.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-2.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t print \"(L1)\" , string ( 'Hello World' ) // '' == 'Hello World' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-2.f90.html"},{"title":"stringifor_string_t-doctest-94.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-94.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-94.f90 stringifor_string_t-doctest-94.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-94.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( acharacter == astring ). eqv .. false .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( acharacter == astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-94.f90.html"},{"title":"stringifor_string_t-doctest-7.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-7.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-7.f90 stringifor_string_t-doctest-7.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-7.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = scan ( s = 'Hello World Hello!' , set = string1 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = scan ( s = 'Hello World Hello!' , set = string1 , back = . true .) == scan ( string = 'Hello World Hello!' , & set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-7.f90.html"},{"title":"stringifor_string_t-doctest-17.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-17.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-17.f90 stringifor_string_t-doctest-17.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-17.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'y' print \"(L1)\" , astring % repeat ( 'x' , 5 ) // '' == 'xxxxx' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-17.f90.html"},{"title":"stringifor_string_t-doctest-75.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-75.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-75.f90 stringifor_string_t-doctest-75.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-75.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 3 ) astring = ' Hello World' test_passed ( 1 ) = astring % is_upper (). eqv .. false . astring = ' HELLO WORLD' test_passed ( 2 ) = astring % is_upper (). eqv .. true . astring = ' hello world' test_passed ( 3 ) = astring % is_upper (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-75.f90.html"},{"title":"stringifor_string_t-doctest-65.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-65.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-65.f90 stringifor_string_t-doctest-65.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-65.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = '+++ab-++cre-++cre-ab+++++' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-65.f90.html"},{"title":"stringifor_string_t-doctest-10.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-10.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-10.f90 stringifor_string_t-doctest-10.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-10.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % adjustr () // '' == '   Hello World!' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-10.f90.html"},{"title":"stringifor_string_t-doctest-6.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-6.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-6.f90 stringifor_string_t-doctest-6.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-6.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = index ( s = 'Hello World Hello!' , substring = string1 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = index ( s = 'Hello World Hello!' , substring = string1 , back = . true .) == index ( string = 'Hello World Hello!' , & substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-6.f90.html"},{"title":"stringifor_string_t-doctest-67.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-67.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-67.f90 stringifor_string_t-doctest-67.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-67.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) call anotherstring % write_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo call anotherstring % write_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( unit = scratch , status = 'delete' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-67.f90.html"},{"title":"stringifor_string_t-doctest-93.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-93.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-93.f90 stringifor_string_t-doctest-93.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-93.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( astring == acharacter ). eqv .. false .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( astring == acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-93.f90.html"},{"title":"stringifor_string_t-doctest-38.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-38.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-38.f90 stringifor_string_t-doctest-38.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-38.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 5 ) astring = 'this is string example wow!!!' anotherstring = '... ' test_passed ( 1 ) = astring % insert ( substring = anotherstring , pos = 1 ) // '' == '... this is string example wow!!!' test_passed ( 2 ) = astring % insert ( substring = anotherstring , pos = 23 ) // '' == 'this is string example...  wow!!!' test_passed ( 3 ) = astring % insert ( substring = anotherstring , pos = 29 ) // '' == 'this is string example wow!!!... ' test_passed ( 4 ) = astring % insert ( substring = anotherstring , pos =- 1 ) // '' == '... this is string example wow!!!' test_passed ( 5 ) = astring % insert ( substring = anotherstring , pos = 100 ) // '' == 'this is string example wow!!!... ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-38.f90.html"},{"title":"stringifor_string_t-doctest-11.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-11.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-11.f90 stringifor_string_t-doctest-11.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-11.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 4 ) astring = '   Hello World  !    ' test_passed ( 1 ) = astring % count ( substring = ' ' ) == 10 astring = 'Hello World  !    ' test_passed ( 2 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 6 astring = '    Hello World  !' test_passed ( 3 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 6 astring = '   Hello World  !    ' test_passed ( 4 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 8 print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-11.f90.html"},{"title":"stringifor_string_t-doctest-12.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-12.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-12.f90 stringifor_string_t-doctest-12.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-12.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % index ( substring = string2 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = string2 , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-12.f90.html"},{"title":"stringifor_string_t-doctest-61.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-61.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-61.f90 stringifor_string_t-doctest-61.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-61.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring real ( R4P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R4P ) test_passed ( 1 ) = real_ == 3.4e9_R4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-61.f90.html"},{"title":"stringifor_string_t-doctest-90.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-90.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-90.f90 stringifor_string_t-doctest-90.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-90.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: yetanotherstring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' yetanotherstring = astring . cat . acharacter test_passed ( 1 ) = yetanotherstring % chars () == 'Hello World!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-90.f90.html"},{"title":"stringifor_string_t-doctest-62.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-62.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-62.f90 stringifor_string_t-doctest-62.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-62.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring real ( R8P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R8P ) test_passed ( 1 ) = real_ == 3.4e9_R8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-62.f90.html"},{"title":"stringifor_string_t-doctest-81.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-81.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-81.f90 stringifor_string_t-doctest-81.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-81.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I4P test_passed ( 1 ) = astring % to_number ( kind = 1_I4P ) == 127_I4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-81.f90.html"},{"title":"stringifor_string_t-doctest-3.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-3.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-3.f90 stringifor_string_t-doctest-3.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-3.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , adjustl ( astring ) == 'Hello World!   ' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-3.f90.html"},{"title":"stringifor-doctest-1.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor-doctest-1.f90~~EfferentGraph sourcefile~stringifor-doctest-1.f90 stringifor-doctest-1.f90 sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor-doctest-1.f90->sourcefile~stringifor.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) call read_file ( file = 'read_file_test.tmp' , lines = strings , iostat = iostat , iomsg = iomsg ) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) call read_file ( file = 'read_file_test.tmp' , lines = strings , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor-doctest-1.f90.html"},{"title":"stringifor_string_t-doctest-15.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-15.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-15.f90 stringifor_string_t-doctest-15.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-15.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len_trim () == len_trim ( 'Hello World!   ' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-15.f90.html"},{"title":"stringifor_string_t-doctest-5.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-5.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-5.f90 stringifor_string_t-doctest-5.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-5.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t print \"(L1)\" , count ( 'hello' , substring = 'll' ) == 1 endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-5.f90.html"},{"title":"stringifor_string_t-doctest-39.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-39.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-39.f90 stringifor_string_t-doctest-39.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-39.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: strings ( 3 ) logical :: test_passed ( 5 ) strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 1 ) = ( astring % join ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) test_passed ( 2 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 3 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free test_passed ( 4 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' test_passed ( 5 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-39.f90.html"},{"title":"stringifor_string_t-doctest-16.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-16.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-16.f90 stringifor_string_t-doctest-16.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-16.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'x' print \"(L1)\" , astring % repeat ( 5 ) // '' == 'xxxxx' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-16.f90.html"},{"title":"stringifor_string_t-doctest-14.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-14.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-14.f90 stringifor_string_t-doctest-14.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-14.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len () == len ( 'Hello World!   ' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-14.f90.html"},{"title":"stringifor_string_t-doctest-71.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-71.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-71.f90 stringifor_string_t-doctest-71.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-71.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 6 ) astring = '   -1212112 ' test_passed ( 1 ) = astring % is_integer (). eqv .. true . astring = '   -1212112' test_passed ( 2 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . astring = '-1212112   ' test_passed ( 3 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . astring = '+2e20' test_passed ( 4 ) = astring % is_integer (). eqv .. true . astring = ' -2E13 ' test_passed ( 5 ) = astring % is_integer (). eqv .. true . astring = ' -2 E13 ' test_passed ( 6 ) = astring % is_integer (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-71.f90.html"},{"title":"stringifor_string_t-doctest-40.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-40.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-40.f90 stringifor_string_t-doctest-40.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-40.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( 5 ) :: characters ( 3 ) logical :: test_passed ( 6 ) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 1 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) test_passed ( 2 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 3 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 4 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 5 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' astring = '_' test_passed ( 6 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // '_' // characters ( 2 ) // '_' // characters ( 3 )) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-40.f90.html"},{"title":"stringifor_string_t-doctest-46.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-46.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-46.f90 stringifor_string_t-doctest-46.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-46.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 3 ) astring = 'When YOU are sad YOU should think to me :-)' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) astring = repeat ( new_line ( 'a' ) // 'abcd' , 20 ) astring = astring % replace ( old = new_line ( 'a' ), new = '|cr|' ) astring = astring % replace ( old = '|cr|' , new = new_line ( 'a' ) // '    ' ) test_passed ( 3 ) = ( astring // '' == repeat ( new_line ( 'a' ) // '    ' // 'abcd' , 20 )) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-46.f90.html"},{"title":"stringifor_string_t-doctest-31.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-31.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-31.f90 stringifor_string_t-doctest-31.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-31.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = '&#94;\\s \\d+\\s*' test_passed ( 1 ) = astring % escape ( to_escape = '\\')//''==' &#94;\\\\ s \\\\ d + \\\\ s * ' test_passed(2) = astring%escape(to_escape=' \\ ', esc=' | ')//''==' &#94;|\\ s |\\ d + |\\ s * ' print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-31.f90.html"},{"title":"stringifor_string_t-doctest-58.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-58.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-58.f90 stringifor_string_t-doctest-58.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-58.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I2P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I2P ) test_passed ( 1 ) = integer_ == 127_I2P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-58.f90.html"},{"title":"stringifor_string_t-doctest-109.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-109.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-109.f90 stringifor_string_t-doctest-109.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-109.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter > astring ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter > astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-109.f90.html"},{"title":"stringifor_string_t-doctest-64.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-64.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-64.f90 stringifor_string_t-doctest-64.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-64.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = '&#94;\\\\s \\\\d+\\\\s*' test_passed ( 1 ) = ( astring % unescape ( to_unescape = '\\')//''==' &#94;\\ s \\ d + \\ s * ') test_passed(2) = (astring%unescape(to_unescape=' s ')//''==' &#94;\\ s \\\\ d + \\ s * ') print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-64.f90.html"},{"title":"stringifor_string_t-doctest-103.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-103.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-103.f90 stringifor_string_t-doctest-103.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-103.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter <= astring ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter <= astring ). eqv .. false .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( acharacter <= astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-103.f90.html"},{"title":"stringifor_string_t-doctest-27.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-27.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-27.f90 stringifor_string_t-doctest-27.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-27.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % chars () == 'say all Hello WorLD!' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-27.f90.html"},{"title":"stringifor_string_t-doctest-48.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-48.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-48.f90 stringifor_string_t-doctest-48.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-48.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring character ( len = :), allocatable :: acharacter integer :: istart integer :: iend logical :: test_passed ( 5 ) astring = '<test> <first> hello </first> <first> not the first </first> </test>' anotherstring = astring % search ( tag_start = '<first>' , tag_end = '</first>' ) test_passed ( 1 ) = anotherstring // '' == '<first> hello </first>' astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' anotherstring = astring % search ( tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 2 ) = anotherstring // '' == '<a> <a> <a> the nested a </a> </a> </a>' call astring % free anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_string = anotherstring , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 3 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' call astring % free acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 4 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<sec>' , tag_end = '</sec>' , istart = istart , iend = iend ) test_passed ( 5 ) = astring // '' == acharacter ( 31 : 67 ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-48.f90.html"},{"title":"stringifor_string_t-doctest-18.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-18.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-18.f90 stringifor_string_t-doctest-18.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-18.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % scan ( set = string2 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = string2 , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-18.f90.html"},{"title":"stringifor_string_t-doctest-82.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-82.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-82.f90 stringifor_string_t-doctest-82.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-82.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I8P test_passed ( 1 ) = astring % to_number ( kind = 1_I8P ) == 127_I8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-82.f90.html"},{"title":"stringifor_string_t-doctest-91.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-91.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-91.f90 stringifor_string_t-doctest-91.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-91.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: yetanotherstring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' yetanotherstring = acharacter . cat . astring test_passed ( 1 ) = yetanotherstring % chars () == 'World!Hello ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-91.f90.html"},{"title":"stringifor_string_t-doctest-96.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-96.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-96.f90 stringifor_string_t-doctest-96.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-96.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( astring /= acharacter ). eqv .. true .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( astring /= acharacter ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-96.f90.html"},{"title":"stringifor_string_t-doctest-83.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-83.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-83.f90 stringifor_string_t-doctest-83.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-83.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R4P test_passed ( 1 ) = astring % to_number ( kind = 1._R4P ) == 3.021e6_R4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-83.f90.html"},{"title":"stringifor_string_t-doctest-52.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-52.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-52.f90 stringifor_string_t-doctest-52.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-52.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) logical :: test_passed ( 1 ) astring = '-1-2-3-4-5-6-7-8-' call astring % split_chunked ( tokens = strings , sep = '-' , chunks = 3 ) test_passed ( 1 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4' . and . & strings ( 5 ) // '' == '5' . and . strings ( 6 ) // '' == '6' . and . strings ( 7 ) // '' == '7' . and . strings ( 8 ) // '' == '8' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-52.f90.html"},{"title":"stringifor_string_t-doctest-59.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-59.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-59.f90 stringifor_string_t-doctest-59.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-59.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I4P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I4P ) test_passed ( 1 ) = integer_ == 127_I4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-59.f90.html"},{"title":"stringifor_string_t-doctest-104.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-104.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-104.f90 stringifor_string_t-doctest-104.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-104.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 3 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring >= anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring >= anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'ONE' test_passed ( 3 ) = (( astring >= anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-104.f90.html"},{"title":"stringifor_string_t-doctest-86.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-86.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-86.f90 stringifor_string_t-doctest-86.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-86.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 1 ) astring = 'Hello ' anotherstring = 'Bye bye' test_passed ( 1 ) = astring // anotherstring == 'Hello Bye bye' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-86.f90.html"},{"title":"stringifor_string_t-doctest-79.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-79.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-79.f90 stringifor_string_t-doctest-79.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-79.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I1P test_passed ( 1 ) = astring % to_number ( kind = 1_I1P ) == 127_I1P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-79.f90.html"},{"title":"stringifor_string_t-doctest-34.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-34.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-34.f90 stringifor_string_t-doctest-34.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-34.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'this is string example....wow!!!' call astring % free print '(L1)' , astring % is_allocated (). eqv .. false . endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-34.f90.html"},{"title":"stringifor_string_t-doctest-26.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-26.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-26.f90 stringifor_string_t-doctest-26.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-26.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % capitalize () // '' == 'Say all hello world!' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-26.f90.html"},{"title":"stringifor_string_t-doctest-35.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-35.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-35.f90 stringifor_string_t-doctest-35.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-35.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_chr ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr print '(L1)' , test_passed endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-35.f90.html"},{"title":"stringifor_string_t-doctest-63.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-63.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-63.f90 stringifor_string_t-doctest-63.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-63.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring real ( R16P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R16P ) test_passed ( 1 ) = real_ == 3.4e9_R16P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-63.f90.html"},{"title":"stringifor_string_t-doctest-72.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-72.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-72.f90 stringifor_string_t-doctest-72.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-72.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 3 ) astring = ' Hello World' test_passed ( 1 ) = astring % is_lower (). eqv .. false . astring = ' HELLO WORLD' test_passed ( 2 ) = astring % is_lower (). eqv .. false . astring = ' hello world' test_passed ( 3 ) = astring % is_lower (). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-72.f90.html"},{"title":"stringifor.F90 – StringiFor","text":"StringiFor, Strings Fortran Manipulator with steroids. This file depends on sourcefile~~stringifor.f90~~EfferentGraph sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~stringifor.f90~~AfferentGraph sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor-doctest-1.f90 stringifor-doctest-1.f90 sourcefile~stringifor-doctest-1.f90->sourcefile~stringifor.f90 sourcefile~stringifor-doctest-2.f90 stringifor-doctest-2.f90 sourcefile~stringifor-doctest-2.f90->sourcefile~stringifor.f90 sourcefile~stringifor_test_csv_naive_parser.f90 stringifor_test_csv_naive_parser.f90 sourcefile~stringifor_test_csv_naive_parser.f90->sourcefile~stringifor.f90 sourcefile~stringifor_test_parse_large_csv.f90 stringifor_test_parse_large_csv.f90 sourcefile~stringifor_test_parse_large_csv.f90->sourcefile~stringifor.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< StringiFor, Strings Fortran Manipulator with steroids. module stringifor !< StringiFor, Strings Fortran Manipulator with steroids. use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P ! use stringifor_string_t, only : adjustl, adjustr, count, index, len, len_trim, repeat, scan, trim, verify, CK, string use stringifor_string_t , only : adjustl , adjustr , count , index , len_trim , repeat , scan , trim , verify , CK , glob , string , strjoin implicit none private save ! expose StingiFor objects public :: CK public :: glob public :: strjoin public :: string ! expose StingiFor overloaded builtins and operators ! public :: adjustl, adjustr, count, index, len, len_trim, repeat, scan, trim, verify public :: adjustl , adjustr , count , index , len_trim , repeat , scan , trim , verify ! expose StingiFor new procedures public :: read_file , read_lines , write_file , write_lines ! expose PENF kinds public :: I1P , I2P , I4P , I8P , R4P , R8P , R16P contains subroutine read_file ( file , lines , form , iostat , iomsg ) !< Read a file as a single string stream. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, file='read_file_test.tmp') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< close(scratch) !< call read_file(file='read_file_test.tmp', lines=strings, iostat=iostat, iomsg=iomsg) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< close(scratch) !< call read_file(file='read_file_test.tmp', lines=strings, form='unformatted', iostat=iostat, iomsg=iomsg) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< close(scratch, status='DELETE') !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call read_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_file subroutine read_lines ( unit , lines , form , iostat , iomsg ) !< Read lines (records) from a connected-formatted unit. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !< @note There is no doctests, this being tested by means of [[read_file]] doctests. integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = 1 ) :: ch !< Character storage. integer :: l !< Counter. form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) select case ( form_ % chars ()) case ( 'FORMATTED' ) l = 0 do read ( unit , * , err = 10 , end = 10 ) l = l + 1 enddo case ( 'UNFORMATTED' ) l = 0 do read ( unit , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) l = l + 1 enddo endselect 10 rewind ( unit ) if ( l > 0 ) then allocate ( lines ( 1 : l )) l = 1 iostat_ = 0 do call lines ( l )% read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if (( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )). or .( l >= size ( lines , dim = 1 ))) then exit endif l = l + 1 enddo endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_lines subroutine write_file ( file , lines , form , iostat , iomsg ) !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string)              :: anotherstring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< anotherstring = anotherstring%join(array=line, sep=new_line('a')) !< call write_file(file='write_file_test.tmp', lines=line, iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< call write_file(file='write_file_test.tmp', lines=line, form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='write_file_test.tmp') !< close(scratch, status='DELETE') !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call write_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_file subroutine write_lines ( unit , lines , form , iostat , iomsg ) !< Write lines (records) to a connected-formatted unit. !< !< @note There is no doctests, this being tested by means of [[write_file]] doctests. integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: l !< Counter. do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endsubroutine write_lines endmodule stringifor","tags":"","loc":"sourcefile/stringifor.f90.html"},{"title":"stringifor_string_t-doctest-9.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-9.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-9.f90 stringifor_string_t-doctest-9.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-9.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , astring % adjustl () // '' == 'Hello World!   ' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-9.f90.html"},{"title":"stringifor_string_t-doctest-99.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-99.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-99.f90 stringifor_string_t-doctest-99.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-99.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring < acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring < acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-99.f90.html"},{"title":"stringifor_string_t-doctest-44.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-44.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-44.f90 stringifor_string_t-doctest-44.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-44.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 6 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then exit else test_passed ( l ) = ( astring == line ( l )) endif enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg , form = 'UnfORMatteD' ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then exit else test_passed ( l + 3 ) = ( astring == line ( l )) endif enddo close ( scratch ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-44.f90.html"},{"title":"stringifor_string_t-doctest-24.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-24.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-24.f90 stringifor_string_t-doctest-24.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-24.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 5 ) astring = 'bar/foo.tar.bz2' test_passed ( 1 ) = astring % basename () // '' == 'foo.tar.bz2' test_passed ( 2 ) = astring % basename ( extension = '.tar.bz2' ) // '' == 'foo' test_passed ( 3 ) = astring % basename ( strip_last_extension = . true .) // '' == 'foo.tar' astring = '\\bar\\foo.tar.bz2' test_passed ( 4 ) = astring % basename ( sep = '\\')//''==' foo . tar . bz2 ' astring = ' bar ' test_passed(5) = astring%basename(strip_last_extension=.true.)//''==' bar ' print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-24.f90.html"},{"title":"stringifor_string_t-doctest-4.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-4.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-4.f90 stringifor_string_t-doctest-4.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-4.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , adjustr ( astring ) == '   Hello World!' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-4.f90.html"},{"title":"stringifor_string_t-doctest-28.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-28.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-28.f90 stringifor_string_t-doctest-28.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-28.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % colorize ( color_fg = 'red' ) == '\u001b[31msay all Hello WorLD!\u001b[0m' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-28.f90.html"},{"title":"stringifor_string_t-doctest-97.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-97.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-97.f90 stringifor_string_t-doctest-97.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-97.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( acharacter /= astring ). eqv .. true .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( acharacter /= astring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-97.f90.html"},{"title":"stringifor_string_t-doctest-42.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-42.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-42.f90 stringifor_string_t-doctest-42.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-42.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: strings ( 3 ) logical :: test_passed ( 3 ) astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-42.f90.html"},{"title":"stringifor_string_t-doctest-69.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-69.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-69.f90 stringifor_string_t-doctest-69.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-69.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) test_passed ( 1 ) = astring % is_allocated (). eqv .. false . astring = 'hello' test_passed ( 2 ) = astring % is_allocated (). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-69.f90.html"},{"title":"stringifor_string_t-doctest-77.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-77.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-77.f90 stringifor_string_t-doctest-77.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-77.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 1 ) astring = 'hello' anotherstring = astring test_passed ( 1 ) = astring % chars () == anotherstring % chars () print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-77.f90.html"},{"title":"stringifor_string_t-doctest-88.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-88.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-88.f90 stringifor_string_t-doctest-88.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-88.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' test_passed ( 1 ) = acharacter // astring == 'World!Hello ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-88.f90.html"},{"title":"stringifor_string_t-doctest-49.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-49.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-49.f90 stringifor_string_t-doctest-49.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-49.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'the Quick Brown fox Jumps over the Lazy Dog.' print \"(A)\" , astring % slice ( 11 , 25 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-49.f90.html"},{"title":"stringifor_string_t-doctest-20.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-20.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-20.f90 stringifor_string_t-doctest-20.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-20.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % trim () == trim ( 'Hello World!   ' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-20.f90.html"},{"title":"stringifor_string_t-doctest-50.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-50.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-50.f90 stringifor_string_t-doctest-50.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-50.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % snakecase () // '' == 'the_quick_brown_fox_jumps_over_the_lazy_dog.' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-50.f90.html"},{"title":"stringifor_string_t-doctest-23.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-23.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-23.f90 stringifor_string_t-doctest-23.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-23.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 4 ) string1 = '/bar/foo.tar.bz2' test_passed ( 1 ) = string1 % basedir () // '' == '/bar' string1 = './bar/foo.tar.bz2' test_passed ( 2 ) = string1 % basedir () // '' == './bar' string1 = 'bar/foo.tar.bz2' test_passed ( 3 ) = string1 % basedir () // '' == 'bar' string1 = '\\bar\\foo.tar.bz2' test_passed ( 4 ) = string1 % basedir ( sep = '\\')//''==' \\ bar ' print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-23.f90.html"},{"title":"stringifor_string_t-doctest-1.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-1.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-1.f90 stringifor_string_t-doctest-1.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-1.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call glob ( self = astring , pattern = 'foo-*' , list = alist_chr ) call glob ( self = astring , pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr if ( test_passed ) then test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str endif print '(L1)' , test_passed endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-1.f90.html"},{"title":"stringifor_string_t-doctest-80.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-80.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-80.f90 stringifor_string_t-doctest-80.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-80.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I2P test_passed ( 1 ) = astring % to_number ( kind = 1_I2P ) == 127_I2P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-80.f90.html"},{"title":"stringifor_string_t-doctest-76.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-76.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-76.f90 stringifor_string_t-doctest-76.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-76.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-76.f90.html"},{"title":"stringifor_test_csv_naive_parser.f90 – StringiFor","text":"StringiFor csv naive parser test. This file depends on sourcefile~~stringifor_test_csv_naive_parser.f90~~EfferentGraph sourcefile~stringifor_test_csv_naive_parser.f90 stringifor_test_csv_naive_parser.f90 sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor_test_csv_naive_parser.f90->sourcefile~stringifor.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< StringiFor *csv naive parser* test. program stringifor_test_csv_naive_parser !< StringiFor *csv naive parser* test. !< !< This is an example of the usefulness of StringiFor. use stringifor implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. type ( string ) :: lines ( 4 ) !< The CSV file lines. type ( string ) :: most_expensive !< The most expensive car. real ( R8P ) :: highest_cost !< The highest cost. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: c , r !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . ! a cars database lines ( 1 ) = 'Year,Make,Model,Description,Price' lines ( 2 ) = '1997,Ford,E350,ac abs moon,3000.00' lines ( 3 ) = '1999,Chevy,Venture \"Extended Edition\", ,4900.00' lines ( 4 ) = '1999,Chevy,Venture \"Extended Edition Very Large\", ,5000.00' ! preparing a CSV file test call write_file ( file = 'file_test_temp.csv' , lines = lines ) ! parsing the just created CSV file call csv % read_file ( file = 'file_test_temp.csv' ) ! read the CSV file as a single stream call csv % split ( tokens = rows , sep = new_line ( 'a' )) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! eliminating the file open ( newunit = r , file = 'file_test_temp.csv' ) ; close ( unit = r , status = 'DELETE' ) ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' do c = 1 , columns_number columns ( c ) = '----' ! re-use columns for printing separators enddo print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' ! find the most expensive car print \"(A)\" , 'Searching for the most expensive car' most_expensive = 'unknown' highest_cost = - 1._R8P do r = 2 , rows_number if ( cells ( 5 , r )% to_number ( kind = 1._R8P ) >= highest_cost ) then highest_cost = cells ( 5 , r )% to_number ( kind = 1._R8P ) most_expensive = csv % join ( array = [ cells ( 2 , r ), cells ( 3 , r )], sep = ' ' ) endif enddo test_passed ( 1 ) = most_expensive // '' == 'Chevy Venture \"Extended Edition Very Large\"' print \"(A,L1)\" , 'The most expensive car is : ' // most_expensive // ', is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram stringifor_test_csv_naive_parser","tags":"","loc":"sourcefile/stringifor_test_csv_naive_parser.f90.html"},{"title":"stringifor_string_t-doctest-36.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-36.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-36.f90 stringifor_string_t-doctest-36.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-36.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str print '(L1)' , test_passed endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-36.f90.html"},{"title":"stringifor_string_t-doctest-37.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-37.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-37.f90 stringifor_string_t-doctest-37.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-37.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 5 ) astring = 'this is string example wow!!!' acharacter = '... ' test_passed ( 1 ) = astring % insert ( substring = acharacter , pos = 1 ) // '' == '... this is string example wow!!!' test_passed ( 2 ) = astring % insert ( substring = acharacter , pos = 23 ) // '' == 'this is string example...  wow!!!' test_passed ( 3 ) = astring % insert ( substring = acharacter , pos = 29 ) // '' == 'this is string example wow!!!... ' test_passed ( 4 ) = astring % insert ( substring = acharacter , pos =- 1 ) // '' == '... this is string example wow!!!' test_passed ( 5 ) = astring % insert ( substring = acharacter , pos = 100 ) // '' == 'this is string example wow!!!... ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-37.f90.html"},{"title":"stringifor_string_t-doctest-68.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-68.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-68.f90 stringifor_string_t-doctest-68.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-68.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 5 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . test_passed ( 2 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . test_passed ( 3 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . test_passed ( 4 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . test_passed ( 5 ) = astring % end_with ( suffix = '!' ). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-68.f90.html"},{"title":"stringifor_string_t.F90 – StringiFor","text":"StringiFor, definition of string type. Files dependent on this one sourcefile~~stringifor_string_t.f90~~AfferentGraph sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-1.f90 stringifor_string_t-doctest-1.f90 sourcefile~stringifor_string_t-doctest-1.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-10.f90 stringifor_string_t-doctest-10.f90 sourcefile~stringifor_string_t-doctest-10.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-100.f90 stringifor_string_t-doctest-100.f90 sourcefile~stringifor_string_t-doctest-100.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-101.f90 stringifor_string_t-doctest-101.f90 sourcefile~stringifor_string_t-doctest-101.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-102.f90 stringifor_string_t-doctest-102.f90 sourcefile~stringifor_string_t-doctest-102.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-103.f90 stringifor_string_t-doctest-103.f90 sourcefile~stringifor_string_t-doctest-103.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-104.f90 stringifor_string_t-doctest-104.f90 sourcefile~stringifor_string_t-doctest-104.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-105.f90 stringifor_string_t-doctest-105.f90 sourcefile~stringifor_string_t-doctest-105.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-106.f90 stringifor_string_t-doctest-106.f90 sourcefile~stringifor_string_t-doctest-106.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-107.f90 stringifor_string_t-doctest-107.f90 sourcefile~stringifor_string_t-doctest-107.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-108.f90 stringifor_string_t-doctest-108.f90 sourcefile~stringifor_string_t-doctest-108.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-109.f90 stringifor_string_t-doctest-109.f90 sourcefile~stringifor_string_t-doctest-109.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-11.f90 stringifor_string_t-doctest-11.f90 sourcefile~stringifor_string_t-doctest-11.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-12.f90 stringifor_string_t-doctest-12.f90 sourcefile~stringifor_string_t-doctest-12.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-13.f90 stringifor_string_t-doctest-13.f90 sourcefile~stringifor_string_t-doctest-13.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-14.f90 stringifor_string_t-doctest-14.f90 sourcefile~stringifor_string_t-doctest-14.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-15.f90 stringifor_string_t-doctest-15.f90 sourcefile~stringifor_string_t-doctest-15.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-16.f90 stringifor_string_t-doctest-16.f90 sourcefile~stringifor_string_t-doctest-16.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-17.f90 stringifor_string_t-doctest-17.f90 sourcefile~stringifor_string_t-doctest-17.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-18.f90 stringifor_string_t-doctest-18.f90 sourcefile~stringifor_string_t-doctest-18.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-19.f90 stringifor_string_t-doctest-19.f90 sourcefile~stringifor_string_t-doctest-19.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-2.f90 stringifor_string_t-doctest-2.f90 sourcefile~stringifor_string_t-doctest-2.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-20.f90 stringifor_string_t-doctest-20.f90 sourcefile~stringifor_string_t-doctest-20.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-21.f90 stringifor_string_t-doctest-21.f90 sourcefile~stringifor_string_t-doctest-21.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-22.f90 stringifor_string_t-doctest-22.f90 sourcefile~stringifor_string_t-doctest-22.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-23.f90 stringifor_string_t-doctest-23.f90 sourcefile~stringifor_string_t-doctest-23.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-24.f90 stringifor_string_t-doctest-24.f90 sourcefile~stringifor_string_t-doctest-24.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-25.f90 stringifor_string_t-doctest-25.f90 sourcefile~stringifor_string_t-doctest-25.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-26.f90 stringifor_string_t-doctest-26.f90 sourcefile~stringifor_string_t-doctest-26.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-27.f90 stringifor_string_t-doctest-27.f90 sourcefile~stringifor_string_t-doctest-27.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-28.f90 stringifor_string_t-doctest-28.f90 sourcefile~stringifor_string_t-doctest-28.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-29.f90 stringifor_string_t-doctest-29.f90 sourcefile~stringifor_string_t-doctest-29.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-3.f90 stringifor_string_t-doctest-3.f90 sourcefile~stringifor_string_t-doctest-3.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-30.f90 stringifor_string_t-doctest-30.f90 sourcefile~stringifor_string_t-doctest-30.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-31.f90 stringifor_string_t-doctest-31.f90 sourcefile~stringifor_string_t-doctest-31.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-32.f90 stringifor_string_t-doctest-32.f90 sourcefile~stringifor_string_t-doctest-32.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-33.f90 stringifor_string_t-doctest-33.f90 sourcefile~stringifor_string_t-doctest-33.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-34.f90 stringifor_string_t-doctest-34.f90 sourcefile~stringifor_string_t-doctest-34.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-35.f90 stringifor_string_t-doctest-35.f90 sourcefile~stringifor_string_t-doctest-35.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-36.f90 stringifor_string_t-doctest-36.f90 sourcefile~stringifor_string_t-doctest-36.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-37.f90 stringifor_string_t-doctest-37.f90 sourcefile~stringifor_string_t-doctest-37.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-38.f90 stringifor_string_t-doctest-38.f90 sourcefile~stringifor_string_t-doctest-38.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-39.f90 stringifor_string_t-doctest-39.f90 sourcefile~stringifor_string_t-doctest-39.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-4.f90 stringifor_string_t-doctest-4.f90 sourcefile~stringifor_string_t-doctest-4.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-40.f90 stringifor_string_t-doctest-40.f90 sourcefile~stringifor_string_t-doctest-40.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-41.f90 stringifor_string_t-doctest-41.f90 sourcefile~stringifor_string_t-doctest-41.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-42.f90 stringifor_string_t-doctest-42.f90 sourcefile~stringifor_string_t-doctest-42.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-43.f90 stringifor_string_t-doctest-43.f90 sourcefile~stringifor_string_t-doctest-43.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-44.f90 stringifor_string_t-doctest-44.f90 sourcefile~stringifor_string_t-doctest-44.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-45.f90 stringifor_string_t-doctest-45.f90 sourcefile~stringifor_string_t-doctest-45.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-46.f90 stringifor_string_t-doctest-46.f90 sourcefile~stringifor_string_t-doctest-46.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-47.f90 stringifor_string_t-doctest-47.f90 sourcefile~stringifor_string_t-doctest-47.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-48.f90 stringifor_string_t-doctest-48.f90 sourcefile~stringifor_string_t-doctest-48.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-49.f90 stringifor_string_t-doctest-49.f90 sourcefile~stringifor_string_t-doctest-49.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-5.f90 stringifor_string_t-doctest-5.f90 sourcefile~stringifor_string_t-doctest-5.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-50.f90 stringifor_string_t-doctest-50.f90 sourcefile~stringifor_string_t-doctest-50.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-51.f90 stringifor_string_t-doctest-51.f90 sourcefile~stringifor_string_t-doctest-51.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-52.f90 stringifor_string_t-doctest-52.f90 sourcefile~stringifor_string_t-doctest-52.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-53.f90 stringifor_string_t-doctest-53.f90 sourcefile~stringifor_string_t-doctest-53.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-54.f90 stringifor_string_t-doctest-54.f90 sourcefile~stringifor_string_t-doctest-54.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-55.f90 stringifor_string_t-doctest-55.f90 sourcefile~stringifor_string_t-doctest-55.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-56.f90 stringifor_string_t-doctest-56.f90 sourcefile~stringifor_string_t-doctest-56.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-57.f90 stringifor_string_t-doctest-57.f90 sourcefile~stringifor_string_t-doctest-57.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-58.f90 stringifor_string_t-doctest-58.f90 sourcefile~stringifor_string_t-doctest-58.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-59.f90 stringifor_string_t-doctest-59.f90 sourcefile~stringifor_string_t-doctest-59.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-6.f90 stringifor_string_t-doctest-6.f90 sourcefile~stringifor_string_t-doctest-6.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-60.f90 stringifor_string_t-doctest-60.f90 sourcefile~stringifor_string_t-doctest-60.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-61.f90 stringifor_string_t-doctest-61.f90 sourcefile~stringifor_string_t-doctest-61.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-62.f90 stringifor_string_t-doctest-62.f90 sourcefile~stringifor_string_t-doctest-62.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-63.f90 stringifor_string_t-doctest-63.f90 sourcefile~stringifor_string_t-doctest-63.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-64.f90 stringifor_string_t-doctest-64.f90 sourcefile~stringifor_string_t-doctest-64.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-65.f90 stringifor_string_t-doctest-65.f90 sourcefile~stringifor_string_t-doctest-65.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-66.f90 stringifor_string_t-doctest-66.f90 sourcefile~stringifor_string_t-doctest-66.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-67.f90 stringifor_string_t-doctest-67.f90 sourcefile~stringifor_string_t-doctest-67.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-68.f90 stringifor_string_t-doctest-68.f90 sourcefile~stringifor_string_t-doctest-68.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-69.f90 stringifor_string_t-doctest-69.f90 sourcefile~stringifor_string_t-doctest-69.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-7.f90 stringifor_string_t-doctest-7.f90 sourcefile~stringifor_string_t-doctest-7.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-70.f90 stringifor_string_t-doctest-70.f90 sourcefile~stringifor_string_t-doctest-70.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-71.f90 stringifor_string_t-doctest-71.f90 sourcefile~stringifor_string_t-doctest-71.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-72.f90 stringifor_string_t-doctest-72.f90 sourcefile~stringifor_string_t-doctest-72.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-73.f90 stringifor_string_t-doctest-73.f90 sourcefile~stringifor_string_t-doctest-73.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-74.f90 stringifor_string_t-doctest-74.f90 sourcefile~stringifor_string_t-doctest-74.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-75.f90 stringifor_string_t-doctest-75.f90 sourcefile~stringifor_string_t-doctest-75.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-76.f90 stringifor_string_t-doctest-76.f90 sourcefile~stringifor_string_t-doctest-76.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-77.f90 stringifor_string_t-doctest-77.f90 sourcefile~stringifor_string_t-doctest-77.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-78.f90 stringifor_string_t-doctest-78.f90 sourcefile~stringifor_string_t-doctest-78.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-79.f90 stringifor_string_t-doctest-79.f90 sourcefile~stringifor_string_t-doctest-79.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-8.f90 stringifor_string_t-doctest-8.f90 sourcefile~stringifor_string_t-doctest-8.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-80.f90 stringifor_string_t-doctest-80.f90 sourcefile~stringifor_string_t-doctest-80.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-81.f90 stringifor_string_t-doctest-81.f90 sourcefile~stringifor_string_t-doctest-81.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-82.f90 stringifor_string_t-doctest-82.f90 sourcefile~stringifor_string_t-doctest-82.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-83.f90 stringifor_string_t-doctest-83.f90 sourcefile~stringifor_string_t-doctest-83.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-84.f90 stringifor_string_t-doctest-84.f90 sourcefile~stringifor_string_t-doctest-84.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-85.f90 stringifor_string_t-doctest-85.f90 sourcefile~stringifor_string_t-doctest-85.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-86.f90 stringifor_string_t-doctest-86.f90 sourcefile~stringifor_string_t-doctest-86.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-87.f90 stringifor_string_t-doctest-87.f90 sourcefile~stringifor_string_t-doctest-87.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-88.f90 stringifor_string_t-doctest-88.f90 sourcefile~stringifor_string_t-doctest-88.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-89.f90 stringifor_string_t-doctest-89.f90 sourcefile~stringifor_string_t-doctest-89.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-9.f90 stringifor_string_t-doctest-9.f90 sourcefile~stringifor_string_t-doctest-9.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-90.f90 stringifor_string_t-doctest-90.f90 sourcefile~stringifor_string_t-doctest-90.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-91.f90 stringifor_string_t-doctest-91.f90 sourcefile~stringifor_string_t-doctest-91.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-92.f90 stringifor_string_t-doctest-92.f90 sourcefile~stringifor_string_t-doctest-92.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-93.f90 stringifor_string_t-doctest-93.f90 sourcefile~stringifor_string_t-doctest-93.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-94.f90 stringifor_string_t-doctest-94.f90 sourcefile~stringifor_string_t-doctest-94.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-95.f90 stringifor_string_t-doctest-95.f90 sourcefile~stringifor_string_t-doctest-95.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-96.f90 stringifor_string_t-doctest-96.f90 sourcefile~stringifor_string_t-doctest-96.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-97.f90 stringifor_string_t-doctest-97.f90 sourcefile~stringifor_string_t-doctest-97.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-98.f90 stringifor_string_t-doctest-98.f90 sourcefile~stringifor_string_t-doctest-98.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-99.f90 stringifor_string_t-doctest-99.f90 sourcefile~stringifor_string_t-doctest-99.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor-doctest-1.f90 stringifor-doctest-1.f90 sourcefile~stringifor-doctest-1.f90->sourcefile~stringifor.f90 sourcefile~stringifor-doctest-2.f90 stringifor-doctest-2.f90 sourcefile~stringifor-doctest-2.f90->sourcefile~stringifor.f90 sourcefile~stringifor_test_csv_naive_parser.f90 stringifor_test_csv_naive_parser.f90 sourcefile~stringifor_test_csv_naive_parser.f90->sourcefile~stringifor.f90 sourcefile~stringifor_test_parse_large_csv.f90 stringifor_test_parse_large_csv.f90 sourcefile~stringifor_test_parse_large_csv.f90->sourcefile~stringifor.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !< StringiFor, definition of `string` type. module stringifor_string_t !< StringiFor, definition of `string` type. use , intrinsic :: iso_fortran_env , only : iostat_eor use befor64 , only : b64_decode , b64_encode use face , only : colorize use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P , str implicit none private save ! expose StingiFor overloaded builtins and operators ! public :: adjustl, adjustr, count, index, len, len_trim, repeat, scan, trim, verify public :: adjustl , adjustr , count , index , len_trim , repeat , scan , trim , verify ! expose StingiFor objects public :: CK public :: glob public :: strjoin public :: string integer , parameter :: CK = selected_char_kind ( 'DEFAULT' ) !< Default character kind. type :: string !< OOP designed string class. character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods ! builtins replacements procedure , pass ( self ) :: adjustl => sadjustl !< Adjustl replacement. procedure , pass ( self ) :: adjustr => sadjustr !< Adjustr replacement. procedure , pass ( self ) :: count => scount !< Count replacement. generic :: index => sindex_string_string , & sindex_string_character !< Index replacement. procedure , pass ( self ) :: len => slen !< Len replacement. procedure , pass ( self ) :: len_trim => slen_trim !< Len_trim replacement. generic :: repeat => srepeat_string_string , & srepeat_character_string !< Repeat replacement. generic :: scan => sscan_string_string , & sscan_string_character !< Scan replacement. procedure , pass ( self ) :: trim => strim !< Trim replacement. generic :: verify => sverify_string_string , & sverify_string_character !< Verify replacement. ! auxiliary methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. generic :: colorize => & colorize_str !< Colorize and stylize strings. procedure , pass ( self ) :: decode !< Decode string. procedure , pass ( self ) :: encode !< Encode string. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: glob => & glob_character , & glob_string !< Glob search, finds all the pathnames matching a given pattern. generic :: insert => & insert_string , & insert_character !< Insert substring into string at a specified position. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. generic :: strjoin => & strjoin_strings , & strjoin_characters , & strjoin_strings_array , & strjoin_characters_array !< Return a string that is a join of an array of strings or characters; !< Return join 1D string array of an 2D array of strings or characters in columns or rows. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: read_file !< Read a file a single string stream. procedure , pass ( self ) :: read_line !< Read line (record) from a connected unit. procedure , pass ( self ) :: read_lines !< Read (all) lines (records) from a connected unit as a single ascii stream. procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: slice !< Return the raw characters data sliced. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: split_chunked !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. procedure , pass ( self ) :: tempname !< Return a safe temporary name suitable for temporary file or directories. generic :: to_number => & to_integer_I1P ,& #ifndef _NVF to_integer_I2P ,& #endif to_integer_I4P ,& to_integer_I8P ,& #if defined _R16P to_real_R16P , & #endif to_real_R8P , & to_real_R4P !< Cast string to number. procedure , pass ( self ) :: unescape !< Unescape double backslashes (or custom escaped character). procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: write_file !< Write a single string stream into file. procedure , pass ( self ) :: write_line !< Write line (record) to a connected unit. procedure , pass ( self ) :: write_lines !< Write lines (records) to a connected unit. ! inquire methods procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & #if defined _R16P string_assign_real_R16P , & #endif string_assign_real_R8P , & string_assign_real_R4P !< Assignment operator overloading. generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. generic :: operator ( == ) => string_eq_string , & string_eq_character , & character_eq_string !< Equal operator overloading. generic :: operator ( /= ) => string_ne_string , & string_ne_character , & character_ne_string !< Not equal operator overloading. generic :: operator ( < ) => string_lt_string , & string_lt_character , & character_lt_string !< Lower than operator overloading. generic :: operator ( <= ) => string_le_string , & string_le_character , & character_le_string !< Lower equal than operator overloading. generic :: operator ( >= ) => string_ge_string , & string_ge_character , & character_ge_string !< Greater equal than operator overloading. generic :: operator ( > ) => string_gt_string , & string_gt_character , & character_gt_string !< Greater than operator overloading. ! IO generic :: read ( formatted ) => read_formatted !< Formatted input. generic :: write ( formatted ) => write_formatted !< Formatted output. generic :: read ( unformatted ) => read_unformatted !< Unformatted input. generic :: write ( unformatted ) => write_unformatted !< Unformatted output. ! private methods ! builtins replacements procedure , private , pass ( self ) :: sindex_string_string !< Index replacement. procedure , private , pass ( self ) :: sindex_string_character !< Index replacement. procedure , private , pass ( self ) :: srepeat_string_string !< Repeat replacement. procedure , private , nopass :: srepeat_character_string !< Repeat replacement. procedure , private , pass ( self ) :: sscan_string_string !< Scan replacement. procedure , private , pass ( self ) :: sscan_string_character !< Scan replacement. procedure , private , pass ( self ) :: sverify_string_string !< Verify replacement. procedure , private , pass ( self ) :: sverify_string_character !< Verify replacement. ! auxiliary methods procedure , private , pass ( self ) :: colorize_str !< Colorize and stylize strings. procedure , private , pass ( self ) :: glob_character !< Glob search (character output). procedure , private , pass ( self ) :: glob_string !< Glob search (string output). procedure , private , pass ( self ) :: insert_string !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: insert_character !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , nopass :: strjoin_strings !< Return join string of an array of strings. procedure , private , nopass :: strjoin_characters !< Return join string of an array of strings. procedure , private , nopass :: strjoin_strings_array !< Return join 1D string array of an 2D array of strings in columns or rows. procedure , private , nopass :: strjoin_characters_array !< Return join 1D string array of an 2D array of characters in columns or rows. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. #ifndef _NVF procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. #endif procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. ! assignments procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. ! concatenation operators procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). ! logical operators procedure , private , pass ( lhs ) :: string_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: string_eq_character !< Equal to character logical operator. procedure , private , pass ( rhs ) :: character_eq_string !< Equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ne_string !< Not equal to string logical operator. procedure , private , pass ( lhs ) :: string_ne_character !< Not equal to character logical operator. procedure , private , pass ( rhs ) :: character_ne_string !< Not equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_lt_string !< Lower than to string logical operator. procedure , private , pass ( lhs ) :: string_lt_character !< Lower than to character logical operator. procedure , private , pass ( rhs ) :: character_lt_string !< Lower than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_le_string !< Lower equal than to string logical operator. procedure , private , pass ( lhs ) :: string_le_character !< Lower equal than to character logical operator. procedure , private , pass ( rhs ) :: character_le_string !< Lower equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ge_string !< Greater equal than to string logical operator. procedure , private , pass ( lhs ) :: string_ge_character !< Greater equal than to character logical operator. procedure , private , pass ( rhs ) :: character_ge_string !< Greater equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_gt_string !< Greater than to string logical operator. procedure , private , pass ( lhs ) :: string_gt_character !< Greater than to character logical operator. procedure , private , pass ( rhs ) :: character_gt_string !< Greater than to character (inverted) logical operator. ! IO procedure , private , pass ( dtv ) :: read_formatted !< Formatted input. procedure , private , pass ( dtv ) :: read_delimited !< Read a delimited input. procedure , private , pass ( dtv ) :: read_undelimited !< Read an undelimited input. procedure , private , pass ( dtv ) :: read_undelimited_listdirected !< Read an undelimited list directed input. procedure , private , pass ( dtv ) :: write_formatted !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted !< Unformatted output. ! miscellanea procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string ! internal parameters character ( kind = CK , len = 26 ), parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( kind = CK , len = 26 ), parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. character ( kind = CK , len = 1 ), parameter :: SPACE = ' ' !< Space character. character ( kind = CK , len = 1 ), parameter :: TAB = achar ( 9 ) !< Tab character. character ( kind = CK , len = 1 ), parameter :: UIX_DIR_SEP = char ( 47 ) !< Unix/Linux directories separator (/). character ( kind = CK , len = 1 ), parameter :: BACKSLASH = char ( 92 ) !< Backslash character. interface glob !< Overloading glob procedure. !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: alist_chr(:) !< type(string),     allocatable :: alist_str(:) !< integer, parameter            :: Nf=5 !< character(14)                 :: files(1:Nf) !< integer                       :: file_unit !< integer                       :: f !< integer                       :: ff !< logical                       :: test_passed !< do f=1, Nf !<    files(f) = astring%tempname(prefix='foo-') !<    open(newunit=file_unit, file=files(f)) !<    write(file_unit, *)f !<    close(unit=file_unit) !< enddo !< call glob(self=astring, pattern='foo-*', list=alist_chr) !< call glob(self=astring, pattern='foo-*', list=alist_str) !< do f=1, Nf !<    open(newunit=file_unit, file=files(f)) !<    close(unit=file_unit, status='delete') !< enddo !< test_passed = .false. !< outer_chr: do f=1, size(alist_chr, dim=1) !<    do ff=1, Nf !<       test_passed = alist_chr(f) == files(ff) !<       if (test_passed) cycle outer_chr !<    enddo !< enddo outer_chr !< if (test_passed) then !<    test_passed = .false. !<    outer_str: do f=1, size(alist_str, dim=1) !<       do ff=1, Nf !<          test_passed = alist_str(f) == files(ff) !<          if (test_passed) cycle outer_str !<       enddo !<    enddo outer_str !< endif !< print '(L1)', test_passed !<``` !=> T <<< module procedure glob_character , glob_string endinterface glob interface strjoin module procedure strjoin_strings , strjoin_characters , strjoin_strings_array , strjoin_characters_array endinterface strjoin ! builtin overloading interface adjustl !< Builtin adjustl overloading. module procedure sadjustl_character endinterface adjustl interface adjustr !< Builtin adjustr overloading. module procedure sadjustr_character endinterface adjustr interface count !< Builtin count overloading. module procedure count_substring endinterface interface index !< Builtin index overloading. module procedure sindex_string_string , sindex_string_character , sindex_character_string endinterface index !interface len !  !< Builtin len overloading. !  module procedure slen !endinterface len interface len_trim !< Builtin len_trim overloading. module procedure slen_trim endinterface len_trim interface repeat !< Builtin repeat overloading. module procedure srepeat_string_string endinterface repeat interface scan !< Builtin scan overloading. module procedure sscan_string_string , sscan_string_character , sscan_character_string endinterface scan interface trim !< Builtin trim overloading. module procedure strim endinterface trim interface verify !< Builtin verify overloading. module procedure sverify_string_string , sverify_string_character , sverify_character_string endinterface verify contains ! public non TBP ! creator pure function string_ ( c ) !< Return a string given a character input. !< !<```fortran !< print \"(L1)\", string('Hello World')//''=='Hello World' !<``` !=> T <<< character ( * ), intent ( in ) :: c !< Character. type ( string ) :: string_ !< String. string_ % raw = c endfunction string_ ! builtins replacements pure function sadjustl_character ( s ) result ( adjusted ) !< Left adjust a string by removing leading spaces (character output). !< !<```fortran !< type(string) :: astring !< astring = '   Hello World!' !< print \"(L1)\", adjustl(astring)=='Hello World!   ' !<``` !=> T <<< class ( string ), intent ( in ) :: s !< String. character ( kind = CK , len = :), allocatable :: adjusted !< Adjusted string. if ( allocated ( s % raw )) adjusted = adjustl ( s % raw ) endfunction sadjustl_character pure function sadjustr_character ( s ) result ( adjusted ) !< Right adjust a string by removing leading spaces (character output). !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", adjustr(astring)=='   Hello World!' !<``` !=> T <<< class ( string ), intent ( in ) :: s !< String. character ( kind = CK , len = :), allocatable :: adjusted !< Adjusted string. if ( allocated ( s % raw )) adjusted = adjustr ( s % raw ) endfunction sadjustr_character elemental function count_substring ( s , substring ) result ( No ) !< Count the number of occurences of a substring into a string. !< !<```fortran !< print \"(L1)\", count('hello', substring='ll')==1 !<``` !=> T <<< character ( * ), intent ( in ) :: s !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. No = 0 if ( len ( substring ) > len ( s )) return c1 = 1 do c2 = index ( string = s ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo endfunction count_substring elemental function sindex_character_string ( s , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'llo' !< test_passed(1) = index(s='Hello World Hello!', substring=string1)==index(string='Hello World Hello!', substring='llo') !< test_passed(2) = index(s='Hello World Hello!', substring=string1, back=.true.)==index(string='Hello World Hello!', & !<                                                                                       substring='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: s !< String. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( substring % raw )) then i = index ( string = s , substring = substring % raw , back = back ) else i = 0 endif endfunction sindex_character_string elemental function sscan_character_string ( s , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'llo' !< test_passed(1) = scan(s='Hello World Hello!', set=string1)==scan(string='Hello World Hello!', set='llo') !< test_passed(2) = scan(s='Hello World Hello!', set=string1, back=.true.)==scan(string='Hello World Hello!', & !<                                                                               set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: s !< String. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( set % raw )) then i = scan ( string = s , set = set % raw , back = back ) else i = 0 endif endfunction sscan_character_string elemental function sverify_character_string ( s , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'ell' !< test_passed(1) = verify(s='Hello World Hello!', set=string1)==verify(string='Hello World Hello!', set='llo') !< test_passed(2) = verify(s='Hello World Hello!', set=string1, back=.true.)==verify(string='Hello World Hello!', set='llo', & !<                                                                                   back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: s !< String. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( set % raw )) then i = verify ( string = s , set = set % raw , back = back ) else i = 0 endif endfunction sverify_character_string ! public methods ! builtins replacements elemental function sadjustl ( self ) result ( adjusted ) !< Left adjust a string by removing leading spaces. !< !<```fortran !< type(string) :: astring !< astring = '   Hello World!' !< print \"(L1)\", astring%adjustl()//''=='Hello World!   ' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) endfunction sadjustl elemental function sadjustr ( self ) result ( adjusted ) !< Right adjust a string by removing leading spaces. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%adjustr()//''=='   Hello World!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) endfunction sadjustr elemental function scount ( self , substring , ignore_isolated ) result ( No ) !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = '   Hello World  !    ' !< test_passed(1) = astring%count(substring=' ')==10 !< astring = 'Hello World  !    ' !< test_passed(2) = astring%count(substring=' ', ignore_isolated=.true.)==6 !< astring = '    Hello World  !' !< test_passed(3) = astring%count(substring=' ', ignore_isolated=.true.)==6 !< astring = '   Hello World  !    ' !< test_passed(4) = astring%count(substring=' ', ignore_isolated=.true.)==8 !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated c1 = 1 do c2 = index ( string = self % raw ( c1 :), substring = substring ) if ( c2 == 0 ) return if (. not . ignore_isolated_ ) then No = No + 1 else if (. not .(( c1 == 1. and . c2 == 1 ) . or . ( c1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif endfunction scount elemental function sindex_string_string ( self , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !< !<```fortran !< type(string) :: string1 !< type(string) :: string2 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< string2 = 'llo' !< test_passed(1) = string1%index(substring=string2)==index(string='Hello World Hello!', substring='llo') !< test_passed(2) = string1%index(substring=string2, back=.true.)==index(string='Hello World Hello!', substring='llo', & !<                                                                       back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring % raw , back = back ) else i = 0 endif endfunction sindex_string_string elemental function sindex_string_character ( self , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< test_passed(1) = string1%index(substring='llo')==index(string='Hello World Hello!', substring='llo') !< test_passed(2) = string1%index(substring='llo', back=.true.)==index(string='Hello World Hello!', substring='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif endfunction sindex_string_character elemental function slen ( self ) result ( l ) !< Return the length of a string. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%len()==len('Hello World!   ') !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif endfunction slen elemental function slen_trim ( self ) result ( l ) !< Return the length of a string, ignoring any trailing blanks. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%len_trim()==len_trim('Hello World!   ') !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif endfunction slen_trim elemental function srepeat_string_string ( self , ncopies ) result ( repeated ) !< Concatenates several copies of an input string. !< !<```fortran !< type(string) :: astring !< astring = 'x' !< print \"(L1)\", astring%repeat(5)//''=='xxxxx' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. #ifdef _NVF character ( 9999 ) :: nvf_bug !< Work around for NVFortran bug. #endif #ifdef _NVF nvf_bug = self % raw repeated % raw = repeat ( string = trim ( nvf_bug ), ncopies = ncopies ) #else repeated % raw = repeat ( string = self % raw , ncopies = ncopies ) #endif endfunction srepeat_string_string elemental function srepeat_character_string ( rstring , ncopies ) result ( repeated ) !< Concatenates several copies of an input string. !< !<```fortran !< type(string) :: astring !< astring = 'y' !< print \"(L1)\", astring%repeat('x', 5)//''=='xxxxx' !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. repeated % raw = repeat ( string = rstring , ncopies = ncopies ) endfunction srepeat_character_string elemental function sscan_string_string ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !< !<```fortran !< type(string) :: string1 !< type(string) :: string2 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< string2 = 'llo' !< test_passed(1) = string1%scan(set=string2)==scan(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%scan(set=string2, back=.true.)==scan(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = scan ( string = self % raw , set = set % raw , back = back ) else i = 0 endif endfunction sscan_string_string elemental function sscan_string_character ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< test_passed(1) = string1%scan(set='llo')==scan(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%scan(set='llo', back=.true.)==scan(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif endfunction sscan_string_character elemental function strim ( self ) result ( trimmed ) !< Remove trailing spaces. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%trim()==trim('Hello World!   ') !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) endfunction strim elemental function sverify_string_string ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !< !<```fortran !< type(string) :: string1 !< type(string) :: string2 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< string2 = 'llo' !< test_passed(1) = string1%verify(set=string2)==verify(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%verify(set=string2, back=.true.)==verify(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = verify ( string = self % raw , set = set % raw , back = back ) else i = 0 endif endfunction sverify_string_string elemental function sverify_string_character ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< test_passed(1) = string1%verify(set='llo')==verify(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%verify(set='llo', back=.true.)==verify(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif endfunction sverify_string_character ! auxiliary methods elemental function basedir ( self , sep ) !< Return the base directory name of a string containing a file name. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(4) !< string1 = '/bar/foo.tar.bz2' !< test_passed(1) = string1%basedir()//''=='/bar' !< string1 = './bar/foo.tar.bz2' !< test_passed(2) = string1%basedir()//''=='./bar' !< string1 = 'bar/foo.tar.bz2' !< test_passed(3) = string1%basedir()//''=='bar' !< string1 = '\\bar\\foo.tar.bz2' !< test_passed(4) = string1%basedir(sep='\\')//''=='\\bar' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif endfunction basedir elemental function basename ( self , sep , extension , strip_last_extension ) !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(5) !< astring = 'bar/foo.tar.bz2' !< test_passed(1) = astring%basename()//''=='foo.tar.bz2' !< test_passed(2) = astring%basename(extension='.tar.bz2')//''=='foo' !< test_passed(3) = astring%basename(strip_last_extension=.true.)//''=='foo.tar' !< astring = '\\bar\\foo.tar.bz2' !< test_passed(4) = astring%basename(sep='\\')//''=='foo.tar.bz2' !< astring = 'bar' !< test_passed(5) = astring%basename(strip_last_extension=.true.)//''=='bar' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) if ( present ( extension )) then pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then pos = index ( basename % raw , '.' , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) endif endif endif endfunction basename elemental function camelcase ( self , sep ) !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(L1)', astring%camelcase()//''=='CamelCaseVar' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !< Return a string with its first character capitalized and the rest lowercased. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%capitalize()//''=='Say all hello world!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif endfunction capitalize pure function chars ( self ) result ( raw ) !< Return the raw characters data. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%chars()=='say all Hello WorLD!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif endfunction chars pure function colorize_str ( self , color_fg , color_bg , style ) result ( colorized ) !< Colorize and stylize strings, DEFAULT kind. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%colorize(color_fg='red')=='\u001b[31msay all Hello WorLD!\u001b[0m' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :), allocatable :: colorized !< Colorized string. colorized = colorize ( string = self % chars (), color_fg = color_fg , color_bg = color_bg , style = style ) endfunction colorize_str elemental function decode ( self , codec ) result ( decoded ) !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(L1)', astring%decode(codec='base64')//''=='How are you?' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif endfunction decode elemental function encode ( self , codec ) result ( encoded ) !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(L1)', astring%encode(codec='base64')//''=='SG93IGFyZSB5b3U/' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif endfunction encode elemental function escape ( self , to_escape , esc ) result ( escaped ) !< Escape backslashes (or custom escape character). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '&#94;\\s \\d+\\s*' !< test_passed(1) = astring%escape(to_escape='\\')//''=='&#94;\\\\s \\\\d+\\\\s*' !< test_passed(2) = astring%escape(to_escape='\\', esc='|')//''=='&#94;|\\s |\\d+|\\s*' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif endfunction escape elemental function extension ( self ) !< Return the extension of a string containing a file name. !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(L1)', astring%extension()//''=='.bz2' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) if ( pos > 0 ) extension % raw = self % raw ( pos :) endif endfunction extension elemental function fill ( self , width , right , filling_char ) result ( filled ) !< Pad string on the left (or right) with zeros (or other char) to fill width. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = 'this is string example....wow!!!' !< test_passed(1) = astring%fill(width=40)//''=='00000000this is string example....wow!!!' !< test_passed(2) = astring%fill(width=50)//''=='000000000000000000this is string example....wow!!!' !< test_passed(3) = astring%fill(width=50, right=.true.)//''=='this is string example....wow!!!000000000000000000' !< test_passed(4) = astring%fill(width=40, filling_char='*')//''=='********this is string example....wow!!!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif endfunction fill elemental subroutine free ( self ) !< Free dynamic memory. !< !<```fortran !< type(string) :: astring !< astring = 'this is string example....wow!!!' !< call astring%free !< print '(L1)', astring%is_allocated().eqv..false. !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. if ( allocated ( self % raw )) deallocate ( self % raw ) endsubroutine free subroutine glob_character ( self , pattern , list ) !< Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. !< !< @note Method not portable: works only on Unix/GNU Linux OS. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: alist_chr(:) !< integer, parameter            :: Nf=5 !< character(14)                 :: files(1:Nf) !< integer                       :: file_unit !< integer                       :: f !< integer                       :: ff !< logical                       :: test_passed !< do f=1, Nf !<    files(f) = astring%tempname(prefix='foo-') !<    open(newunit=file_unit, file=files(f)) !<    write(file_unit, *)f !<    close(unit=file_unit) !< enddo !< call astring%glob(pattern='foo-*', list=alist_chr) !< do f=1, Nf !<    open(newunit=file_unit, file=files(f)) !<    close(unit=file_unit, status='delete') !< enddo !< test_passed = .false. !< outer_chr: do f=1, size(alist_chr, dim=1) !<    do ff=1, Nf !<       test_passed = alist_chr(f) == files(ff) !<       if (test_passed) cycle outer_chr !<    enddo !< enddo outer_chr !< print '(L1)', test_passed !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: pattern !< Given pattern. character ( len = :), allocatable , intent ( out ) :: list (:) !< List of matching pathnames. type ( string ), allocatable :: list_ (:) !< List of matching pathnames. integer ( I4P ) :: max_len !< Maximum length. integer ( I4P ) :: matches_number !< Matches number. integer ( I4P ) :: m !< Counter. call self % glob ( pattern = pattern , list = list_ ) if ( allocated ( list_ )) then matches_number = size ( list_ , dim = 1 ) max_len = 0 do m = 1 , matches_number max_len = max ( max_len , list_ ( m )% len ()) enddo allocate ( character ( max_len ) :: list ( 1 : matches_number )) do m = 1 , matches_number list ( m ) = list_ ( m )% chars () enddo endif endsubroutine glob_character subroutine glob_string ( self , pattern , list ) !< Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. !< !< @note Method not portable: works only on Unix/GNU Linux OS. !< !<```fortran !< type(string)                  :: astring !< type(string),     allocatable :: alist_str(:) !< integer, parameter            :: Nf=5 !< character(14)                 :: files(1:Nf) !< integer                       :: file_unit !< integer                       :: f !< integer                       :: ff !< logical                       :: test_passed !< !< do f=1, Nf !<    files(f) = astring%tempname(prefix='foo-') !<    open(newunit=file_unit, file=files(f)) !<    write(file_unit, *)f !<    close(unit=file_unit) !< enddo !< call astring%glob(pattern='foo-*', list=alist_str) !< do f=1, Nf !<    open(newunit=file_unit, file=files(f)) !<    close(unit=file_unit, status='delete') !< enddo !< test_passed = .false. !< outer_str: do f=1, size(alist_str, dim=1) !<    do ff=1, Nf !<       test_passed = alist_str(f) == files(ff) !<       if (test_passed) cycle outer_str !<    enddo !< enddo outer_str !< print '(L1)', test_passed !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: pattern !< Given pattern. type ( string ), allocatable , intent ( out ) :: list (:) !< List of matching pathnames. type ( string ) :: tempfile !< Safe temporary file. character ( len = :), allocatable :: tempname !< Safe temporary name. integer ( I4P ) :: tempunit !< Unit of temporary file. tempname = self % tempname () call execute_command_line ( 'ls -1 ' // trim ( adjustl ( pattern )) // ' > ' // tempname ) call tempfile % read_file ( file = tempname ) call tempfile % split ( sep = new_line ( 'a' ), tokens = list ) open ( newunit = tempunit , file = tempname ) close ( unit = tempunit , status = 'delete' ) endsubroutine glob_string elemental function insert_character ( self , substring , pos ) result ( inserted ) !< Insert substring into string at a specified position. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(5) !< astring = 'this is string example wow!!!' !< acharacter = '... ' !< test_passed(1) = astring%insert(substring=acharacter, pos=1)//''=='... this is string example wow!!!' !< test_passed(2) = astring%insert(substring=acharacter, pos=23)//''=='this is string example...  wow!!!' !< test_passed(3) = astring%insert(substring=acharacter, pos=29)//''=='this is string example wow!!!... ' !< test_passed(4) = astring%insert(substring=acharacter, pos=-1)//''=='... this is string example wow!!!' !< test_passed(5) = astring%insert(substring=acharacter, pos=100)//''=='this is string example wow!!!... ' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. if ( allocated ( self % raw )) then inserted = self safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring // self % raw ( safepos :) endif else inserted % raw = substring endif endfunction insert_character elemental function insert_string ( self , substring , pos ) result ( inserted ) !< Insert substring into string at a specified position. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(5) !< astring = 'this is string example wow!!!' !< anotherstring = '... ' !< test_passed(1) = astring%insert(substring=anotherstring, pos=1)//''=='... this is string example wow!!!' !< test_passed(2) = astring%insert(substring=anotherstring, pos=23)//''=='this is string example...  wow!!!' !< test_passed(3) = astring%insert(substring=anotherstring, pos=29)//''=='this is string example wow!!!... ' !< test_passed(4) = astring%insert(substring=anotherstring, pos=-1)//''=='... this is string example wow!!!' !< test_passed(5) = astring%insert(substring=anotherstring, pos=100)//''=='this is string example wow!!!... ' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. if ( allocated ( self % raw )) then inserted = self if ( allocated ( substring % raw )) then safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring % raw // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring % raw else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring % raw // self % raw ( safepos :) endif endif else if ( allocated ( substring % raw )) inserted % raw = substring % raw endif endfunction insert_string pure function join_strings ( self , array , sep ) result ( join ) !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !< !<```fortran !< type(string) :: astring !< type(string) :: strings(3) !< logical      :: test_passed(5) !< strings(1) = 'one' !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(1) = (astring%join(array=strings)//''==strings(1)//strings(2)//strings(3)) !< test_passed(2) = (astring%join(array=strings, sep='-')//''==strings(1)//'-'//strings(2)//'-'//strings(3)) !< call strings(1)%free !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(3) = (astring%join(array=strings, sep='-')//''==strings(2)//'-'//strings(3)) !< strings(1) = 'one' !< strings(2) = 'two' !< call strings(3)%free !< test_passed(4) = (astring%join(array=strings, sep='-')//''==strings(1)//'-'//strings(2)) !< strings(1) = 'one' !< call strings(2)%free !< strings(3) = 'three' !< test_passed(5) = (astring%join(array=strings, sep='-')//''==strings(1)//'-'//strings(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction join_strings pure function join_characters ( self , array , sep ) result ( join ) !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !< !<```fortran !< type(string) :: astring !< character(5) :: characters(3) !< logical      :: test_passed(6) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(1) = (astring%join(array=characters)//''==characters(1)//characters(2)//characters(3)) !< test_passed(2) = (astring%join(array=characters, sep='-')//''==characters(1)//'-'//characters(2)//'-'//characters(3)) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(3) = (astring%join(array=characters, sep='-')//''==characters(2)//'-'//characters(3)) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(4) = (astring%join(array=characters, sep='-')//''==characters(1)//'-'//characters(2)) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(5) = (astring%join(array=characters, sep='-')//''==characters(1)//'-'//characters(3)) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = 'three' !< astring = '_' !< test_passed(6) = (astring%join(array=characters)//''==characters(1)//'_'//characters(2)//'_'//characters(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction join_characters pure function strjoin_strings ( array , sep ) result ( join ) !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< !<```fortran !< type(string)     :: strings(3) !< logical          :: test_passed(5) !< strings(1) = 'one' !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(1) = (strjoin(array=strings)//''==strings(1)//strings(2)//strings(3)) !< test_passed(2) = (strjoin(array=strings, sep='-')//''==strings(1)//'-'//strings(2)//'-'//strings(3)) !< call strings(1)%free !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(3) = (strjoin(array=strings, sep='-')//''==strings(2)//'-'//strings(3)) !< strings(1) = 'one' !< strings(2) = 'two' !< call strings(3)%free !< test_passed(4) = (strjoin(array=strings, sep='-')//''==strings(1)//'-'//strings(2)) !< strings(1) = 'one' !< call strings(2)%free !< strings(3) = 'three' !< test_passed(5) = (strjoin(array=strings, sep='-')//''==strings(1)//'-'//strings(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. sep_ = '' if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction strjoin_strings pure function strjoin_characters ( array , sep , is_trim ) result ( join ) !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< The trim function is applied to array items if optional logical is_trim variable isn't set to .false. !< !<```fortran !< character(5) :: characters(3) !< logical      :: test_passed(13) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(1) = (strjoin(array=characters)//''==trim(characters(1))//trim(characters(2))//trim(characters(3))) !< test_passed(2) = (strjoin(array=characters, sep='-')//''==trim(characters(1))//'-'//trim(characters(2))//'-'//trim(characters(3))) !< test_passed(3) = ( strjoin(array=characters, is_trim=.false.)//''==characters(1)//characters(2)//characters(3)) !< test_passed(4) = ( strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(1)//'-'//characters(2)//'-'//characters(3)) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(5) = (strjoin(array=characters)//''==trim(characters(2))//trim(characters(3))) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(6) = (strjoin(array=characters)//''==trim(characters(1))//trim(characters(2))) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(7) = (strjoin(array=characters)//''==trim(characters(1))//trim(characters(3))) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(8) = (strjoin(array=characters, sep='-')//''==trim(characters(2))//'-'//trim(characters(3))) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(9) = (strjoin(array=characters, sep='-')//''==trim(characters(1))//'-'//trim(characters(2))) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(10) = (strjoin(array=characters, sep='-')//''==trim(characters(1))//'-'//trim(characters(3))) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(11) = (strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(2)//'-'//characters(3)) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(12) = (strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(1)//'-'//characters(2)) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(13) = (strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(1)//'-'//characters(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. logical , intent ( in ), optional :: is_trim !< Flag to setup trim character or not type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. logical :: is_trim_ !< Flag to setup trim character or not integer :: a !< Counter. sep_ = '' if ( present ( sep )) sep_ = sep is_trim_ = . true . ; if ( present ( is_trim )) is_trim_ = is_trim join = '' if ( is_trim_ ) then do a = 2 , size ( array , dim = 1 ) if ( trim ( array ( a )) /= '' ) join % raw = join % raw // sep_ // trim ( array ( a )) enddo if ( trim ( array ( 1 )) /= '' ) then join % raw = trim ( array ( 1 )) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif else do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endif endfunction strjoin_characters pure function strjoin_strings_array ( array , sep , is_col ) result ( join ) !< Return a string that is a join of columns or rows of an array of strings. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). !< !<```fortran !< type(string), allocatable :: strings_arr(:, :) !< logical                   :: test_passed(5) !< !< strings_arr = reshape( source = & !<                        [string('one'), string('two'), string('three'),  & !<                         string('ONE'), string('TWO'), string('THREE')], & !<                        shape = [3, 2] ) !< !< test_passed(1) = all( strjoin(array=strings_arr) == & !<                       reshape([string('onetwothree'), string('ONETWOTHREE')], & !<                       shape = [2]) ) !< !< test_passed(2) = all( strjoin(array=strings_arr, sep='_') == & !<                       reshape([string('one_two_three'), string('ONE_TWO_THREE')], & !<                       shape = [2]) ) !< !<  test_passed(3) = all( strjoin(array=strings_arr, is_col=.false.) == & !<                        reshape([string('oneONE'), string('twoTWO'), string('threeTHREE')], & !<                        shape = [3]) ) !< !<  test_passed(4) = all( strjoin(array=strings_arr, sep='_', is_col=.false.) == & !<                        reshape([string('one_ONE'), string('two_TWO'), string('three_THREE')], & !<                        shape = [3]) ) !< !< call strings_arr(2, 1)%free !< test_passed(5) = all( strjoin(array=strings_arr, sep='_', is_col=.false.) == & !<                  reshape([string('one_ONE'), string('TWO'), string('three_THREE')], & !<                  shape = [3]) ) !< !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: array ( 1 :, 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. logical , intent ( in ), optional :: is_col !< Direction: 'columns' if .true. or 'rows' if .false. type ( string ), allocatable :: join (:) !< The join of array. type ( string ), allocatable :: slice (:) !< The column or row slice of array character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. logical :: is_col_ !< Direction, default value. integer :: a , join_size , slice_size !< Counter, sizes of join vector and of slice of array sep_ = '' ; if ( present ( sep )) sep_ = sep is_col_ = . true . ; if ( present ( is_col )) is_col_ = is_col if ( is_col_ ) then join_size = size ( array , dim = 2 ) slice_size = size ( array , dim = 1 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( slice ( slice_size )) do a = 1 , join_size slice (:) = array (:, a ) join ( a ) = strjoin_strings ( slice , sep_ ) end do else join_size = size ( array , dim = 1 ) slice_size = size ( array , dim = 2 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( slice ( slice_size )) do a = 1 , join_size slice (:) = array ( a , :) join ( a ) = strjoin_strings ( slice , sep_ ) end do endif endfunction strjoin_strings_array pure function strjoin_characters_array ( array , sep , is_trim , is_col ) result ( join ) !< Return a string that is a join of columns or rows of an array of characters. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< The trim function is applied to array items if optional logical is_trim variable isn't set to .false. !< The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). !< !<```fortran !< character(len=10)         :: chars_arr(3, 2) !< logical                   :: test_passed(9) !< chars_arr(:, 1) = ['one       ', 'two       ', 'three     '] !< chars_arr(:, 2) = ['ONE       ', 'TWO       ', 'THREE     '] !< !< test_passed(1) = all( strjoin(array=chars_arr) == & !<                       reshape([string('onetwothree'), string('ONETWOTHREE')], & !<                       shape = [2]) ) !< !< test_passed(2) = all( strjoin(array=chars_arr, is_trim=.false.) ==  & !<                       reshape([string('one       two       three     '),  & !<                                string('ONE       TWO       THREE     ')], & !<                       shape = [2]) ) !< !< test_passed(3) = all( strjoin(array=chars_arr, sep='_') == & !<                       reshape([string('one_two_three'), string('ONE_TWO_THREE')], & !<                       shape = [2]) ) !< !< test_passed(4) = all( strjoin(array=chars_arr, sep='_', is_trim=.false.) ==  & !<                       reshape([string('one       _two       _three     '),  & !<                                string('ONE       _TWO       _THREE     ')], & !<                       shape = [2]) ) !< !< test_passed(5) = all( strjoin(array=chars_arr, is_col=.false.) == & !<                       reshape([string('oneONE'), string('twoTWO'), string('threeTHREE')], & !<                       shape = [3]) ) !< !< test_passed(6) = all( strjoin(array=chars_arr, is_trim=.false., is_col=.false.) ==  & !<                       reshape([string('one       ONE       '),  & !<                                string('two       TWO       '),  & !<                                string('three     THREE     ')], & !<                       shape = [3]) ) !< !< test_passed(7) = all( strjoin(array=chars_arr, sep='_', is_col=.false.) == & !<                       reshape([string('one_ONE'), string('two_TWO'), string('three_THREE')], & !<                       shape = [3]) ) !< !< test_passed(8) = all( strjoin(array=chars_arr, sep='_', is_trim=.false., is_col=.false.) ==  & !<                       reshape([string('one       _ONE       '),  & !<                                string('two       _TWO       '),  & !<                                string('three     _THREE     ')], & !<                       shape = [3]) ) !< !< chars_arr(2,1) = '' !< test_passed(9) = all( strjoin(array=chars_arr, sep='_', is_col=.false.) ==  & !<                       reshape([string('one_ONE'),  & !<                                string('TWO'),  & !<                                string('three_THREE')], & !<                       shape = [3]) ) !< !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :, 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. logical , intent ( in ), optional :: is_trim !< Flag to setup trim character or not logical , intent ( in ), optional :: is_col !< Direction: 'columns' if .true. or 'rows' if .false. type ( string ), allocatable :: join (:) !< The join of array. character ( kind = CK , len = :), allocatable :: slice (:) !< The column or row slice of array character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. logical :: is_trim_ !< Flag to setup trim character or not logical :: is_col_ !< Direction, default value. integer :: a , join_size , slice_size !< Counter, sizes of join vector and of slice of array integer :: item_len !< Length of array item (all items of character array have equal lengths) item_len = len ( array ( 1 , 1 )) !< all items of character array have equal lengths sep_ = '' ; if ( present ( sep )) sep_ = sep is_trim_ = . true . ; if ( present ( is_trim )) is_trim_ = is_trim is_col_ = . true . ; if ( present ( is_col )) is_col_ = is_col if ( is_col_ ) then join_size = size ( array , dim = 2 ) slice_size = size ( array , dim = 1 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( character ( len = item_len ) :: slice ( slice_size )) do a = 1 , join_size slice (:) = array (:, a ) join ( a ) = strjoin_characters ( slice , sep_ , is_trim_ ) end do else join_size = size ( array , dim = 1 ) slice_size = size ( array , dim = 2 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( character ( len = item_len ) :: slice ( slice_size )) do a = 1 , join_size slice (:) = array ( a , :) join ( a ) = strjoin_characters ( slice , sep_ , is_trim_ ) end do endif endfunction strjoin_characters_array elemental function lower ( self ) !< Return a string with all lowercase characters. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%lower()//''=='hello world!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif endfunction lower pure function partition ( self , sep ) result ( partitions ) !< Split string at separator and return the 3 parts (before, the separator and after). !< !<```fortran !< type(string) :: astring !< type(string) :: strings(3) !< logical      :: test_passed(3) !< astring = 'Hello WorLD!' !< strings = astring%partition(sep='lo Wo') !< test_passed(1) = (strings(1)//''=='Hel'.and.strings(2)//''=='lo Wo'.and.strings(3)//''=='rLD!') !< strings = astring%partition(sep='Hello') !< test_passed(2) = (strings(1)//''==''.and.strings(2)//''=='Hello'.and.strings(3)//''==' WorLD!') !< astring = 'Hello WorLD!' !< strings = astring%partition() !< test_passed(3) = (strings(1)//''=='Hello'.and.strings(2)//''==' '.and.strings(3)//''=='WorLD!') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) endif endif endfunction partition subroutine read_file ( self , file , is_fast , form , iostat , iomsg ) !< Read a file as a single string stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !< @note *Fast* file reading allows a very efficient reading of streamed file, but it dumps file as single streamed string. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(9) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, file='read_file_test.tmp') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< close(scratch) !< call astring%read_file(file='read_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< close(scratch) !< call astring%read_file(file='read_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< close(scratch, status='DELETE') !< call astring%read_file(file='read_file_test.tmp', iostat=iostat) !< test_passed(9) = (iostat/=0) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. logical , intent ( in ), optional :: is_fast !< Flag to enable (super) fast file reading. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. logical :: is_fast_ !< Flag to enable (super) fast file reading, local variable. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. integer ( I4P ) :: filesize !< Size of the file for fast reading. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then is_fast_ = . false . ; if ( present ( is_fast )) is_fast_ = is_fast if ( is_fast_ ) then open ( newunit = unit , file = file , access = 'STREAM' , form = 'UNFORMATTED' , iomsg = iomsg_ , iostat = iostat_ ) inquire ( file = file , size = filesize ) if ( allocated ( self % raw )) deallocate ( self % raw ) allocate ( character ( len = filesize ) :: self % raw ) read ( unit = unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw close ( unit ) else form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % read_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif else iostat_ = 1 iomsg_ = 'file not found' endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_file subroutine read_line ( self , unit , form , iostat , iomsg ) !< Read line (record) from a connected unit. !< !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)      :: astring !< type(string)      :: line(3) !< integer           :: iostat !< character(len=99) :: iomsg !< integer           :: scratch !< integer           :: l !< logical           :: test_passed(6) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, status='SCRATCH') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< rewind(scratch) !< l = 0 !< iostat = 0 !< do !<   l = l + 1 !<   call astring%read_line(unit=scratch, iostat=iostat, iomsg=iomsg) !<   if (iostat/=0.and..not.is_iostat_eor(iostat)) then !<     exit !<   else !<     test_passed(l) = (astring==line(l)) !<   endif !< enddo !< close(scratch) !< open(newunit=scratch, status='SCRATCH', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< rewind(scratch) !< l = 0 !< iostat = 0 !< do !<   l = l + 1 !<   call astring%read_line(unit=scratch, iostat=iostat, iomsg=iomsg, form='UnfORMatteD') !<   if (iostat/=0.and..not.is_iostat_eor(iostat)) then !<     exit !<   else !<     test_passed(l+3) = (astring==line(l)) !<   endif !< enddo !< close(scratch) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = :), allocatable :: line !< Line storage. character ( kind = CK , len = 1 ) :: ch !< Character storage. form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg line = '' select case ( form_ % chars ()) case ( 'FORMATTED' ) do read ( unit , \"(A)\" , advance = 'no' , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 , eor = 10 ) ch line = line // ch enddo case ( 'UNFORMATTED' ) do read ( unit , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) then iostat_ = iostat_eor exit endif line = line // ch enddo endselect 10 if ( line /= '' ) self % raw = line if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_line subroutine read_lines ( self , unit , form , iostat , iomsg ) !< Read (all) lines (records) from a connected unit as a single ascii stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. The line is read as an ascii stream read until the eor is reached. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, status='SCRATCH') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< call astring%read_lines(unit=scratch, iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< close(scratch) !< open(newunit=scratch, status='SCRATCH', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< call astring%read_lines(unit=scratch, form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< close(scratch) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. type ( string ) :: lines !< Lines storage. type ( string ) :: line !< Line storage. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) iostat_ = 0 lines % raw = '' do line % raw = '' call line % read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if ( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )) then exit elseif ( line /= '' ) then lines % raw = lines % raw // line % raw // new_line ( 'a' ) endif enddo if ( lines % raw /= '' ) self % raw = lines % raw if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_lines elemental function replace ( self , old , new , count ) result ( replaced ) !< Return a string with all occurrences of substring old replaced by new. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = 'When YOU are sad YOU should think to me :-)' !< test_passed(1) = (astring%replace(old='YOU', new='THEY')//''=='When THEY are sad THEY should think to me :-)') !< test_passed(2) = (astring%replace(old='YOU', new='THEY', count=1)//''=='When THEY are sad YOU should think to me :-)') !< astring = repeat(new_line('a')//'abcd', 20) !< astring = astring%replace(old=new_line('a'), new='|cr|') !< astring = astring%replace(old='|cr|', new=new_line('a')//'    ') !< test_passed(3) = (astring//''==repeat(new_line('a')//'    '//'abcd', 20)) !< astring = 'abcd  efg    hlmn' !< astring = astring%replace(old='', new='-') !< test_passed(4) = (astring//''=='abcd  efg    hlmn') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. if ( allocated ( self % raw )) then replaced = self if ( len ( old ) == 0 ) return ! avoid infite loop for null substring replacement r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif endfunction replace elemental function reverse ( self ) result ( reversed ) !< Return a reversed string. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = 'abcdefghilmnopqrstuvz' !< test_passed(1) = (astring%reverse()//''=='zvutsrqponmlihgfedcba') !< astring = '0123456789' !< test_passed(2) = (astring%reverse()//''=='9876543210') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif endfunction reverse function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. !< !<```fortran !< type(string)                  :: astring !< type(string)                  :: anotherstring !< character(len=:), allocatable :: acharacter !< integer                       :: istart !< integer                       :: iend !< logical                       :: test_passed(5) !< astring = '<test> <first> hello </first> <first> not the first </first> </test>' !< anotherstring = astring%search(tag_start='<first>', tag_end='</first>') !< test_passed(1) = anotherstring//''=='<first> hello </first>' !< astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' !< anotherstring = astring%search(tag_start='<a>', tag_end='</a>') !< test_passed(2) = anotherstring//''=='<a> <a> <a> the nested a </a> </a> </a>' !< call astring%free !< anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' !< astring = astring%search(in_string=anotherstring, tag_start='<a>', tag_end='</a>') !< test_passed(3) = astring//''=='<a> <a> <a> the nested a </a> </a> </a>' !< call astring%free !< acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' !< astring = astring%search(in_character=acharacter, tag_start='<a>', tag_end='</a>') !< test_passed(4) = astring//''=='<a> <a> <a> the nested a </a> </a> </a>' !< acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' !< astring = astring%search(in_character=acharacter, tag_start='<sec>', tag_end='</sec>', istart=istart, iend=iend) !< test_passed(5) = astring//''==acharacter(31:67) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) raw = self % raw endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % count ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ endfunction search pure function slice ( self , istart , iend ) result ( raw ) !< Return the raw characters data sliced. !< !<```fortran !< type(string) :: astring !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< print \"(A)\", astring%slice(11,25) !<``` !=> Brown fox Jumps <<< class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: istart !< Slice start index. integer , intent ( in ) :: iend !< Slice end   index. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. if ( allocated ( self % raw )) then raw = self % raw ( istart : iend ) else raw = '' endif endfunction slice elemental function snakecase ( self , sep ) !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< test_passed(1) = astring%snakecase()//''=='the_quick_brown_fox_jumps_over_the_lazy_dog.' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif endfunction snakecase pure subroutine split ( self , tokens , sep , max_tokens ) !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurrence. !< !< @note If `max_tokens` is passed the returned number of tokens is either `max_tokens` or `max_tokens + 1`. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< logical                   :: test_passed(11) !< astring = '+ab-++cre-++cre-ab+' !< call astring%split(tokens=strings, sep='+') !< test_passed(1) = (strings(1)//''=='ab-'.and.strings(2)//''=='cre-'.and.strings(3)//''=='cre-ab') !< astring = 'ab-++cre-++cre-ab+' !< call astring%split(tokens=strings, sep='+') !< test_passed(2) = (strings(1)//''=='ab-'.and.strings(2)//''=='cre-'.and.strings(3)//''=='cre-ab') !< astring = 'ab-++cre-++cre-ab' !< call astring%split(tokens=strings, sep='+') !< test_passed(3) = (strings(1)//''=='ab-'.and.strings(2)//''=='cre-'.and.strings(3)//''=='cre-ab') !< astring = 'Hello '//new_line('a')//'World!' !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(4) = (strings(1)//''=='Hello '.and.strings(2)//''=='World!') !< astring = 'Hello World!' !< call astring%split(tokens=strings) !< test_passed(5) = (strings(1)//''=='Hello'.and.strings(2)//''=='World!') !< astring = '+ab-' !< call astring%split(tokens=strings, sep='+') !< test_passed(6) = (strings(1)//''=='ab-') !< astring = '+ab-' !< call astring%split(tokens=strings, sep='-') !< test_passed(7) = (strings(1)//''=='+ab') !< astring = '+ab-+cd-' !< call astring%split(tokens=strings, sep='+') !< test_passed(8) = (strings(1)//''=='ab-'.and.strings(2)//''=='cd-') !< astring = 'ab-+cd-+' !< call astring%split(tokens=strings, sep='+') !< test_passed(9) = (strings(1)//''=='ab-'.and.strings(2)//''=='cd-') !< astring = '+ab-+cd-+' !< call astring%split(tokens=strings, sep='+') !< test_passed(10) = (strings(1)//''=='ab-'.and.strings(2)//''=='cd-') !< astring = '1-2-3-4-5-6-7-8' !< call astring%split(tokens=strings, sep='-', max_tokens=3) !< test_passed(11) = (strings(1)//''=='1'.and.strings(2)//''=='2'.and.strings(3)//''=='3'.and.strings(4)//''=='4-5-6-7-8') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. integer , intent ( in ), optional :: max_tokens !< Fix the maximum number of returned tokens. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % count ( sep_ ) if ( No > 0 ) then if ( present ( max_tokens )) then if ( max_tokens < No . and . max_tokens > 0 ) No = max_tokens endif allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No - 1 tokens ( t ) = temp_toks ( 1 , t + 1 ) enddo tokens ( No ) = temp_toks ( 3 , No ) else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif else allocate ( tokens ( 1 )) tokens ( 1 ) = self endif endif endsubroutine split pure subroutine split_chunked ( self , tokens , chunks , sep ) !< Return a list of substring in the string, using sep as the delimiter string, chunked (memory-efficient) algorithm. !< !< @note Multiple subsequent separators are collapsed to one occurrence. !< !< @note The split is performed in chunks of `#chunks` to avoid excessive memory consumption. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< logical                   :: test_passed(1) !< astring = '-1-2-3-4-5-6-7-8-' !< call astring%split_chunked(tokens=strings, sep='-', chunks=3) !< test_passed(1) = (strings(1)//''=='1'.and.strings(2)//''=='2'.and.strings(3)//''=='3'.and.strings(4)//''=='4'.and. & !<                   strings(5)//''=='5'.and.strings(6)//''=='6'.and.strings(7)//''=='7'.and.strings(8)//''=='8') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. integer , intent ( in ) :: chunks !< Number of chunks. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: Nt !< Number of actual tokens. integer :: t !< Counter. logical :: isok if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep Nt = self % count ( sep_ ) if ( self % start_with ( prefix = sep_ )) Nt = Nt - 1 if ( self % end_with ( suffix = sep_ )) Nt = Nt - 1 t = 0 call self % split ( tokens = tokens , sep = sep_ , max_tokens = chunks ) do t = size ( tokens , dim = 1 ) if ( t > Nt ) exit call split_last_token ( tokens = tokens , max_tokens = chunks , isok = isok ) if ( isok ) then else exit endif enddo t = size ( tokens , dim = 1 ) if ( tokens ( t )% count ( sep_ ) > 0 ) then call split_last_token ( tokens = tokens , isok = isok ) endif endif contains pure subroutine split_last_token ( tokens , max_tokens , isok ) !< Split last token. type ( string ), allocatable , intent ( inout ) :: tokens (:) !< Tokens substring. integer , intent ( in ), optional :: max_tokens !< Max tokens returned. type ( string ), allocatable :: tokens_ (:) !< Temporary tokens. type ( string ), allocatable :: tokens_swap (:) !< Swap tokens. integer :: Nt_ !< Number of last created tokens. logical , intent ( out ) :: isok isok = . true . call tokens ( t )% split ( tokens = tokens_ , sep = sep_ , max_tokens = max_tokens ) if ( allocated ( tokens_ )) then Nt_ = size ( tokens_ , dim = 1 ) if ( Nt_ >= 1 ) then allocate ( tokens_swap ( 1 : t - 1 + Nt_ )) tokens_swap ( 1 : t - 1 ) = tokens ( 1 : t - 1 ) tokens_swap ( t :) = tokens_ (:) call move_alloc ( from = tokens_swap , to = tokens ) endif if ( Nt_ == 1 ) then isok = . false . end if deallocate ( tokens_ ) endif endsubroutine split_last_token endsubroutine split_chunked elemental function startcase ( self , sep ) !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< test_passed(1) = astring%startcase()//''=='The Quick Brown Fox Jumps Over The Lazy Dog.' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif endfunction startcase elemental function strip ( self , remove_nulls ) !< Return a copy of the string with the leading and trailing characters removed. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = '  Hello World!   ' !< test_passed(1) = astring%strip()//''=='Hello World!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: remove_nulls !< Remove null characters at the end. type ( string ) :: strip !< The stripped string. integer :: c !< Counter. if ( allocated ( self % raw )) then strip = self % adjustl () strip = strip % trim () if ( present ( remove_nulls )) then if ( remove_nulls ) then c = index ( self % raw , char ( 0 )) if ( c > 0 ) strip % raw = strip % raw ( 1 : c - 1 ) endif endif endif endfunction strip elemental function swapcase ( self ) !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = '  Hello World!   ' !< test_passed(1) = astring%swapcase()//''=='  hELLO wORLD!   ' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif endfunction swapcase function tempname ( self , is_file , prefix , path ) !< Return a safe temporary name suitable for temporary file or directories. !< !<```fortran !< type(string) :: astring !< character(len=:), allocatable :: tmpname !< logical                       :: test_passed(5) !< tmpname = astring%tempname() !< inquire(file=tmpname, exist=test_passed(1)) !< test_passed(1) = .not.test_passed(1) !< tmpname = astring%tempname(is_file=.false.) !< inquire(file=tmpname, exist=test_passed(2)) !< test_passed(2) = .not.test_passed(2) !< tmpname = astring%tempname(path='./') !< inquire(file=tmpname, exist=test_passed(3)) !< test_passed(3) = .not.test_passed(3) !< astring = 'me-' !< tmpname = astring%tempname() !< inquire(file=tmpname, exist=test_passed(4)) !< test_passed(4) = .not.test_passed(4) !< tmpname = astring%tempname(prefix='you-') !< inquire(file=tmpname, exist=test_passed(5)) !< test_passed(5) = .not.test_passed(5) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: is_file !< True if tempname should be used for file (the default). character ( * ), intent ( in ), optional :: prefix !< Name prefix, otherwise self is used (if allocated). character ( * ), intent ( in ), optional :: path !< Path where file/directory should be used, default `./`. character ( len = :), allocatable :: tempname !< Safe (unique) temporary name. logical :: is_file_ !< True if tempname should be used for file (the default). character ( len = :), allocatable :: prefix_ !< Name prefix, otherwise self is used (if allocated). character ( len = :), allocatable :: path_ !< Path where file/directory should be used, default `./`. logical , save :: is_initialized = . false . !< Status of random seed initialization. real ( R4P ) :: random_real !< Random number (real). integer ( I4P ) :: random_integer !< Random number (integer). logical :: is_hold !< Flag to check if a safe tempname has been found. is_file_ = . true . ; if ( present ( is_file )) is_file_ = is_file path_ = '' ; if ( present ( path )) path_ = path prefix_ = '' if ( present ( prefix )) then prefix_ = prefix elseif ( allocated ( self % raw )) then prefix_ = self % raw endif if (. not . is_initialized ) then call random_seed is_initialized = . true . endif tempname = repeat ( ' ' , len ( path_ ) + len ( prefix_ ) + 10 ) ! [path_] + [prefix_] + 6 random chars + [.tmp] do call random_number ( random_real ) random_integer = transfer ( random_real , random_integer ) random_integer = iand ( random_integer , 16777215_I4P ) if ( is_file_ ) then write ( tempname , '(A,Z6.6,A)' ) path_ // prefix_ , random_integer , '.tmp' else write ( tempname , '(A,Z6.6)' ) path_ // prefix_ , random_integer tempname = trim ( tempname ) endif inquire ( file = tempname , exist = is_hold ) if (. not . is_hold ) exit enddo endfunction tempname elemental function to_integer_I1P ( self , kind ) result ( to_number ) !< Cast string to integer (I1P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I1P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I1P) !< test_passed(1) = integer_==127_I1P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I1P #ifndef _NVF elemental function to_integer_I2P ( self , kind ) result ( to_number ) !< Cast string to integer (I2P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I2P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I2P) !< test_passed(1) = integer_==127_I2P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I2P #endif elemental function to_integer_I4P ( self , kind ) result ( to_number ) !< Cast string to integer (I4P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I4P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I4P) !< test_passed(1) = integer_==127_I4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I4P elemental function to_integer_I8P ( self , kind ) result ( to_number ) !< Cast string to integer (I8P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I8P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I8P) !< test_passed(1) = integer_==127_I8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I8P elemental function to_real_R4P ( self , kind ) result ( to_number ) !< Cast string to real (R4P). !< !<```fortran !< use penf !< type(string) :: astring !< real(R4P)    :: real_ !< logical      :: test_passed(1) !< astring = '3.4e9' !< real_ = astring%to_number(kind=1._R4P) !< test_passed(1) = real_==3.4e9_R4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R4P elemental function to_real_R8P ( self , kind ) result ( to_number ) !< Cast string to real (R8P). !< !<```fortran !< use penf !< type(string) :: astring !< real(R8P)    :: real_ !< logical      :: test_passed(1) !< astring = '3.4e9' !< real_ = astring%to_number(kind=1._R8P) !< test_passed(1) = real_==3.4e9_R8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R8P elemental function to_real_R16P ( self , kind ) result ( to_number ) !< Cast string to real (R16P). !< !<```fortran !< use penf !< type(string) :: astring !< real(R16P)   :: real_ !< logical      :: test_passed(1) !< astring = '3.4e9' !< real_ = astring%to_number(kind=1._R16P) !< test_passed(1) = real_==3.4e9_R16P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R16P elemental function unescape ( self , to_unescape , unesc ) result ( unescaped ) !< Unescape double backslashes (or custom escaped character). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '&#94;\\\\s \\\\d+\\\\s*' !< test_passed(1) = (astring%unescape(to_unescape='\\')//''=='&#94;\\s \\d+\\s*') !< test_passed(2) = (astring%unescape(to_unescape='s')//''=='&#94;\\s \\\\d+\\s*') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_unescape !< Character to be unescaped. character ( kind = CK , len =* ), intent ( in ), optional :: unesc !< Character used to unescape. type ( string ) :: unescaped !< Escaped string. character ( kind = CK , len = :), allocatable :: unesc_ !< Character to unescape, local variable. integer :: c !< Character counter. if ( allocated ( self % raw )) then unesc_ = '' ; if ( present ( unesc )) unesc_ = unesc unescaped % raw = '' c = 1 do if ( c > len ( self % raw )) exit if ( c == len ( self % raw )) then unescaped % raw = unescaped % raw // self % raw ( c : c ) exit else if ( self % raw ( c : c + 1 ) == BACKSLASH // to_unescape ) then unescaped % raw = unescaped % raw // to_unescape c = c + 2 else unescaped % raw = unescaped % raw // self % raw ( c : c ) c = c + 1 endif endif enddo endif endfunction unescape elemental function unique ( self , substring ) result ( uniq ) !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = '+++ab-++cre-++cre-ab+++++' !< test_passed(1) = astring%unique(substring='+')//''=='+ab-+cre-+cre-ab+' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. #ifdef _NVF character ( 9999 ) :: nvf_bug !< Work around for NVFortran bug. #endif if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do #ifdef _NVF nvf_bug = substring_ if (. not . uniq % index ( repeat ( trim ( nvf_bug ), 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( trim ( nvf_bug ), 2 ), new = substring_ ) #else if (. not . uniq % index ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) #endif enddo endif endfunction unique elemental function upper ( self ) !< Return a string with all uppercase characters. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%upper()//''=='HELLO WORLD!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif endfunction upper subroutine write_file ( self , file , form , iostat , iomsg ) !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string)              :: anotherstring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< anotherstring = anotherstring%join(array=line, sep=new_line('a')) !< call anotherstring%write_file(file='write_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< call anotherstring%write_file(file='write_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='write_file_test.tmp') !< close(unit=scratch, status='delete') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % write_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_file subroutine write_line ( self , unit , form , iostat , iomsg ) !< Write line (record) to a connected unit. !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !< !< @note There is no doctests, this being tested by means of [[string:write_file]] doctests. class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. iostat_ = 0 iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg if ( allocated ( self % raw )) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) write ( unit , \"(A)\" , iostat = iostat_ , iomsg = iomsg_ ) self % raw case ( 'UNFORMATTED' ) if ( self % end_with ( new_line ( 'a' ))) then write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw else write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw // new_line ( 'a' ) endif endselect endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_line subroutine write_lines ( self , unit , form , iostat , iomsg ) !< Write lines (records) to a connected unit. !< !< This method checks if self contains more than one line (records) and writes them as lines (records). !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !< !< @note There is no doctests, this being tested by means of [[string:write_file]] doctests. class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ), allocatable :: lines (:) !< Lines. integer :: l !< Counter. if ( allocated ( self % raw )) then call self % split ( tokens = lines , sep = new_line ( 'a' )) do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endif endsubroutine write_lines ! inquire elemental function end_with ( self , suffix , start , end , ignore_null_eof ) !< Return true if a string ends with a specified suffix. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(5) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%end_with(suffix='LD!').eqv..true. !< test_passed(2) = astring%end_with(suffix='lD!').eqv..false. !< test_passed(3) = astring%end_with(suffix='orLD!', start=5).eqv..true. !< test_passed(4) = astring%end_with(suffix='orLD!', start=8, end=12).eqv..true. !< test_passed(5) = astring%end_with(suffix='!').eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical , intent ( in ), optional :: ignore_null_eof !< Ignore null character at the end of file. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. logical :: ignore_null_eof_ !< Ignore null character at the end of file, local variable. end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end ignore_null_eof_ = . false . ; if ( present ( ignore_null_eof )) ignore_null_eof_ = ignore_null_eof if ( ignore_null_eof_ . and .( self % raw ( end_ : end_ ) == char ( 0 ))) end_ = end_ - 1 if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = self % raw ( end_ - len ( suffix ) + 1 : end_ ) == suffix endif endif endfunction end_with elemental function is_allocated ( self ) !< Return true if the string is allocated. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< test_passed(1) = astring%is_allocated().eqv..false. !< astring = 'hello' !< test_passed(2) = astring%is_allocated().eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. is_allocated = allocated ( self % raw ) endfunction is_allocated elemental function is_digit ( self ) !< Return true if all characters in the string are digits. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '   -1212112.3 ' !< test_passed(1) = astring%is_digit().eqv..false. !< astring = '12121123' !< test_passed(2) = astring%is_digit().eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif endfunction is_digit elemental function is_integer ( self , allow_spaces ) !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(6) !< astring = '   -1212112 ' !< test_passed(1) = astring%is_integer().eqv..true. !< astring = '   -1212112' !< test_passed(2) = astring%is_integer(allow_spaces=.false.).eqv..false. !< astring = '-1212112   ' !< test_passed(3) = astring%is_integer(allow_spaces=.false.).eqv..false. !< astring = '+2e20' !< test_passed(4) = astring%is_integer().eqv..true. !< astring = ' -2E13 ' !< test_passed(5) = astring%is_integer().eqv..true. !< astring = ' -2 E13 ' !< test_passed(6) = astring%is_integer().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif endfunction is_integer elemental function is_lower ( self ) !< Return true if all characters in the string are lowercase. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(3) !< astring = ' Hello World' !< test_passed(1) = astring%is_lower().eqv..false. !< astring = ' HELLO WORLD' !< test_passed(2) = astring%is_lower().eqv..false. !< astring = ' hello world' !< test_passed(3) = astring%is_lower().eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif endfunction is_lower elemental function is_number ( self , allow_spaces ) !< Return true if the string contains a number (real or integer). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(7) !< astring = '   -1212112 ' !< test_passed(1) = astring%is_number().eqv..true. !< astring = '   -121.2112 ' !< test_passed(2) = astring%is_number().eqv..true. !< astring = '   -1212112' !< test_passed(3) = astring%is_number(allow_spaces=.false.).eqv..false. !< astring = '-12121.12   ' !< test_passed(4) = astring%is_number(allow_spaces=.false.).eqv..false. !< astring = '+2e20' !< test_passed(5) = astring%is_number().eqv..true. !< astring = ' -2.4E13 ' !< test_passed(6) = astring%is_number().eqv..true. !< astring = ' -2 E13 ' !< test_passed(7) = astring%is_number().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) endfunction is_number elemental function is_real ( self , allow_spaces ) !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(6) !< astring = '   -1212112.d0 ' !< test_passed(1) = astring%is_real().eqv..true. !< astring = '   -1212112.d0' !< test_passed(2) = astring%is_real(allow_spaces=.false.).eqv..false. !< astring = '-1212112.d0   ' !< test_passed(3) = astring%is_real(allow_spaces=.false.).eqv..false. !< astring = '+2.e20' !< test_passed(4) = astring%is_real().eqv..true. !< astring = ' -2.01E13 ' !< test_passed(5) = astring%is_real().eqv..true. !< astring = ' -2.01 E13 ' !< test_passed(6) = astring%is_real().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif endfunction is_real elemental function is_upper ( self ) !< Return true if all characters in the string are uppercase. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(3) !< astring = ' Hello World' !< test_passed(1) = astring%is_upper().eqv..false. !< astring = ' HELLO WORLD' !< test_passed(2) = astring%is_upper().eqv..true. !< astring = ' hello world' !< test_passed(3) = astring%is_upper().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif endfunction is_upper elemental function start_with ( self , prefix , start , end ) !< Return true if a string starts with a specified prefix. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%start_with(prefix='Hello').eqv..true. !< test_passed(2) = astring%start_with(prefix='hell').eqv..false. !< test_passed(3) = astring%start_with(prefix='llo Wor', start=3).eqv..true. !< test_passed(4) = astring%start_with(prefix='lo W', start=4, end=7).eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif endfunction start_with ! private methods ! assignments pure subroutine string_assign_string ( lhs , rhs ) !< Assignment operator from string input. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(1) !< astring = 'hello' !< anotherstring = astring !< test_passed(1) = astring%chars()==anotherstring%chars() !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( rhs % raw )) lhs % raw = rhs % raw endsubroutine string_assign_string pure subroutine string_assign_character ( lhs , rhs ) !< Assignment operator from character input. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'hello' !< test_passed(1) = astring%chars()=='hello' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. lhs % raw = rhs endsubroutine string_assign_character pure subroutine string_assign_integer_I1P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I1P !< test_passed(1) = astring%to_number(kind=1_I1P)==127_I1P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I1P pure subroutine string_assign_integer_I2P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I2P !< test_passed(1) = astring%to_number(kind=1_I2P)==127_I2P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I2P pure subroutine string_assign_integer_I4P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I4P !< test_passed(1) = astring%to_number(kind=1_I4P)==127_I4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I4P pure subroutine string_assign_integer_I8P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I8P !< test_passed(1) = astring%to_number(kind=1_I8P)==127_I8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I8P pure subroutine string_assign_real_R4P ( lhs , rhs ) !< Assignment operator from real input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 3.021e6_R4P !< test_passed(1) = astring%to_number(kind=1._R4P)==3.021e6_R4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R4P pure subroutine string_assign_real_R8P ( lhs , rhs ) !< Assignment operator from real input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 3.021e6_R8P !< test_passed(1) = astring%to_number(kind=1._R8P)==3.021e6_R8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R8P pure subroutine string_assign_real_R16P ( lhs , rhs ) !< Assignment operator from real input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 3.021e6_R8P !< test_passed(1) = astring%to_number(kind=1._R8P)==3.021e6_R8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R16P ! contatenation operators pure function string_concat_string ( lhs , rhs ) result ( concat ) !< Concatenation with string. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(1) !< astring = 'Hello ' !< anotherstring = 'Bye bye' !< test_passed(1) = astring//anotherstring=='Hello Bye bye' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw endfunction string_concat_string pure function string_concat_character ( lhs , rhs ) result ( concat ) !< Concatenation with character. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< test_passed(1) = astring//acharacter=='Hello World!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif endfunction string_concat_character pure function character_concat_string ( lhs , rhs ) result ( concat ) !< Concatenation with character (inverted). !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< test_passed(1) = acharacter//astring=='World!Hello ' !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif endfunction character_concat_string elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !< Concatenation with string. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< type(string) :: yetanotherstring !< logical      :: test_passed(1) !< astring = 'Hello ' !< anotherstring = 'Bye bye' !< yetanotherstring = astring.cat.anotherstring !< test_passed(1) = yetanotherstring%chars()=='Hello Bye bye' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary endfunction string_concat_string_string elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !< Concatenation with character. !< !<```fortran !< type(string)                  :: astring !< type(string)                  :: yetanotherstring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< yetanotherstring = astring.cat.acharacter !< test_passed(1) = yetanotherstring%chars()=='Hello World!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif endfunction string_concat_character_string elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !< Concatenation with character (inverted). !< !<```fortran !< type(string)                  :: astring !< type(string)                  :: yetanotherstring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< yetanotherstring = acharacter.cat.astring !< test_passed(1) = yetanotherstring%chars()=='World!Hello ' !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif endfunction character_concat_string_string ! logical operators elemental function string_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = '  one ' !< anotherstring = 'two' !< test_passed(1) = ((astring==anotherstring).eqv..false.) !< astring = 'the same ' !< anotherstring = 'the same ' !< test_passed(2) = ((astring==anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw == rhs % raw endfunction string_eq_string elemental function string_eq_character ( lhs , rhs ) result ( is_it ) !< Equal to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((astring==acharacter).eqv..false.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((astring==acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw == rhs endfunction string_eq_character elemental function character_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((acharacter==astring).eqv..false.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((acharacter==astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = rhs % raw == lhs endfunction character_eq_string elemental function string_ne_string ( lhs , rhs ) result ( is_it ) !< Not equal to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = '  one ' !< anotherstring = 'two' !< test_passed(1) = ((astring/=anotherstring).eqv..true.) !< astring = 'the same ' !< anotherstring = 'the same ' !< test_passed(2) = ((astring/=anotherstring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw /= rhs % raw endfunction string_ne_string elemental function string_ne_character ( lhs , rhs ) result ( is_it ) !< Not equal to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((astring/=acharacter).eqv..true.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((astring/=acharacter).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw /= rhs endfunction string_ne_character elemental function character_ne_string ( lhs , rhs ) result ( is_it ) !< Not equal to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((acharacter/=astring).eqv..true.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((acharacter/=astring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = rhs % raw /= lhs endfunction character_ne_string elemental function string_lt_string ( lhs , rhs ) result ( is_it ) !< Lower than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring<anotherstring).eqv..false.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring<anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw < rhs % raw endfunction string_lt_string elemental function string_lt_character ( lhs , rhs ) result ( is_it ) !< Lower than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring<acharacter).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring<acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw < rhs endfunction string_lt_character elemental function character_lt_string ( lhs , rhs ) result ( is_it ) !< Lower than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter<astring).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter<astring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs < rhs % raw endfunction character_lt_string elemental function string_le_string ( lhs , rhs ) result ( is_it ) !< Lower equal than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(3) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring<=anotherstring).eqv..false.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring<=anotherstring).eqv..true.) !< astring = 'ONE' !< anotherstring = 'ONE' !< test_passed(3) = ((astring<=anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw <= rhs % raw endfunction string_le_string elemental function string_le_character ( lhs , rhs ) result ( is_it ) !< Lower equal than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring<=acharacter).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring<=acharacter).eqv..true.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((astring<=acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw <= rhs endfunction string_le_character elemental function character_le_string ( lhs , rhs ) result ( is_it ) !< Lower equal than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter<=astring).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter<=astring).eqv..false.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((acharacter<=astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs <= rhs % raw endfunction character_le_string elemental function string_ge_string ( lhs , rhs ) result ( is_it ) !< Greater equal than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(3) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring>=anotherstring).eqv..true.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring>=anotherstring).eqv..false.) !< astring = 'ONE' !< anotherstring = 'ONE' !< test_passed(3) = ((astring>=anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw >= rhs % raw endfunction string_ge_string elemental function string_ge_character ( lhs , rhs ) result ( is_it ) !< Greater equal than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring>=acharacter).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring>=acharacter).eqv..false.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((astring>=acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw >= rhs endfunction string_ge_character elemental function character_ge_string ( lhs , rhs ) result ( is_it ) !< Greater equal than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter>=astring).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter>=astring).eqv..true.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((acharacter>=astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs >= rhs % raw endfunction character_ge_string elemental function string_gt_string ( lhs , rhs ) result ( is_it ) !< Greater than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring>anotherstring).eqv..true.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring>anotherstring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw > rhs % raw endfunction string_gt_string elemental function string_gt_character ( lhs , rhs ) result ( is_it ) !< Greater than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring>acharacter).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring>acharacter).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw > rhs endfunction string_gt_character elemental function character_gt_string ( lhs , rhs ) result ( is_it ) !< Greater than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter>astring).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter>astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs > rhs % raw endfunction character_gt_string ! IO subroutine read_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !< !< @bug Read listdirected with and without delimiters does not work. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. character ( kind = CK , len = 1 ) :: delim !< String delimiter, if any. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. if ( iotype == 'LISTDIRECTED' ) then call get_next_non_blank_character_any_record ( unit = unit , ch = delim , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return if ( delim == '\"' . OR . delim == \"'\" ) then call dtv % read_delimited ( unit = unit , delim = delim , iostat = iostat , iomsg = local_iomsg ) else ! step back before the non-blank read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited_listdirected ( unit = unit , iostat = iostat , iomsg = local_iomsg ) endif if ( is_iostat_eor ( iostat )) then ! suppress IOSTAT_EOR iostat = 0 elseif ( iostat /= 0 ) then iomsg = local_iomsg endif return else read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endif endsubroutine read_formatted subroutine read_delimited ( dtv , unit , delim , iostat , iomsg ) !< Read a delimited string from a unit connected for formatted input. !< !< If the closing delimiter is followed by end of record, then we return end of record. !< !< @note This does not need a doctest, it being tested by [[string::read_formatted]]. class ( string ), intent ( out ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( in ) :: delim !< String delimiter. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. logical :: was_delim !< Indicates that the last character read was a delimiter. was_delim = . false . dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then if ( was_delim ) then ! end of delimited string followed by end of record is end of the string. Pass back the ! end of record condition to the caller return else ! end of record without terminating delimiter - move along cycle endif elseif ( iostat /= 0 ) THEN return endif if ( ch == delim ) then if ( was_delim ) then ! doubled delimiter is one delimiter in the value dtv % raw = dtv % raw // ch was_delim = . false . else ! need to test next character to see what is happening was_delim = . true . endif elseif ( was_delim ) then ! the previous character was actually the delimiter for the end of the string. Put back this character read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) return else dtv % raw = dtv % raw // ch endif enddo endsubroutine read_delimited subroutine read_undelimited_listdirected ( dtv , unit , iostat , iomsg ) !< Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. !< !< A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. !< !< If input is terminated by end of record, then this procedure returns an end-of-record condition. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. logical :: decimal_point !<True if DECIMAL=POINT in effect. call get_decimal_mode ( unit = unit , decimal_point = decimal_point , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited ( unit = unit , terminators = ' ' // '/' // merge ( CK_ ',' , CK_ ';' , decimal_point ), iostat = iostat , iomsg = iomsg ) endsubroutine read_undelimited_listdirected subroutine read_undelimited ( dtv , unit , terminators , iostat , iomsg ) !< Read an undelimited string up until end of record or a character from a set of terminators is encountered. !< !< If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the !< file remains at end of record. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: terminators !< Characters that are considered to terminate the string. !< Blanks in this string are meaningful. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then ! end of record just means end of string. We pass on the condition return elseif ( iostat /= 0 ) then ! something odd happened return endif if ( scan ( ch , terminators ) /= 0 ) then ! change the file position so that the next read sees the terminator read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return iostat = 0 return endif ! we got a character - append it dtv % raw = dtv % raw // ch enddo endsubroutine read_undelimited subroutine write_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !< Formatted output. class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif endsubroutine write_formatted subroutine read_unformatted ( dtv , unit , iostat , iomsg ) !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endsubroutine read_unformatted subroutine write_unformatted ( dtv , unit , iostat , iomsg ) !< Unformatted output. class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif endsubroutine write_unformatted ! miscellanea elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !< Return a string with the first occurrence of substring old replaced by new. !< !< @note The doctest is not necessary, this being tested by [[string:replace]]. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif endif endif endfunction replace_one_occurrence ! non type-bound-procedures subroutine get_delimiter_mode ( unit , delim , iostat , iomsg ) !< Get the DELIM changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of NONE is always returned. use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit integer , intent ( in ) :: unit !< The unit for the connection. character ( len = 1 , kind = CK ), intent ( out ) :: delim !< Represents the value of the DELIM mode. integer , intent ( out ) :: iostat !< IOSTAT error code, non-zero on error. character ( * ), intent ( inout ) :: iomsg !< IOMSG explanatory message - only defined if iostat is non-zero. character ( 10 ) :: delim_buffer !< Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. ! get the string representation of the changeable mode inquire ( unit , delim = delim_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the DELIM mode for an internal file iostat = 0 delim = '' return elseif ( iostat /= 0 ) then iomsg = local_iomsg return endif ! interpret the DELIM string if ( delim_buffer == 'QUOTE' ) then delim = '\"' elseif ( delim_buffer == 'APOSTROPHE' ) then delim = '''' else delim = '\"' endif endsubroutine get_delimiter_mode subroutine get_next_non_blank_character_this_record ( unit , ch , iostat , iomsg ) !< Get the next non-blank character in the current record. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. do ! we spcify non-advancing, just in case we want this callable outside the context of a child input statement ! the PAD specifier simply saves the need for the READ statement to define ch if EOR is hit ! read(unit, \"(A)\", iostat=iostat, iomsg=iomsg, advance='NO') ch ! ...but that causes ifort to blow up at runtime read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg , pad = 'NO' ) ch if ( iostat /= 0 ) return if ( ch /= '' ) exit enddo endsubroutine get_next_non_blank_character_this_record subroutine get_next_non_blank_character_any_record ( unit , ch , iostat , iomsg ) !< Get the next non-blank character, advancing records if necessary. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. do call get_next_non_blank_character_this_record ( unit = unit , ch = ch , iostat = iostat , iomsg = local_iomsg ) if ( is_iostat_eor ( iostat )) then ! try again on the next record read ( unit , \"(/)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return elseif ( iostat /= 0 ) then ! some sort of problem iomsg = local_iomsg return else ! got it exit endif enddo endsubroutine get_next_non_blank_character_any_record subroutine get_decimal_mode ( unit , decimal_point , iostat , iomsg ) !< Get the DECIMAL changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the !< actual value in force at the time of the call to this procedure. use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit integer , intent ( in ) :: unit !< Logical unit. logical , intent ( out ) :: decimal_point !< True if the decimal mode is POINT, false otherwise. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( 5 ) :: decimal_buffer !< Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character ( len ( iomsg )) :: local_iomsg !< Local iomsg, so it doesn't get inappropriately redefined. inquire ( unit , decimal = decimal_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the decimal mode for an internal file iostat = 0 decimal_point = . true . return else if ( iostat /= 0 ) then iomsg = local_iomsg return endif decimal_point = decimal_buffer == 'POINT' endsubroutine get_decimal_mode endmodule stringifor_string_t","tags":"","loc":"sourcefile/stringifor_string_t.f90.html"},{"title":"stringifor_string_t-doctest-19.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-19.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-19.f90 stringifor_string_t-doctest-19.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-19.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % scan ( set = 'llo' ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = 'llo' , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-19.f90.html"},{"title":"stringifor_string_t-doctest-43.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-43.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-43.f90 stringifor_string_t-doctest-43.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-43.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 9 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) call astring % read_file ( file = 'read_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat ) test_passed ( 9 ) = ( iostat /= 0 ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-43.f90.html"},{"title":"stringifor_string_t-doctest-54.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-54.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-54.f90 stringifor_string_t-doctest-54.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-54.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = '  Hello World!   ' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-54.f90.html"},{"title":"stringifor_string_t-doctest-47.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-47.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-47.f90 stringifor_string_t-doctest-47.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-47.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = 'abcdefghilmnopqrstuvz' test_passed ( 1 ) = ( astring % reverse () // '' == 'zvutsrqponmlihgfedcba' ) astring = '0123456789' test_passed ( 2 ) = ( astring % reverse () // '' == '9876543210' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-47.f90.html"},{"title":"stringifor_string_t-doctest-101.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-101.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-101.f90 stringifor_string_t-doctest-101.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-101.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 3 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring <= anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring <= anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'ONE' test_passed ( 3 ) = (( astring <= anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-101.f90.html"},{"title":"stringifor_string_t-doctest-89.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-89.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-89.f90 stringifor_string_t-doctest-89.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-89.f90->sourcefile~stringifor_string_t.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring type ( string ) :: yetanotherstring logical :: test_passed ( 1 ) astring = 'Hello ' anotherstring = 'Bye bye' yetanotherstring = astring . cat . anotherstring test_passed ( 1 ) = yetanotherstring % chars () == 'Hello Bye bye' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-89.f90.html"}]}