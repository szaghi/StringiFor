var tipuesearch = {"pages":[{"text":"StringiFor StringiFor StringiFor, Strings Fortran Manipulator, yet another strings Fortran module A KISS pure Fortran library providing  astrings (class) manipulator for modern (2003+) Fortran projects. StringiFor is a pure Fortran (KISS) library providing a strings manipulator for modern Fortran projects; StringiFor is Fortran 2003+ standard compliant; StringiFor is OOP designed; StringiFor is TDD designed; StringiFor is a Free, Open Source Project. Table of Contents What is StringiFor? Main features Copyrights Documentation A Taste of StringiFor Issues Compiler Support GNU partial support GNU gfortran does not support user-defined-type-IO, thus some class features are disabled if GNU is used. What is StringiFor? Modern Fortran standards (2003+) have introduced a better support for characters variables, but Fortraners still do not have the power on dealing with strings of other more-rich-programmers, e.g. Pythoners. Allocatable deferred length character variables are now quantum-leap with respect the old inflexible Fortran characters, but it is still not enough for many Fortraners. Moreover, Fortran does not provide builtin methods for widely used strings manipulations offered by other languages, e.g. UPPER/lowercase transformation, tokenization, etc… StringiFor attempts to fill this lack. Go to Top Main features StringiFor exposes only one class (OO-designed), the string type, that should be used as a more powerful string variable with respect a standard Fortran character variable. The main features of this class are: seamless interchangeability with standard character variables, i.e.: I/O operation (disabled if GNU gfortran is used); string/character concatenation; string/character assignment; handy builtin methods: UPPER/lower case transformartion; tokenization; number-to-string (and viceversa) casting; Any feature request is welcome. Go to Top Copyrights StringiFor is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to StringiFor is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the StringiFor documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of StringiFor To be written. Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" StringiFor "},{"text":"StringiFor, Strings Fortran, yet another stringify Fortran module Source Code !< StringiFor, Strings Fortran, yet another stringify Fortran module module stringifor !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor, Strings Fortran, yet another stringify Fortran module !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: string !< OOP designed string class. !< !< Provides: !< !< * [X] seamless interchangeability with standard character variables, i.e.: !<   + [X] I/O operation; !<   + [X] string/character concatenation; !<   + [X] string/character assignment; !< * [ ] handy builtin methods: !<   + [ ] UPPER/lower case transformartion; !<   + [ ] tokenization; !<   + [ ] number-to-string (and viceversa) casting; private character ( len = :), allocatable :: raw !< Raw data. contains ! public methods procedure , pass ( self ) :: chars !< Return the raw characters data. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character !< Assignment operator overloading. generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. ! builtins replacements procedure , pass ( self ) :: sadjustl !< Adjustl replacement. procedure , pass ( self ) :: sadjustr !< Adjustr replacement. procedure , pass ( self ) :: sindex !< Index replacement. procedure , pass ( self ) :: slen !< Len replacement. procedure , pass ( self ) :: slen_trim !< Len_trim replacement. procedure , nopass :: srepeat !< Repeat replacement. procedure , pass ( self ) :: sscan !< Scan replacement. procedure , pass ( self ) :: strim !< Trim replacement. procedure , pass ( self ) :: sverify !< Verify replacement. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted_ !< Formatted input. generic :: write ( formatted ) => write_formatted_ !< Formatted output. generic :: read ( unformatted ) => read_unformatted_ !< Unformatted input. generic :: write ( unformatted ) => write_unformatted_ !< Unformatted output. #else procedure , pass ( dtv ) :: read_formatted => read_formatted_ !< Formatted input. procedure , pass ( dtv ) :: read_formatted_internal !< Formatted input from internal. procedure , pass ( dtv ) :: write_formatted => write_formatted_ !< Formatted output. procedure , pass ( dtv ) :: write_formatted_internal !< Formatted output to internal. #endif ! private methods procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). procedure , private , pass ( dtv ) :: read_formatted_ !< Formatted input. procedure , private , pass ( dtv ) :: write_formatted_ !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted_ !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted_ !< Unformatted output. endtype string !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars pure function sadjustl ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl pure function sadjustr ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr pure function sindex ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex pure function slen ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen pure function slen_trim ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string, ignoring any trailing blanks. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen_trim pure function srepeat ( rstring , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = rstring , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat pure function sscan ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan pure function strim ( self ) result ( trimmed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Remove leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strim pure function sverify ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sverify ! private methods elemental subroutine string_assign_string ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from string input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) lhs % raw = rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_string elemental subroutine string_assign_character ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from character input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( len =* ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_character pure function string_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string pure function string_concat_character ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( len =* ), intent ( in ) :: rhs !< Right hand side. character ( len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character pure function character_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string pure function string_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( len = :), allocatable :: temporary !< Temporary concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string_string pure function string_concat_character_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character_string pure function character_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string_string subroutine read_formatted_ ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted_ subroutine read_formatted_internal ( dtv , iunit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input from internal. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. character ( len =* ), intent ( in ) :: iunit !< Internal unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted_internal subroutine write_formatted_ ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted_ subroutine write_formatted_internal ( dtv , iunit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output to internal. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. character ( len =* ), intent ( inout ) :: iunit !< Interanl unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted_internal subroutine read_unformatted_ ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_unformatted_ subroutine write_unformatted_ ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_unformatted_ endmodule stringifor","tags":"","loc":"sourcefile/stringifor.f90.html","title":"stringifor.F90 – StringiFor"},{"text":"StringiFor concatenation test. Source Code !< StringiFor `concatenation` test. program concatenation !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `concatenation` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ) :: yetanotherstring !< Yet another string. character ( len = :), allocatable :: acharacter !< A character. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- astring = 'Hello ' anotherstring = 'Bye bye' acharacter = 'World!' write ( stdout , \"(A)\" ) astring // acharacter write ( stdout , \"(A)\" ) acharacter // astring write ( stdout , \"(A)\" ) astring // anotherstring yetanotherstring = astring . cat . acharacter write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = acharacter . cat . astring write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = astring . cat . anotherstring write ( stdout , \"(A)\" ) yetanotherstring % chars () stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram concatenation","tags":"","loc":"sourcefile/concatenation.f90.html","title":"concatenation.f90 – StringiFor"},{"text":"StringiFor io_basic test. Source Code !< StringiFor `io_basic` test. program io_basic !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `io_basic` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- astring = 'Hello World!' acharacter = 'New Hello World!' #ifndef __GFORTRAN__ write ( stdout , \"(DT)\" ) astring read ( acharacter , \"(DT)\" ) astring print \"(DT)\" , astring #else call astring % write_formatted ( stdout , \"(DT)\" , [ 1 ], iostat , iomsg ) call astring % read_formatted_internal ( acharacter , \"(DT)\" , [ 1 ], iostat , iomsg ) write ( stdout , \"(A)\" ) astring % chars () #endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram io_basic","tags":"","loc":"sourcefile/io_basic.f90.html","title":"io_basic.F90 – StringiFor"},{"text":"StringiFor sadjustlr test. Source Code !< StringiFor `sadjustlr` test. program sadjustlr !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sadjustlr` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- astring = '   Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'AdjustL:  \"' // astring % sadjustl () // '\"' astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'AdjustR:  \"' // astring % sadjustr () // '\"' stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sadjustlr","tags":"","loc":"sourcefile/sadjustlr.f90.html","title":"sadjustlr.f90 – StringiFor"},{"text":"StringiFor sindex test. Source Code !< StringiFor `sindex` test. program sindex !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sindex` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sindex ( substring = anothercharacter ) ic = index ( string = acharacter , substring = anothercharacter ) write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sindex ( substring = anothercharacter , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sindex","tags":"","loc":"sourcefile/sindex.f90.html","title":"sindex.f90 – StringiFor"},{"text":"StringiFor slen test. Source Code !< StringiFor `slen` test. program slen !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `slen` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,I2)\" ) 'Len: ' , astring % slen () write ( stdout , \"(A,I2)\" ) 'Len_trim: ' , astring % slen_trim () stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram slen","tags":"","loc":"sourcefile/slen.f90.html","title":"slen.f90 – StringiFor"},{"text":"StringiFor srepeat test. Source Code !< StringiFor `srepeat` test. program srepeat !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `srepeat` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- write ( stdout , \"(A,I2)\" ) 'Repeat x 5 times: \"' // astring % srepeat ( rstring = 'x' , ncopies = 5 ) // '\"' stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram srepeat","tags":"","loc":"sourcefile/srepeat.f90.html","title":"srepeat.f90 – StringiFor"},{"text":"StringiFor sscan test. Source Code !< StringiFor `sscan` test. program sscan !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sscan` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sscan ( set = anothercharacter ) ic = scan ( string = acharacter , set = anothercharacter ) write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sscan ( set = anothercharacter , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sscan","tags":"","loc":"sourcefile/sscan.f90.html","title":"sscan.f90 – StringiFor"},{"text":"StringiFor strim test. Source Code !< StringiFor `strim` test. program strim !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strim` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Trimmed:  \"' // astring % strim () // '\"' stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strim","tags":"","loc":"sourcefile/strim.f90.html","title":"strim.f90 – StringiFor"},{"text":"StringiFor sverify test. Source Code !< StringiFor `sverify` test. program sverify !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sverify` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sverify ( set = anothercharacter ) ic = verify ( string = acharacter , set = anothercharacter ) write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sverify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic anothercharacter = acharacter i = astring % sverify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) write ( stdout , \"(A,I2,A,L1)\" ) 'Identical strings call result: ' , i , ' is correct? ' , i == ic stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sverify","tags":"","loc":"sourcefile/sverify.f90.html","title":"sverify.f90 – StringiFor"},{"text":"type, public :: string OOP designed string class. Provides: seamless interchangeability with standard character variables, i.e.: I/O operation; string/character concatenation; string/character assignment; handy builtin methods: UPPER/lower case transformartion; tokenization; number-to-string (and viceversa) casting; Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: chars Return the raw characters data. private pure function chars (self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(len=:),\n  allocatable Raw characters data. Description Return the raw characters data. generic, public :: assignment(=) => string_assign_string , string_assign_character Assignment operator overloading. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. generic, public :: operator(//) => string_concat_string , string_concat_character , character_concat_string Concatenation operator overloading. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(len=:),\n  allocatable Concatenated string. Description Concatenation with string. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value character(len=:),\n  allocatable Concatenated string. Description Concatenation with character. private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). generic, public :: operator(.cat.) => string_concat_string_string , string_concat_character_string , character_concat_string_string Concatenation operator (string output) overloading. private pure function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. private pure function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. private pure function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). procedure, public, pass(self) :: sadjustl Adjustl replacement. private pure function sadjustl (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. procedure, public, pass(self) :: sadjustr Adjustr replacement. private pure function sadjustr (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. procedure, public, pass(self) :: sindex Index replacement. private pure function sindex (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. procedure, public, pass(self) :: slen Len replacement. private pure function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. procedure, public, pass(self) :: slen_trim Len_trim replacement. private pure function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer <\np S\nt\nr\ni\nn\ng l\ne\nn\ng\nt\nh\n.\n<\n/\np Description Return the length of a string, ignoring any trailing blanks. procedure, public, nopass :: srepeat Repeat replacement. private pure function srepeat (rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. procedure, public, pass(self) :: sscan Scan replacement. private pure function sscan (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . procedure, public, pass(self) :: strim Trim replacement. private pure function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. procedure, public, pass(self) :: sverify Verify replacement. private pure function sverify (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. procedure, public, pass(dtv) :: read_formatted => read_formatted_ Formatted input. private subroutine read_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. procedure, public, pass(dtv) :: read_formatted_internal Formatted input from internal. private subroutine read_formatted_internal (dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. character(len=*), intent(in) :: iunit Internal unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input from internal. procedure, public, pass(dtv) :: write_formatted => write_formatted_ Formatted output. private subroutine write_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted output. procedure, public, pass(dtv) :: write_formatted_internal Formatted output to internal. private subroutine write_formatted_internal (dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. character(len=*), intent(inout) :: iunit Interanl unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted output to internal. procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(len=:),\n  allocatable Concatenated string. Description Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value character(len=:),\n  allocatable Concatenated string. Description Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). private pure function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). private pure function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). private pure function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). procedure, private, pass(dtv) :: read_formatted_ Formatted input. private subroutine read_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. procedure, private, pass(dtv) :: write_formatted_ Formatted output. private subroutine write_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted output. procedure, private, pass(dtv) :: read_unformatted_ Unformatted input. private subroutine read_unformatted_ (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. procedure, private, pass(dtv) :: write_unformatted_ Unformatted output. private subroutine write_unformatted_ (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. Source Code type :: string !< OOP designed string class. !< !< Provides: !< !< * [X] seamless interchangeability with standard character variables, i.e.: !<   + [X] I/O operation; !<   + [X] string/character concatenation; !<   + [X] string/character assignment; !< * [ ] handy builtin methods: !<   + [ ] UPPER/lower case transformartion; !<   + [ ] tokenization; !<   + [ ] number-to-string (and viceversa) casting; private character ( len = :), allocatable :: raw !< Raw data. contains ! public methods procedure , pass ( self ) :: chars !< Return the raw characters data. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character !< Assignment operator overloading. generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. ! builtins replacements procedure , pass ( self ) :: sadjustl !< Adjustl replacement. procedure , pass ( self ) :: sadjustr !< Adjustr replacement. procedure , pass ( self ) :: sindex !< Index replacement. procedure , pass ( self ) :: slen !< Len replacement. procedure , pass ( self ) :: slen_trim !< Len_trim replacement. procedure , nopass :: srepeat !< Repeat replacement. procedure , pass ( self ) :: sscan !< Scan replacement. procedure , pass ( self ) :: strim !< Trim replacement. procedure , pass ( self ) :: sverify !< Verify replacement. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted_ !< Formatted input. generic :: write ( formatted ) => write_formatted_ !< Formatted output. generic :: read ( unformatted ) => read_unformatted_ !< Unformatted input. generic :: write ( unformatted ) => write_unformatted_ !< Unformatted output. #else procedure , pass ( dtv ) :: read_formatted => read_formatted_ !< Formatted input. procedure , pass ( dtv ) :: read_formatted_internal !< Formatted input from internal. procedure , pass ( dtv ) :: write_formatted => write_formatted_ !< Formatted output. procedure , pass ( dtv ) :: write_formatted_internal !< Formatted output to internal. #endif ! private methods procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). procedure , private , pass ( dtv ) :: read_formatted_ !< Formatted input. procedure , private , pass ( dtv ) :: write_formatted_ !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted_ !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted_ !< Unformatted output. endtype string","tags":"","loc":"type/string.html","title":"string – StringiFor "},{"text":"private pure function chars(self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(len=:),\n  allocatable Raw characters data. Description Return the raw characters data. Source Code pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars","tags":"","loc":"proc/chars.html","title":"chars – StringiFor"},{"text":"private pure function sadjustl(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. Source Code pure function sadjustl ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl","tags":"","loc":"proc/sadjustl.html","title":"sadjustl – StringiFor"},{"text":"private pure function sadjustr(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. Source Code pure function sadjustr ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr","tags":"","loc":"proc/sadjustr.html","title":"sadjustr – StringiFor"},{"text":"private pure function sindex(self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Source Code pure function sindex ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex","tags":"","loc":"proc/sindex.html","title":"sindex – StringiFor"},{"text":"private pure function slen(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. Source Code pure function slen ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen","tags":"","loc":"proc/slen.html","title":"slen – StringiFor"},{"text":"private pure function slen_trim(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. Source Code pure function slen_trim ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string, ignoring any trailing blanks. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen_trim","tags":"","loc":"proc/slen_trim.html","title":"slen_trim – StringiFor"},{"text":"private pure function srepeat(rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Source Code pure function srepeat ( rstring , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = rstring , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat","tags":"","loc":"proc/srepeat.html","title":"srepeat – StringiFor"},{"text":"private pure function sscan(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Source Code pure function sscan ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan","tags":"","loc":"proc/sscan.html","title":"sscan – StringiFor"},{"text":"private pure function strim(self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. Source Code pure function strim ( self ) result ( trimmed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Remove leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strim","tags":"","loc":"proc/strim.html","title":"strim – StringiFor"},{"text":"private pure function sverify(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Source Code pure function sverify ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sverify","tags":"","loc":"proc/sverify.html","title":"sverify – StringiFor"},{"text":"private pure function string_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(len=:),\n  allocatable Concatenated string. Description Concatenation with string. Source Code pure function string_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string","tags":"","loc":"proc/string_concat_string.html","title":"string_concat_string – StringiFor"},{"text":"private pure function string_concat_character(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value character(len=:),\n  allocatable Concatenated string. Description Concatenation with character. Source Code pure function string_concat_character ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( len =* ), intent ( in ) :: rhs !< Right hand side. character ( len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character","tags":"","loc":"proc/string_concat_character.html","title":"string_concat_character – StringiFor"},{"text":"private pure function character_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). Source Code pure function character_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string","tags":"","loc":"proc/character_concat_string.html","title":"character_concat_string – StringiFor"},{"text":"private pure function string_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: temporary Temporary concatenated string. Source Code pure function string_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( len = :), allocatable :: temporary !< Temporary concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string_string","tags":"","loc":"proc/string_concat_string_string.html","title":"string_concat_string_string – StringiFor"},{"text":"private pure function string_concat_character_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. Source Code pure function string_concat_character_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character_string","tags":"","loc":"proc/string_concat_character_string.html","title":"string_concat_character_string – StringiFor"},{"text":"private pure function character_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). Source Code pure function character_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string_string","tags":"","loc":"proc/character_concat_string_string.html","title":"character_concat_string_string – StringiFor"},{"text":"private elemental subroutine string_assign_string(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. Source Code elemental subroutine string_assign_string ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from string input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) lhs % raw = rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_string","tags":"","loc":"proc/string_assign_string.html","title":"string_assign_string – StringiFor"},{"text":"private elemental subroutine string_assign_character(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. Source Code elemental subroutine string_assign_character ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from character input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( len =* ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_character","tags":"","loc":"proc/string_assign_character.html","title":"string_assign_character – StringiFor"},{"text":"private subroutine read_formatted_(dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Variables Type Visibility Attributes Name Initial character(len=100), public :: temporary Temporary storage string. Source Code subroutine read_formatted_ ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted_","tags":"","loc":"proc/read_formatted_.html","title":"read_formatted_ – StringiFor"},{"text":"private subroutine read_formatted_internal(dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. character(len=*), intent(in) :: iunit Internal unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input from internal. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Variables Type Visibility Attributes Name Initial character(len=100), public :: temporary Temporary storage string. Source Code subroutine read_formatted_internal ( dtv , iunit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input from internal. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. character ( len =* ), intent ( in ) :: iunit !< Internal unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted_internal","tags":"","loc":"proc/read_formatted_internal.html","title":"read_formatted_internal – StringiFor"},{"text":"private subroutine write_formatted_(dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted output. Source Code subroutine write_formatted_ ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted_","tags":"","loc":"proc/write_formatted_.html","title":"write_formatted_ – StringiFor"},{"text":"private subroutine write_formatted_internal(dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. character(len=*), intent(inout) :: iunit Interanl unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted output to internal. Source Code subroutine write_formatted_internal ( dtv , iunit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output to internal. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. character ( len =* ), intent ( inout ) :: iunit !< Interanl unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted_internal","tags":"","loc":"proc/write_formatted_internal.html","title":"write_formatted_internal – StringiFor"},{"text":"private subroutine read_unformatted_(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Variables Type Visibility Attributes Name Initial character(len=100), public :: temporary Temporary storage string. Source Code subroutine read_unformatted_ ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_unformatted_","tags":"","loc":"proc/read_unformatted_.html","title":"read_unformatted_ – StringiFor"},{"text":"private subroutine write_unformatted_(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. Source Code subroutine write_unformatted_ ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_unformatted_","tags":"","loc":"proc/write_unformatted_.html","title":"write_unformatted_ – StringiFor"},{"text":"StringiFor, Strings Fortran, yet another stringify Fortran module Used By module~~stringifor~~UsedByGraph module~stringifor stringifor program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~sindex sindex module~stringifor->program~sindex program~slen slen module~stringifor->program~slen program~sverify sverify module~stringifor->program~sverify program~srepeat srepeat module~stringifor->program~srepeat program~io_basic io_basic module~stringifor->program~io_basic program~concatenation concatenation module~stringifor->program~concatenation program~sscan sscan module~stringifor->program~sscan program~strim strim module~stringifor->program~strim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: string Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: chars Return the raw characters data. generic, public :: assignment(=) => string_assign_string, string_assign_character Assignment operator overloading. generic, public :: operator(//) => string_concat_string, string_concat_character, character_concat_string Concatenation operator overloading. generic, public :: operator(.cat.) => string_concat_string_string, string_concat_character_string, character_concat_string_string Concatenation operator (string output) overloading. procedure, public, pass(self) :: sadjustl Adjustl replacement. procedure, public, pass(self) :: sadjustr Adjustr replacement. procedure, public, pass(self) :: sindex Index replacement. procedure, public, pass(self) :: slen Len replacement. procedure, public, pass(self) :: slen_trim Len_trim replacement. procedure, public, nopass :: srepeat Repeat replacement. procedure, public, pass(self) :: sscan Scan replacement. procedure, public, pass(self) :: strim Trim replacement. procedure, public, pass(self) :: sverify Verify replacement. procedure, public, pass(dtv) :: read_formatted => read_formatted_ Formatted input. procedure, public, pass(dtv) :: read_formatted_internal Formatted input from internal. procedure, public, pass(dtv) :: write_formatted => write_formatted_ Formatted output. procedure, public, pass(dtv) :: write_formatted_internal Formatted output to internal. procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). procedure, private, pass(dtv) :: read_formatted_ Formatted input. procedure, private, pass(dtv) :: write_formatted_ Formatted output. procedure, private, pass(dtv) :: read_unformatted_ Unformatted input. procedure, private, pass(dtv) :: write_unformatted_ Unformatted output. Description OOP designed string class. Functions private pure function chars (self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(len=:),\n  allocatable Raw characters data. Description Return the raw characters data. private pure function sadjustl (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. private pure function sadjustr (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. private pure function sindex (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. private pure function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. private pure function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer <\np S\nt\nr\ni\nn\ng l\ne\nn\ng\nt\nh\n.\n<\n/\np Description Return the length of a string, ignoring any trailing blanks. private pure function srepeat (rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. private pure function sscan (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . private pure function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. private pure function sverify (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(len=:),\n  allocatable Concatenated string. Description Concatenation with string. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value character(len=:),\n  allocatable Concatenated string. Description Concatenation with character. private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). private pure function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. private pure function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. private pure function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). Subroutines private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. private subroutine read_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. private subroutine read_formatted_internal (dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. character(len=*), intent(in) :: iunit Internal unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input from internal. private subroutine write_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted output. private subroutine write_formatted_internal (dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. character(len=*), intent(inout) :: iunit Interanl unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted output to internal. private subroutine read_unformatted_ (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. private subroutine write_unformatted_ (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Unformatted output.","tags":"","loc":"module/stringifor.html","title":"stringifor – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~concatenation~~UsesGraph program~concatenation concatenation iso_fortran_env iso_fortran_env iso_fortran_env->program~concatenation module~stringifor stringifor module~stringifor->program~concatenation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor concatenation test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring Another string. type( string ) :: yetanotherstring Yet another string. character(len=:), allocatable :: acharacter A character. Source Code program concatenation !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `concatenation` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ) :: yetanotherstring !< Yet another string. character ( len = :), allocatable :: acharacter !< A character. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- astring = 'Hello ' anotherstring = 'Bye bye' acharacter = 'World!' write ( stdout , \"(A)\" ) astring // acharacter write ( stdout , \"(A)\" ) acharacter // astring write ( stdout , \"(A)\" ) astring // anotherstring yetanotherstring = astring . cat . acharacter write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = acharacter . cat . astring write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = astring . cat . anotherstring write ( stdout , \"(A)\" ) yetanotherstring % chars () stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram concatenation","tags":"","loc":"program/concatenation.html","title":"concatenation – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~io_basic~~UsesGraph program~io_basic io_basic iso_fortran_env iso_fortran_env iso_fortran_env->program~io_basic module~stringifor stringifor module~stringifor->program~io_basic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor io_basic test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. integer :: iostat IO status code. character(len=99) :: iomsg IO status message. Source Code program io_basic !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `io_basic` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- astring = 'Hello World!' acharacter = 'New Hello World!' #ifndef __GFORTRAN__ write ( stdout , \"(DT)\" ) astring read ( acharacter , \"(DT)\" ) astring print \"(DT)\" , astring #else call astring % write_formatted ( stdout , \"(DT)\" , [ 1 ], iostat , iomsg ) call astring % read_formatted_internal ( acharacter , \"(DT)\" , [ 1 ], iostat , iomsg ) write ( stdout , \"(A)\" ) astring % chars () #endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram io_basic","tags":"","loc":"program/io_basic.html","title":"io_basic – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sadjustlr~~UsesGraph program~sadjustlr sadjustlr iso_fortran_env iso_fortran_env iso_fortran_env->program~sadjustlr module~stringifor stringifor module~stringifor->program~sadjustlr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sadjustlr test. Variables Type Attributes Name Initial type( string ) :: astring A string. Source Code program sadjustlr !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sadjustlr` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- astring = '   Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'AdjustL:  \"' // astring % sadjustl () // '\"' astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'AdjustR:  \"' // astring % sadjustr () // '\"' stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sadjustlr","tags":"","loc":"program/sadjustlr.html","title":"sadjustlr – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sindex~~UsesGraph program~sindex sindex iso_fortran_env iso_fortran_env iso_fortran_env->program~sindex module~stringifor stringifor module~stringifor->program~sindex Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sindex test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. character(len=:), allocatable :: anothercharacter Another character. integer :: i Index result. integer :: ic Index result comparison. Source Code program sindex !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sindex` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sindex ( substring = anothercharacter ) ic = index ( string = acharacter , substring = anothercharacter ) write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sindex ( substring = anothercharacter , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sindex","tags":"","loc":"program/sindex.html","title":"sindex – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~slen~~UsesGraph program~slen slen iso_fortran_env iso_fortran_env iso_fortran_env->program~slen module~stringifor stringifor module~stringifor->program~slen Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor slen test. Variables Type Attributes Name Initial type( string ) :: astring A string. Source Code program slen !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `slen` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,I2)\" ) 'Len: ' , astring % slen () write ( stdout , \"(A,I2)\" ) 'Len_trim: ' , astring % slen_trim () stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram slen","tags":"","loc":"program/slen.html","title":"slen – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~srepeat~~UsesGraph program~srepeat srepeat iso_fortran_env iso_fortran_env iso_fortran_env->program~srepeat module~stringifor stringifor module~stringifor->program~srepeat Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor srepeat test. Variables Type Attributes Name Initial type( string ) :: astring A string. Source Code program srepeat !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `srepeat` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- write ( stdout , \"(A,I2)\" ) 'Repeat x 5 times: \"' // astring % srepeat ( rstring = 'x' , ncopies = 5 ) // '\"' stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram srepeat","tags":"","loc":"program/srepeat.html","title":"srepeat – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sscan~~UsesGraph program~sscan sscan iso_fortran_env iso_fortran_env iso_fortran_env->program~sscan module~stringifor stringifor module~stringifor->program~sscan Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sscan test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. character(len=:), allocatable :: anothercharacter Another character. integer :: i Index result. integer :: ic Index result comparison. Source Code program sscan !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sscan` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sscan ( set = anothercharacter ) ic = scan ( string = acharacter , set = anothercharacter ) write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sscan ( set = anothercharacter , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sscan","tags":"","loc":"program/sscan.html","title":"sscan – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~strim~~UsesGraph program~strim strim iso_fortran_env iso_fortran_env iso_fortran_env->program~strim module~stringifor stringifor module~stringifor->program~strim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor strim test. Variables Type Attributes Name Initial type( string ) :: astring A string. Source Code program strim !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strim` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Trimmed:  \"' // astring % strim () // '\"' stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strim","tags":"","loc":"program/strim.html","title":"strim – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sverify~~UsesGraph program~sverify sverify iso_fortran_env iso_fortran_env iso_fortran_env->program~sverify module~stringifor stringifor module~stringifor->program~sverify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sverify test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. character(len=:), allocatable :: anothercharacter Another character. integer :: i Index result. integer :: ic Index result comparison. Source Code program sverify !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sverify` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sverify ( set = anothercharacter ) ic = verify ( string = acharacter , set = anothercharacter ) write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sverify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic anothercharacter = acharacter i = astring % sverify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) write ( stdout , \"(A,I2,A,L1)\" ) 'Identical strings call result: ' , i , ' is correct? ' , i == ic stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sverify","tags":"","loc":"program/sverify.html","title":"sverify – StringiFor"}]}