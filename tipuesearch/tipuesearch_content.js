var tipuesearch = {"pages":[{"title":" StringiFor ","text":"StringiFor StringiFor StringiFor, Strings Fortran Manipulator, yet another strings Fortran module A KISS pure Fortran library providing  astrings (class) manipulator for modern (2003+) Fortran projects. StringiFor is a pure Fortran (KISS) library providing a strings manipulator for modern Fortran projects; StringiFor is Fortran 2003+ standard compliant; StringiFor is OOP designed; StringiFor is TDD designed; StringiFor is a Free, Open Source Project. Issues Compiler Support What is StringiFor? | Main features | Copyrights | Download | Compilation | Documentation | Comparison to other Approaches What is StringiFor? Modern Fortran standards (2003+) have introduced a better support for characters variables, but Fortraners still do not have the power on dealing with strings of other more-rich-programmers, e.g. Pythoners. Allocatable deferred length character variables are now quantum-leap with respect the old inflexible Fortran characters, but it is still not enough for many Fortraners. Moreover, Fortran does not provide builtin methods for widely used strings manipulations offered by other languages, e.g. UPPER/lowercase transformation, tokenization, etc… StringiFor attempts to fill this lack. Go to Top Main features StringiFor exposes only one class (OO-designed), the string type, that should be used as a more powerful string variable with respect a standard Fortran character variable. The main features of this class are: [x] seamless interchangeability with standard character variables, e.g. concatenation, IO, etc…; [x] handy builtin methods, e.g. split, search, basename, join, etc…; [x] low memory consumption: only one deferred length allocatable character member is stored, allowing for efficient memory allocation in array of strings, the elements of which can have different lengths; [x] safe: almost all methods are elemental or pure; [x] robust: the library is Test Driven Developed TDD , a comprehensive tests suite is provided. Any feature request is welcome. Go to Top A Taste of StringiFor StringiFor is very handy… Basic IO String manipulation Numbers handling Complex scenario Basic IO The class string IO is overloaded by defined write/read TBP. Moreover, dedicated methods and operators can be exploited for IO, e.g. use stringifor type ( string ) :: astring astring = 'Hello World' print \"(A)\" , astring % chars () ! \"chars\" method returns a standard character variable print \"(DT)\" , astring ! defined IO (in gfortran is available for GNU GCC >= 7.1) print \"(A)\" , astring // '' ! on-the-fly conversion to standard character by means of concatenation String manipulation The class string has many methods for a plethora of strings manipulations, e.g. use stringifor type ( string ) :: astring type ( string ) :: strings ( 3 ) astring = '0123456789' print \"(A)\" , astring % reverse () // '' ! print \"9876543210\" astring = 'Hello World' print \"(A)\" , astring % replace ( old = 'World' , new = 'People' ) // '' ! print \"Hello People\" astring = 'Hello World' strings = astring % partition ( sep = 'lo Wo' ) print \"(A)\" , 'Before sep: \"' // strings ( 1 ) // '\"' ! print \"Hel\" print \"(A)\" , 'Sep itself: \"' // strings ( 2 ) // '\"' ! print \"lo Wo\" print \"(A)\" , 'After sep:  \"' // strings ( 3 ) // '\"' ! print \"rld\" strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' print \"(A)\" , astring % join ( strings ) // '' ! print \"oneHello WorldtwoHello Worldthree\" print \"(A)\" , astring % join ( strings , sep = '-' ) // '' ! print \"one-two-three\" astring = ' a StraNgE caSe var' print \"(A)\" , astring % camelcase () // '' ! print \" AStrangeCaseVar\" print \"(A)\" , astring % snakecase () // '' ! print \" a_strange_case_var\" print \"(A)\" , astring % startcase () // '' ! print \" A Strange Case Var\" Numbers handling StringiFor, by means of the portability environment library, PENF can handle numbers (reals and integers) effortless. The string/number casting (to/from and viceversa) is done by overloaded assignments (for all kinds of integers and reals). For convenience, StringiFor exposes the PENF number portable kind parameters. use stringifor type ( string ) :: astring astring = 127 _ I1P ! \"I1P\" is the PENF kind for 1-byte-like integer. print \"(A)\" , astring // '' ! print \"+127\" astring = 3.021e6_R4P ! \"R4P\" is the PENF kind for 4-byte-like real. print \"(A)\" , astring // '' ! print \"+0.302100E+07\" astring = \"3.4e9\" ! assign to a string without the necessity to define a real kind if ( astring % is_number ()) then if ( astring % is_real ()) then print \"(E13.6)\" , astring % to_number ( kind = 1._R4P ) ! print \" 0.340000E+10\" using a 4-byte-like kind endif endif Complex scenario StingiFor is developed to improve the poor Fortran people with daily strings-usage, however, also complex scenario is taken into account, e.g. file parsing, OS operations, etc… use stringifor type ( string ) :: astring ! OS like manipulation astring = '/bar/foo.tar.bz2' print \"(A)\" , astring % basedir () // '' ! print \"/bar\" print \"(A)\" , astring % basename () // '' ! print \"foo.tar.bz2\" print \"(A)\" , astring % basename ( extension = '.tar' ) // '' ! print \"foo\" print \"(A)\" , astring % basename ( strip_last_extension = . true .) // '' ! print \"foo.tar\" ! XML like tag parsing astring = '<test> <first> hello </first> <first> not the first </first> </test>' print \"(A)\" , astring % search ( tag_start = '<first>' , tag_end = '</first>' ) // '' ! print \"<first> hello </first>\" A naive CSV parser This is just a provocation, but with StringiFor it is easy to develop a naive CSV parser. Let us assume we want to parse a cars-price database as the following one Year, Make, Model, Description, Price\n1997, Ford, E350   , ac abs moon, 3000.00\n1999, Chevy, Venture \"Extended Edition\"  , , 4900.00\n1999, Chevy, Venture \"Extended Edition Very Large\", , 5000.00 Well, parsing it and handling its cells values is very easy by means of StringiFor use stringifor implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. type ( string ) :: most_expensive !< The most expensive car. real ( R8P ) :: highest_cost !< The highest cost. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: r !< Counter. ! parsing the just created CSV file: all done 9 statements! call csv % read_file ( file = 'cars.csv' ) ! read the CSV file as a single stream call csv % split ( tokens = rows , sep = new_line ( 'a' )) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' print \"(A)\" , '|' // repeat ( '----|' , size ( columns )) ! printing separators do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' ! find the most expensive car print \"(A)\" , 'Searching for the most expensive car' most_expensive = 'unknown' highest_cost = - 1._R8P do r = 2 , rows_number if ( cells ( 5 , r )% to_number ( kind = 1._R8P ) >= highest_cost ) then highest_cost = cells ( 5 , r )% to_number ( kind = 1._R8P ) most_expensive = csv % join ( array = [ cells ( 2 , r ), cells ( 3 , r )], sep = ' ' ) endif enddo print \"(A)\" , 'The most expensive car is : ' // most_expensive See the test program csv_naive_parser for a working example. Obviously, this is a naive parser without any robustness, but it proves the usefulness of the StringiFor approach. Go to Top Copyrights StringiFor is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to StringiFor is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Download StringiFor home is at https://github.com/szaghi/StringiFor . It uses git submodule to handle the third party dependencies. To download all the source files you can: clone this repository (all dependencies are satisfied): git clone https://github.com/szaghi/StringiFor cd StringiFor git submodule update --init download only the StringiFor sources, all other dependencies must be downloaded manually: download the latest master-branch archive: wget https://github.com/szaghi/StringiFor/archive/master.zip unzip StringiFor-master.zip cd StringiFor-master git submodule update --init download a release archive at https://github.com/szaghi/StringiFor/releases Third Party dependencies Currently StringiFor depends on: FACE PENF BeFoR64 The third party libraries are necessary for building StringiFor. StringiFor is constantly made up-to-date with third party libraries master branch or their latest release. If you download a release of StringiFor manually (without git) you must download manually the above dependencies and place them into src/third_party sub-directory of the project root-tree. Go to Top Compilation StringiFor is a modern Fortran project thus a modern Fortran compiler is need to compile the project. In the following table the support for some widely-used Fortran compilers is summarized. Compiler Vendor Support Notes full support full support not tested not tested not tested not tested The library is modular, namely it exploits Fortran modules. As a consequence, there is compilation-cascade hierarchy to build the library. To correctly build the library the following approaches are supported Build by means of FoBiS : full support; Build by means of GNU Make : support for GNU Make is not provided, a Makefile is provided, but it is likely outdated and could not work as expected. Help for maintaining GNU Make support is strongly welcome, feel free to join this progect. Build by means of CMake : support for CMake is not provide, some CMake support is provided by great users, but it could be outdated. Help for maintaining CMake support is strongly welcome, feel free to join this progect. The FoBiS building support is the most complete and the only one officially supported by the author, as it is the one used for the developing StringiFor. Build by means of FoBiS A fobos file is provided to build the library by means of the Fortran Building System FoBiS . Build all tests Type FoBiS.py build After (a successuful) building a directory ./exe is created containing all the compiled tests that constitute the StringiFor regression-tests-suite , e.g. → FoBiS.py build\nBuilder options\nDirectories\n  Building directory: \"exe\" Compiled-objects .o   directory: \"exe/obj\" Compiled-objects .mod directory: \"exe/mod\" Compiler options\n  Vendor: \"gnu\" Compiler command: \"gfortran\" Module directory switch: \"-J\" Compiling flags: \"-c -frealloc-lhs -std=f2008 -fall-intrinsics -O2 -Dr16p\" Linking flags: \"-O2\" Preprocessing flags: \"-Dr16p\" Coverage: False\n  Profile: False\nPreForM.py used: False\nPreForM.py output directory: None\nPreForM.py extensions processed: [] Building src/tests/is_real.f90\nCompiling src/lib/penf.F90 serially\nCompiling src/lib/string_t.F90 serially\nCompiling src/lib/stringifor.F90 serially\nCompiling src/tests/is_real.f90 serially\nLinking exe/is_real\nTarget src/tests/is_real.f90 has been successfully built\nBuilder options\n  Directories\n    Building directory: \"exe\" Compiled-objects .o   directory: \"exe/obj\" Compiled-objects .mod directory: \"exe/mod\" Compiler options\n    Vendor: \"gnu\" Compiler command: \"gfortran\" Module directory switch: \"-J\" Compiling flags: \"-c -frealloc-lhs -std=f2008 -fall-intrinsics -O2 -Dr16p\" Linking flags: \"-O2\" Preprocessing flags: \"-Dr16p\" Coverage: False\n    Profile: False\n  PreForM.py used: False\n  PreForM.py output directory: None\n  PreForM.py extensions processed: [] Building src/tests/slen.f90\nCompiling src/tests/slen.f90 serially\n...\n\n→ tree -L 1 exe/\nexe/\n├── assignments\n├── basename_dir\n├── camelcase\n├── capitalize\n├── concatenation\n├── equal\n├── escape\n├── extension\n├── fill\n...\n├── swapcase\n├── to_number\n├── unique\n└── upper_lower Build the library Type # static-linked library by means of GNU gfortran FoBiS.py build -mode stringifor-static-gnu # shared-linked library by means of GNU gfortran FoBiS.py build -mode stringifor-shared-gnu # static-linked library by means of Intel Fortran FoBiS.py build -mode stringifor-static-intel # shared-linked library by means of Intel Fortran FoBiS.py build -mode stringifor-shared-intel The library will be built into the directory ./lib . List other fobos modes To list all fobos-provided modes type → FoBiS.py build -lmodes\nThe fobos file defines the following modes:\n  - \"tests-gnu\" - \"tests-gnu-debug\" - \"tests-intel\" - \"tests-intel-debug\" - \"stringifor-static-gnu\" - \"stringifor-shared-gnu\" - \"stringifor-static-intel\" - \"stringifor-shared-intel\" It is worth to note that the first mode is the one automatically called by FoBiS.py build . Build by means of GNU Make The provided makefile support only static-linked library building (not shared one) with both Intel Fortran Compiler and GNU gfortran, and it has two main building rules: build the (static linked) library; build the tests suite. the GNU gfortran compiler is the default one, but the compiler used can be customized with COMPILER=#vendor switch. To build the library type with the GNU gfortran compiler. make The library will be built into the directory ./lib/libstringifor.a . To build the tests suite type make TESTS = yes The tests will be built into the directory ./exe . If you want to use Intel Fortran Compiler add the switch COMPILER=intel to the above commands, i.e. make COMPILER = intel # build only the library make COMPILER = intel TESTS = yes # build the tests suite Build by means of CMake To be done. Go to Top Documentation The StringiFor documentation is mainly contained into this file (it has its own wiki with some less important documents). Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Methods API In the following all the methods of string are listed with a brief description of their aim. The hyperlinks bring you to the full API explained into the GH pages. built-ins replacements name meaning adjustl adjustl replacement adjustr adjustr replacement count count replacement index index replacement len len replacement len_trim len_trim replacement repeat repeat replacement scan scan replacement trim trim replacement verify verify replacement auxiliary methods name meaning basedir return the base directory name of a string containing a file name basename return the base file name of a string containing a file name camelcase return a string with all words capitalized without spaces capitalize return a string with its first character capitalized and the rest lowercased chars return the raw characters data decode decode string encode encode string escape escape backslashes (or custom escape character) extension return the extension of a string containing a file name fill pad string on the left (or right) with zeros (or other char) to fill width free free dynamic memory insert insert substring into string at a specified position join return a string that is a join of an array of strings or characters lower return a string with all lowercase characters partition split string at separator and return the 3 parts (before the separator and after) read_file read a file a single string stream read_line read line (record) from a connected unit read_lines read (all) lines (records) from a connected unit as a single ascii stream replace return a string with all occurrences of substring old replaced by new reverse return a reversed string search search for tagged record into string slice return the raw characters data sliced snakecase return a string with all words lowercase separated by _ split return a list of substring in the string using sep as the delimiter string startcase return a string with all words capitalized, e.g. title case strip return a string with the leading and trailing characters removed swapcase return a string with uppercase chars converted to lowercase and vice versa tempname return a safe temporary name suitable for temporary file or directories to_number cast string to number unescape unescape double backslashes (or custom escaped character) unique reduce to one (unique) multiple occurrences of a substring into a string upper return a string with all uppercase characters write_file write a single string stream into file write_line write line (record) to a connected unit write_lines write lines (records) to a connected unit inquire methods name meaning end_with return true if a string ends with a specified suffix is_allocated return true if the string is allocated is_digit return true if all characters in the string are digits is_integer return true if the string contains an integer is_lower return true if all characters in the string are lowercase is_number return true if the string contains a number (real or integer) is_real return true if the string contains an real is_upper return true if all characters in the string are uppercase start_with return true if a string starts with a specified prefix operators name meaning assignment assignment of string from different inputs // concatenation resulting in characters for seamless integration .cat. concatenation resulting in string == equal operator /= not equal operator < lower than operator <= lower equal than operator >= greater equal than operator > greater than operator IO name meaning read(formatted) formatted input write(formatted) formatted output read(unformatted) unformatted input write(unformatted) unformatted output Go to Top Comparison to other Approaches The lack of Fortran support for strings manipulation has promoted different solutions in the past years. Following the classification of Clive Page [1] we can consider: standard character type; deferred-length allocatable character type (standard 2003+); VARYING_STRING type (standard 90/95+) as defined in ISO/IEC 1539-2:2000 (Varying length character strings). Let us compare StringiFor to the previous three approaches. In particular, let us consider Ian Harvey extension of VARYING_STRING , i.e. the aniso_varying_string [2] . Clive Page had pointed out the following issues, among the others: fixed (at compile time) string length character ( len = 3 ) :: astring ! further lengths different from 3 are not allowed silent truncation on assignment character ( len = 3 ) :: astring astring = 'abcdefgh' ! silent trunctation at 'abc' trim-cluttered code character ( len = 99 ) :: astring character ( len = 99 ) :: anotherstring astring = 'abcdefgh' anotherstring = trim ( astring ) // 'ilmnopqrst' ! trim-cluttering is a necessity handle significant trailing spaces character ( len = 99 ) :: astring character ( len = 99 ) :: anotherstring astring = 'Hello ' ! for some reasons you want to keep these trailing white spaces anotherstring = trim ( astring ) // 'World' ! you need trim because ! len(astring)==len(anotherstring), but lost the significant ! trailing spaces... different character definition character :: astring * 10 ! old way character ( len = 10 ) :: anotherstring ! new way allocation of array of strings character ( len = 10 ), allocatable :: astring (:) allocate ( astring ( 100 )) ! all 100 elements of the array have 10 characters, ! different lengths cannot be declared initialization of array of strings ! the following is illegal character ( len = 9 ), parameter :: day ( 7 ) = [ 'Monday' , & 'Tuesday' , & 'Wednesday' , & 'Thursday' , & 'Friday' , & 'Saturday' , & 'Sunday' ] ! the following is legal, but cluttered by non significant trailing spaces character ( len = 9 ), parameter :: day ( 7 ) = [ 'Monday   ' , & 'Tuesday  ' , & 'Wednesday' , & 'Thursday ' , & 'Friday   ' , & 'Saturday ' , & 'Sunday' ] IO limitations for non standard character variables character ( len = 99 ) :: astring character ( len = :), allocatable :: anotherstring type ( varying_string ) :: yetanotherstring ! fully-simple support for standard character variables astring = 'abcdefgh' print * , astring print \"(A)\" , astring read ( 10 , * ) astring ! partial-simple support for standard deferred length-length allocatable character variables ! care must be placed in input operation... print * , anotherstring print \"(A)\" , anotherstring read ( 10 , * ) anotherstring ! support depends on the implementation of the varying string type print * , yetanotherstring print \"(DT)\" , yetanotherstring read ( 10 , * ) yetanotherstring substring notation (slice)  for non standard character variables character ( len = 99 ) :: astring character ( len = :), allocatable :: anotherstring type ( varying_string ) :: yetanotherstring astring = 'abcdefgh' yetanotherstring = astring anotherstring = astring ( 2 : 6 ) ! allowed anotherstring = yetanotherstring ( 2 : 6 ) ! not allowed passing string to procedures expecting standard character argument is complicated Analyzing the above issues we can agree that deferred-length allocatable character and aniso_varyng_string approaches address many of them, at the cost of introducing some oddies. deferred-length allocatable character This approaches addresses all the issues related to the fixed length limitation, e.g. character ( len = :), allocatable :: astring character ( len = :), allocatable :: anotherstring astring = 'Hello ' anotherstring = astring // 'World' ! trailing with spaces of astring correctly handled ! no need of trim However, it has some limitations too. Aside the input operation, the most important (IMHO) are related to arrays of strings handling, e.g. character ( len = :), allocatable :: asetofstring (:) allocate ( character ( len = 99 ) :: asetofstring ( 10 )) ! all 10 elements must have len=99 aniso_varying_string Aniso_varying_string is an implemention of ISO/IEC 1539-2:2000 (Varying length character strings) developed by Ian Harvey that is internally based on a deferred-lenght allocatable character variable: it is essentially a derived type wrapping a deferred-lenght allocatable character. As a consequence, it has all the advantages of the deferred-length allocatable character approach. The wrapping approach addresses the arrays related issues, e.g. type ( varying_string ), allocatable :: asetofstring (:) allocate ( asetofstring ( 10 )) ! all 10 elements can have diffent lengths Its major issues are related to IO operations: however, this is addressed by new Fortran support for defined IO for derived type that make more effortless the IO of such an object. The other main issue is the impossibility to use the standard slice notation to access to substring: aniso_varying_string addresses (partially) this issue by public-exposing the wrapped allocatable character of its implementations thus allowing the slicing of it, e.g. type ( varying_string ) :: astring astring = 'abcdefg' print \"(A)\" , astring % chars ( 2 : 3 ) ! print 'bc' StringiFor StringiFor shares the same philosophy of aniso_varying_string, thut it has the same pros and cons. However, StringiFor is an Object Oriented Designed class, thus it has some peculiariaties distinguishing it from aniso_varying_string, see StringiFor Peculiarities . Comparison results The following table summarizes the comparison analysis. issue standard character deferred-length allocatable character aniso_varying_string StringiFor fixed length :cloud: :sunny: :sunny: :sunny: silent trunction :cloud: :sunny: :sunny: :sunny: trim-clutter :cloud: :sunny: :sunny: :sunny: significant trailing spaces :cloud: :sunny: :sunny: :sunny: different string definition :cloud: :cloud: :sunny: :sunny: array allocatation :cloud: :cloud: :sunny: :sunny: array initialization :cloud: :cloud: :sunny: :sunny: IO :sunny: :sunny: :partly_sunny: :partly_sunny: substring (slice) notation :sunny: :sunny: :partly_sunny: :partly_sunny: Fortran builtins :sunny: :sunny: :partly_sunny: :partly_sunny: legend symbol meaning :cloud: bad or no support :partly_sunny: partial support :sunny: good support StringiFor Peculiarities StringiFor publics an OOD class, the string object. This class is aimed to address all the issues of the standard character type, as ISO Varying String approaches do, but it is also designed to provide a features-rich string object as you can find on other languages like Python. As a matter of facts, the auxiliary methods added to the string object consitute a long list of new (for Fortraners) string-facilities, allowing you to handle strings effortless (cases-conversion, files-handling, encode/decode, numbers-casting, etc…), see the complete API . It is worth to note that StringiFor is a tentative to adopt an fully OOD thus all methods and operators are TBP defined: to use StringiFor you can import only the string type, allowing a sane and robust names space handling. Only in the case you want the Fortran builtins to accept a string instead of a standard character type, e.g. to use index(astring, 'c') seamless with both a type(string) :: astring and a character(99) :: astring , you must use all the StringiFor public objects, including the overloaded interfaces of the Fortran builtins. References [1] Improved String-handling in Fortran , Clive Page, October 2015. [2] aniso_varying_string , Ian Harvey, 2016. Go to Top Developer Info Stefano Zaghi","tags":"home","loc":"index.html"},{"title":"string – StringiFor ","text":"type, public :: string OOP designed string class. Contents Variables raw Type-Bound Procedures adjustl adjustr count index len len_trim repeat scan trim verify basedir basename camelcase capitalize chars colorize decode encode escape extension fill free glob insert join strjoin lower partition read_file read_line read_lines replace reverse search slice snakecase split split_chunked startcase strip swapcase tempname to_number unescape unique upper write_file write_line write_lines end_with is_allocated is_digit is_integer is_lower is_number is_real is_upper start_with assignment(=) operator(//) operator(.cat.) operator(==) operator(/=) operator(<) operator(<=) operator(>=) operator(>) read(formatted) write(formatted) read(unformatted) write(unformatted) sindex_string_string sindex_string_character srepeat_string_string srepeat_character_string sscan_string_string sscan_string_character sverify_string_string sverify_string_character colorize_str glob_character glob_string insert_string insert_character join_strings join_characters strjoin_strings strjoin_characters strjoin_strings_array strjoin_characters_array to_integer_I1P to_integer_I2P to_integer_I4P to_integer_I8P to_real_R4P to_real_R8P to_real_R16P string_assign_string string_assign_character string_assign_integer_I1P string_assign_integer_I2P string_assign_integer_I4P string_assign_integer_I8P string_assign_real_R4P string_assign_real_R8P string_assign_real_R16P string_concat_string string_concat_character character_concat_string string_concat_string_string string_concat_character_string character_concat_string_string string_eq_string string_eq_character character_eq_string string_ne_string string_ne_character character_ne_string string_lt_string string_lt_character character_lt_string string_le_string string_le_character character_le_string string_ge_string string_ge_character character_ge_string string_gt_string string_gt_character character_gt_string read_formatted read_delimited read_undelimited read_undelimited_listdirected write_formatted read_unformatted write_unformatted replace_one_occurrence Source Code string Components Type Visibility Attributes Name Initial character(kind=CK,len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: adjustl => sadjustl Adjustl replacement. private elemental function sadjustl (self) result(adjusted) Left adjust a string by removing leading spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. procedure, public, pass(self) :: adjustr => sadjustr Adjustr replacement. private elemental function sadjustr (self) result(adjusted) Right adjust a string by removing leading spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. procedure, public, pass(self) :: count => scount Count replacement. private elemental function scount (self, substring, ignore_isolated) result(No) Count the number of occurences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore “isolated” occurrences. Return Value integer Number of occurrences. generic, public :: index => sindex_string_string , sindex_string_character Index replacement. private elemental function sindex_string_string (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sindex_string_character (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, public, pass(self) :: len => slen Len replacement. private elemental function slen (self) result(l) Return the length of a string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. procedure, public, pass(self) :: len_trim => slen_trim Len_trim replacement. private elemental function slen_trim (self) result(l) Return the length of a string, ignoring any trailing blanks. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. generic, public :: repeat => srepeat_string_string , srepeat_character_string Repeat replacement. private elemental function srepeat_string_string (self, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. private elemental function srepeat_character_string (rstring, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. generic, public :: scan => sscan_string_string , sscan_string_character Scan replacement. private elemental function sscan_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, public, pass(self) :: trim => strim Trim replacement. private elemental function strim (self) result(trimmed) Remove trailing spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. generic, public :: verify => sverify_string_string , sverify_string_character Verify replacement. private elemental function sverify_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, public, pass(self) :: basedir Return the base directory name of a string containing a file name. private elemental function basedir (self, sep) Return the base directory name of a string containing a file name. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. procedure, public, pass(self) :: basename Return the base file name of a string containing a file name. private elemental function basename (self, sep, extension, strip_last_extension) Return the base file name of a string containing a file name. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. procedure, public, pass(self) :: camelcase Return a string with all words capitalized without spaces. private elemental function camelcase (self, sep) Return a string with all words capitalized without spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. private elemental function capitalize (self) result(capitalized) Return a string with its first character capitalized and the rest lowercased. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. procedure, public, pass(self) :: chars Return the raw characters data. private pure function chars (self) result(raw) Return the raw characters data. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),allocatable Raw characters data. generic, public :: colorize => colorize_str Colorize and stylize strings. private pure function colorize_str (self, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, DEFAULT kind. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:),allocatable Colorized string. procedure, public, pass(self) :: decode Decode string. private elemental function decode (self, codec) result(decoded) Return a string decoded accordingly the codec. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. procedure, public, pass(self) :: encode Encode string. private elemental function encode (self, codec) result(encoded) Return a string encoded accordingly the codec. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. procedure, public, pass(self) :: escape Escape backslashes (or custom escape character). private elemental function escape (self, to_escape, esc) result(escaped) Escape backslashes (or custom escape character). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. procedure, public, pass(self) :: extension Return the extension of a string containing a file name. private elemental function extension (self) Return the extension of a string containing a file name. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. procedure, public, pass(self) :: fill Pad string on the left (or right) with zeros (or other char) to fill width. private elemental function fill (self, width, right, filling_char) result(filled) Pad string on the left (or right) with zeros (or other char) to fill width. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default “0”). Return Value type( string ) Filled string. procedure, public, pass(self) :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. generic, public :: glob => glob_character , glob_string Glob search, finds all the pathnames matching a given pattern. private subroutine glob_character (self, pattern, list) Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: pattern Given pattern. character(len=:), intent(out), allocatable :: list (:) List of matching pathnames. private subroutine glob_string (self, pattern, list) Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: pattern Given pattern. type( string ), intent(out), allocatable :: list (:) List of matching pathnames. generic, public :: insert => insert_string , insert_character Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Insert substring into string at a specified position. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. private elemental function insert_character (self, substring, pos) result(inserted) Insert substring into string at a specified position. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. generic, public :: join => join_strings , join_characters Return a string that is a join of an array of strings or characters. private pure function join_strings (self, array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function join_characters (self, array, sep) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. generic, public :: strjoin => strjoin_strings , strjoin_characters , strjoin_strings_array , strjoin_characters_array Return a string that is a join of an array of strings or characters;\nReturn join 1D string array of an 2D array of strings or characters in columns or rows. private pure function strjoin_strings (array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function strjoin_characters (array, sep, is_trim) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not Return Value type( string ) The join of array. private pure function strjoin_strings_array (array, sep, is_col) result(join) Return a string that is a join of columns or rows of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ),allocatable, (:) The join of array. private pure function strjoin_characters_array (array, sep, is_trim, is_col) result(join) Return a string that is a join of columns or rows of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ),allocatable, (:) The join of array. procedure, public, pass(self) :: lower Return a string with all lowercase characters. private elemental function lower (self) Return a string with all lowercase characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). private pure function partition (self, sep) result(partitions) Split string at separator and return the 3 parts (before, the separator and after). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )(1:3) after the separator. procedure, public, pass(self) :: read_file Read a file a single string stream. private subroutine read_file (self, file, is_fast, form, iostat, iomsg) Read a file as a single string stream. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. logical, intent(in), optional :: is_fast Flag to enable (super) fast file reading. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. procedure, public, pass(self) :: read_line Read line (record) from a connected unit. private subroutine read_line (self, unit, form, iostat, iomsg) Read line (record) from a connected unit. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. procedure, public, pass(self) :: read_lines Read (all) lines (records) from a connected unit as a single ascii stream. private subroutine read_lines (self, unit, form, iostat, iomsg) Read (all) lines (records) from a connected unit as a single ascii stream. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. private elemental function replace (self, old, new, count) result(replaced) Return a string with all occurrences of substring old replaced by new. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. procedure, public, pass(self) :: reverse Return a reversed string. private elemental function reverse (self) result(reversed) Return a reversed string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. procedure, public, pass(self) :: search Search for tagged record into string. private function search (self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Search for tagged record into string, return the first record found (if any) matching the tags. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. procedure, public, pass(self) :: slice Return the raw characters data sliced. private pure function slice (self, istart, iend) result(raw) Return the raw characters data sliced. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK,len=:),allocatable Raw characters data. procedure, public, pass(self) :: snakecase Return a string with all words lowercase separated by “_”. private elemental function snakecase (self, sep) Return a string with all words lowercase separated by “_”. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. private pure subroutine split (self, tokens, sep, max_tokens) Return a list of substring in the string, using sep as the delimiter string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. integer, intent(in), optional :: max_tokens Fix the maximum number of returned tokens. procedure, public, pass(self) :: split_chunked Return a list of substring in the string, using sep as the delimiter string. private pure subroutine split_chunked (self, tokens, chunks, sep) Return a list of substring in the string, using sep as the delimiter string, chunked (memory-efficient) algorithm. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. integer, intent(in) :: chunks Number of chunks. character(kind=CK,len=*), intent(in), optional :: sep Separator. procedure, public, pass(self) :: startcase Return a string with all words capitalized, e.g. title case. private elemental function startcase (self, sep) Return a string with all words capitalized, e.g. title case. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. procedure, public, pass(self) :: strip Return a string with the leading and trailing characters removed. private elemental function strip (self, remove_nulls) Return a copy of the string with the leading and trailing characters removed. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. procedure, public, pass(self) :: swapcase Return a string with uppercase chars converted to lowercase and vice versa. private elemental function swapcase (self) Return a copy of the string with uppercase characters converted to lowercase and vice versa. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. procedure, public, pass(self) :: tempname Return a safe temporary name suitable for temporary file or directories. private function tempname (self, is_file, prefix, path) Return a safe temporary name suitable for temporary file or directories. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: is_file True if tempname should be used for file (the default). character, intent(in), optional :: prefix Name prefix, otherwise self is used (if allocated). character, intent(in), optional :: path Path where file/directory should be used, default ./ . Return Value character(len=:),allocatable Safe (unique) temporary name. generic, public :: to_number => to_integer_I1P , to_integer_I2P , to_integer_I4P , to_integer_I8P , to_real_R8P , to_real_R4P Cast string to number. private elemental function to_integer_I1P (self, kind) result(to_number) Cast string to integer (I1P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. private elemental function to_integer_I2P (self, kind) result(to_number) Cast string to integer (I2P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. private elemental function to_integer_I4P (self, kind) result(to_number) Cast string to integer (I4P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. private elemental function to_integer_I8P (self, kind) result(to_number) Cast string to integer (I8P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. private elemental function to_real_R8P (self, kind) result(to_number) Cast string to real (R8P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. private elemental function to_real_R4P (self, kind) result(to_number) Cast string to real (R4P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. procedure, public, pass(self) :: unescape Unescape double backslashes (or custom escaped character). private elemental function unescape (self, to_unescape, unesc) result(unescaped) Unescape double backslashes (or custom escaped character). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK,len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. procedure, public, pass(self) :: unique Reduce to one (unique) multiple occurrences of a substring into a string. private elemental function unique (self, substring) result(uniq) Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. procedure, public, pass(self) :: upper Return a string with all uppercase characters. private elemental function upper (self) Return a string with all uppercase characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. procedure, public, pass(self) :: write_file Write a single string stream into file. private subroutine write_file (self, file, form, iostat, iomsg) Write a single string stream into file. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. procedure, public, pass(self) :: write_line Write line (record) to a connected unit. private subroutine write_line (self, unit, form, iostat, iomsg) Write line (record) to a connected unit. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. procedure, public, pass(self) :: write_lines Write lines (records) to a connected unit. private subroutine write_lines (self, unit, form, iostat, iomsg) Write lines (records) to a connected unit. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. private elemental function end_with (self, suffix, start, end, ignore_null_eof) Return true if a string ends with a specified suffix. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. logical, intent(in), optional :: ignore_null_eof Ignore null character at the end of file. Return Value logical Result of the test. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. private elemental function is_allocated (self) Return true if the string is allocated. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. private elemental function is_digit (self) Return true if all characters in the string are digits. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. procedure, public, pass(self) :: is_integer Return true if the string contains an integer. private elemental function is_integer (self, allow_spaces) Return true if the string contains an integer. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. private elemental function is_lower (self) Return true if all characters in the string are lowercase. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. procedure, public, pass(self) :: is_number Return true if the string contains a number (real or integer). private elemental function is_number (self, allow_spaces) Return true if the string contains a number (real or integer). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. procedure, public, pass(self) :: is_real Return true if the string contains an real. private elemental function is_real (self, allow_spaces) Return true if the string contains a real. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. private elemental function is_upper (self) Return true if all characters in the string are uppercase. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. private elemental function start_with (self, prefix, start, end) Return true if a string starts with a specified prefix. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. generic, public :: assignment(=) => string_assign_string , string_assign_character , string_assign_integer_I1P , string_assign_integer_I2P , string_assign_integer_I4P , string_assign_integer_I8P , string_assign_real_R8P , string_assign_real_R4P Assignment operator overloading. private pure subroutine string_assign_string (lhs, rhs) Assignment operator from string input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. private pure subroutine string_assign_character (lhs, rhs) Assignment operator from character input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I1P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I2P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I4P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I8P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_real_R8P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_real_R4P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. generic, public :: operator(//) => string_concat_string , string_concat_character , character_concat_string Concatenation operator overloading. private pure function string_concat_string (lhs, rhs) result(concat) Concatenation with string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),allocatable Concatenated string. private pure function string_concat_character (lhs, rhs) result(concat) Concatenation with character. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),allocatable Concatenated string. private pure function character_concat_string (lhs, rhs) result(concat) Concatenation with character (inverted). Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),allocatable Concatenated string. generic, public :: operator(.cat.) => string_concat_string_string , string_concat_character_string , character_concat_string_string Concatenation operator (string output) overloading. private elemental function string_concat_string_string (lhs, rhs) result(concat) Concatenation with string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Concatenation with character. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. private elemental function character_concat_string_string (lhs, rhs) result(concat) Concatenation with character (inverted). Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. generic, public :: operator(==) => string_eq_string , string_eq_character , character_eq_string Equal operator overloading. private elemental function string_eq_string (lhs, rhs) result(is_it) Equal to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_eq_character (lhs, rhs) result(is_it) Equal to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_eq_string (lhs, rhs) result(is_it) Equal to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: operator(/=) => string_ne_string , string_ne_character , character_ne_string Not equal operator overloading. private elemental function string_ne_string (lhs, rhs) result(is_it) Not equal to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_ne_character (lhs, rhs) result(is_it) Not equal to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_ne_string (lhs, rhs) result(is_it) Not equal to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: operator(<) => string_lt_string , string_lt_character , character_lt_string Lower than operator overloading. private elemental function string_lt_string (lhs, rhs) result(is_it) Lower than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_lt_character (lhs, rhs) result(is_it) Lower than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_lt_string (lhs, rhs) result(is_it) Lower than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: operator(<=) => string_le_string , string_le_character , character_le_string Lower equal than operator overloading. private elemental function string_le_string (lhs, rhs) result(is_it) Lower equal than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_le_character (lhs, rhs) result(is_it) Lower equal than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_le_string (lhs, rhs) result(is_it) Lower equal than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: operator(>=) => string_ge_string , string_ge_character , character_ge_string Greater equal than operator overloading. private elemental function string_ge_string (lhs, rhs) result(is_it) Greater equal than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_ge_character (lhs, rhs) result(is_it) Greater equal than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_ge_string (lhs, rhs) result(is_it) Greater equal than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: operator(>) => string_gt_string , string_gt_character , character_gt_string Greater than operator overloading. private elemental function string_gt_string (lhs, rhs) result(is_it) Greater than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_gt_character (lhs, rhs) result(is_it) Greater than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_gt_string (lhs, rhs) result(is_it) Greater than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. generic, public :: read(formatted) => read_formatted Formatted input. private subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Formatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. generic, public :: write(formatted) => write_formatted Formatted output. private subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Formatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. generic, public :: read(unformatted) => read_unformatted Unformatted input. private subroutine read_unformatted (dtv, unit, iostat, iomsg) Unformatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. generic, public :: write(unformatted) => write_unformatted Unformatted output. private subroutine write_unformatted (dtv, unit, iostat, iomsg) Unformatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(self) :: sindex_string_string Index replacement. private elemental function sindex_string_string (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, private, pass(self) :: sindex_string_character Index replacement. private elemental function sindex_string_character (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, private, pass(self) :: srepeat_string_string Repeat replacement. private elemental function srepeat_string_string (self, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. procedure, private, nopass :: srepeat_character_string Repeat replacement. private elemental function srepeat_character_string (rstring, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. procedure, private, pass(self) :: sscan_string_string Scan replacement. private elemental function sscan_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, private, pass(self) :: sscan_string_character Scan replacement. private elemental function sscan_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, private, pass(self) :: sverify_string_string Verify replacement. private elemental function sverify_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, private, pass(self) :: sverify_string_character Verify replacement. private elemental function sverify_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. procedure, private, pass(self) :: colorize_str Colorize and stylize strings. private pure function colorize_str (self, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, DEFAULT kind. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:),allocatable Colorized string. procedure, private, pass(self) :: glob_character Glob search (character output). private subroutine glob_character (self, pattern, list) Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: pattern Given pattern. character(len=:), intent(out), allocatable :: list (:) List of matching pathnames. procedure, private, pass(self) :: glob_string Glob search (string output). private subroutine glob_string (self, pattern, list) Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: pattern Given pattern. type( string ), intent(out), allocatable :: list (:) List of matching pathnames. procedure, private, pass(self) :: insert_string Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Insert substring into string at a specified position. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. procedure, private, pass(self) :: insert_character Insert substring into string at a specified position. private elemental function insert_character (self, substring, pos) result(inserted) Insert substring into string at a specified position. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. procedure, private, pass(self) :: join_strings Return join string of an array of strings. private pure function join_strings (self, array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. procedure, private, pass(self) :: join_characters Return join string of an array of characters. private pure function join_characters (self, array, sep) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. procedure, private, nopass :: strjoin_strings Return join string of an array of strings. private pure function strjoin_strings (array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. procedure, private, nopass :: strjoin_characters Return join string of an array of strings. private pure function strjoin_characters (array, sep, is_trim) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not Return Value type( string ) The join of array. procedure, private, nopass :: strjoin_strings_array Return join 1D string array of an 2D array of strings in columns or rows. private pure function strjoin_strings_array (array, sep, is_col) result(join) Return a string that is a join of columns or rows of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ),allocatable, (:) The join of array. procedure, private, nopass :: strjoin_characters_array Return join 1D string array of an 2D array of characters in columns or rows. private pure function strjoin_characters_array (array, sep, is_trim, is_col) result(join) Return a string that is a join of columns or rows of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ),allocatable, (:) The join of array. procedure, private, pass(self) :: to_integer_I1P Cast string to integer. private elemental function to_integer_I1P (self, kind) result(to_number) Cast string to integer (I1P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. procedure, private, pass(self) :: to_integer_I2P Cast string to integer. private elemental function to_integer_I2P (self, kind) result(to_number) Cast string to integer (I2P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. procedure, private, pass(self) :: to_integer_I4P Cast string to integer. private elemental function to_integer_I4P (self, kind) result(to_number) Cast string to integer (I4P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. procedure, private, pass(self) :: to_integer_I8P Cast string to integer. private elemental function to_integer_I8P (self, kind) result(to_number) Cast string to integer (I8P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. procedure, private, pass(self) :: to_real_R4P Cast string to real. private elemental function to_real_R4P (self, kind) result(to_number) Cast string to real (R4P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. procedure, private, pass(self) :: to_real_R8P Cast string to real. private elemental function to_real_R8P (self, kind) result(to_number) Cast string to real (R8P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. procedure, private, pass(self) :: to_real_R16P Cast string to real. private elemental function to_real_R16P (self, kind) result(to_number) Cast string to real (R16P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. private pure subroutine string_assign_string (lhs, rhs) Assignment operator from string input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. private pure subroutine string_assign_character (lhs, rhs) Assignment operator from character input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_integer_I1P Assignment operator from integer input. private pure subroutine string_assign_integer_I1P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_integer_I2P Assignment operator from integer input. private pure subroutine string_assign_integer_I2P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_integer_I4P Assignment operator from integer input. private pure subroutine string_assign_integer_I4P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_integer_I8P Assignment operator from integer input. private pure subroutine string_assign_integer_I8P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_real_R4P Assignment operator from real input. private pure subroutine string_assign_real_R4P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_real_R8P Assignment operator from real input. private pure subroutine string_assign_real_R8P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_assign_real_R16P Assignment operator from real input. private pure subroutine string_assign_real_R16P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. private pure function string_concat_string (lhs, rhs) result(concat) Concatenation with string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),allocatable Concatenated string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. private pure function string_concat_character (lhs, rhs) result(concat) Concatenation with character. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),allocatable Concatenated string. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). private pure function character_concat_string (lhs, rhs) result(concat) Concatenation with character (inverted). Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),allocatable Concatenated string. procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). private elemental function string_concat_string_string (lhs, rhs) result(concat) Concatenation with string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). private elemental function string_concat_character_string (lhs, rhs) result(concat) Concatenation with character. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). private elemental function character_concat_string_string (lhs, rhs) result(concat) Concatenation with character (inverted). Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. procedure, private, pass(lhs) :: string_eq_string Equal to string logical operator. private elemental function string_eq_string (lhs, rhs) result(is_it) Equal to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_eq_character Equal to character logical operator. private elemental function string_eq_character (lhs, rhs) result(is_it) Equal to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(rhs) :: character_eq_string Equal to character (inverted) logical operator. private elemental function character_eq_string (lhs, rhs) result(is_it) Equal to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_ne_string Not equal to string logical operator. private elemental function string_ne_string (lhs, rhs) result(is_it) Not equal to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_ne_character Not equal to character logical operator. private elemental function string_ne_character (lhs, rhs) result(is_it) Not equal to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(rhs) :: character_ne_string Not equal to character (inverted) logical operator. private elemental function character_ne_string (lhs, rhs) result(is_it) Not equal to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_lt_string Lower than to string logical operator. private elemental function string_lt_string (lhs, rhs) result(is_it) Lower than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_lt_character Lower than to character logical operator. private elemental function string_lt_character (lhs, rhs) result(is_it) Lower than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(rhs) :: character_lt_string Lower than to character (inverted) logical operator. private elemental function character_lt_string (lhs, rhs) result(is_it) Lower than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_le_string Lower equal than to string logical operator. private elemental function string_le_string (lhs, rhs) result(is_it) Lower equal than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_le_character Lower equal than to character logical operator. private elemental function string_le_character (lhs, rhs) result(is_it) Lower equal than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(rhs) :: character_le_string Lower equal than to character (inverted) logical operator. private elemental function character_le_string (lhs, rhs) result(is_it) Lower equal than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_ge_string Greater equal than to string logical operator. private elemental function string_ge_string (lhs, rhs) result(is_it) Greater equal than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_ge_character Greater equal than to character logical operator. private elemental function string_ge_character (lhs, rhs) result(is_it) Greater equal than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(rhs) :: character_ge_string Greater equal than to character (inverted) logical operator. private elemental function character_ge_string (lhs, rhs) result(is_it) Greater equal than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_gt_string Greater than to string logical operator. private elemental function string_gt_string (lhs, rhs) result(is_it) Greater than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(lhs) :: string_gt_character Greater than to character logical operator. private elemental function string_gt_character (lhs, rhs) result(is_it) Greater than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(rhs) :: character_gt_string Greater than to character (inverted) logical operator. private elemental function character_gt_string (lhs, rhs) result(is_it) Greater than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. procedure, private, pass(dtv) :: read_formatted Formatted input. private subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Formatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(dtv) :: read_delimited Read a delimited input. private subroutine read_delimited (dtv, unit, delim, iostat, iomsg) Read a delimited string from a unit connected for formatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(dtv) :: read_undelimited Read an undelimited input. private subroutine read_undelimited (dtv, unit, terminators, iostat, iomsg) Read an undelimited string up until end of record or a character from a set of terminators is encountered. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: terminators Characters that are considered to terminate the string.\nBlanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(dtv) :: read_undelimited_listdirected Read an undelimited list directed input. private subroutine read_undelimited_listdirected (dtv, unit, iostat, iomsg) Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(dtv) :: write_formatted Formatted output. private subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Formatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(dtv) :: read_unformatted Unformatted input. private subroutine read_unformatted (dtv, unit, iostat, iomsg) Unformatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(dtv) :: write_unformatted Unformatted output. private subroutine write_unformatted (dtv, unit, iostat, iomsg) Unformatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. private elemental function replace_one_occurrence (self, old, new) result(replaced) Return a string with the first occurrence of substring old replaced by new. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Source Code type :: string !< OOP designed string class. character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods ! builtins replacements procedure , pass ( self ) :: adjustl => sadjustl !< Adjustl replacement. procedure , pass ( self ) :: adjustr => sadjustr !< Adjustr replacement. procedure , pass ( self ) :: count => scount !< Count replacement. generic :: index => sindex_string_string , & sindex_string_character !< Index replacement. procedure , pass ( self ) :: len => slen !< Len replacement. procedure , pass ( self ) :: len_trim => slen_trim !< Len_trim replacement. generic :: repeat => srepeat_string_string , & srepeat_character_string !< Repeat replacement. generic :: scan => sscan_string_string , & sscan_string_character !< Scan replacement. procedure , pass ( self ) :: trim => strim !< Trim replacement. generic :: verify => sverify_string_string , & sverify_string_character !< Verify replacement. ! auxiliary methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. generic :: colorize => & colorize_str !< Colorize and stylize strings. procedure , pass ( self ) :: decode !< Decode string. procedure , pass ( self ) :: encode !< Encode string. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: glob => & glob_character , & glob_string !< Glob search, finds all the pathnames matching a given pattern. generic :: insert => & insert_string , & insert_character !< Insert substring into string at a specified position. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. generic :: strjoin => & strjoin_strings , & strjoin_characters , & strjoin_strings_array , & strjoin_characters_array !< Return a string that is a join of an array of strings or characters; !< Return join 1D string array of an 2D array of strings or characters in columns or rows. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: read_file !< Read a file a single string stream. procedure , pass ( self ) :: read_line !< Read line (record) from a connected unit. procedure , pass ( self ) :: read_lines !< Read (all) lines (records) from a connected unit as a single ascii stream. procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: slice !< Return the raw characters data sliced. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: split_chunked !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. procedure , pass ( self ) :: tempname !< Return a safe temporary name suitable for temporary file or directories. generic :: to_number => & to_integer_I1P ,& #ifndef _NVF to_integer_I2P ,& #endif to_integer_I4P ,& to_integer_I8P ,& #if defined _R16P to_real_R16P , & #endif to_real_R8P , & to_real_R4P !< Cast string to number. procedure , pass ( self ) :: unescape !< Unescape double backslashes (or custom escaped character). procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: write_file !< Write a single string stream into file. procedure , pass ( self ) :: write_line !< Write line (record) to a connected unit. procedure , pass ( self ) :: write_lines !< Write lines (records) to a connected unit. ! inquire methods procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & #if defined _R16P string_assign_real_R16P , & #endif string_assign_real_R8P , & string_assign_real_R4P !< Assignment operator overloading. generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. generic :: operator ( == ) => string_eq_string , & string_eq_character , & character_eq_string !< Equal operator overloading. generic :: operator ( /= ) => string_ne_string , & string_ne_character , & character_ne_string !< Not equal operator overloading. generic :: operator ( < ) => string_lt_string , & string_lt_character , & character_lt_string !< Lower than operator overloading. generic :: operator ( <= ) => string_le_string , & string_le_character , & character_le_string !< Lower equal than operator overloading. generic :: operator ( >= ) => string_ge_string , & string_ge_character , & character_ge_string !< Greater equal than operator overloading. generic :: operator ( > ) => string_gt_string , & string_gt_character , & character_gt_string !< Greater than operator overloading. ! IO generic :: read ( formatted ) => read_formatted !< Formatted input. generic :: write ( formatted ) => write_formatted !< Formatted output. generic :: read ( unformatted ) => read_unformatted !< Unformatted input. generic :: write ( unformatted ) => write_unformatted !< Unformatted output. ! private methods ! builtins replacements procedure , private , pass ( self ) :: sindex_string_string !< Index replacement. procedure , private , pass ( self ) :: sindex_string_character !< Index replacement. procedure , private , pass ( self ) :: srepeat_string_string !< Repeat replacement. procedure , private , nopass :: srepeat_character_string !< Repeat replacement. procedure , private , pass ( self ) :: sscan_string_string !< Scan replacement. procedure , private , pass ( self ) :: sscan_string_character !< Scan replacement. procedure , private , pass ( self ) :: sverify_string_string !< Verify replacement. procedure , private , pass ( self ) :: sverify_string_character !< Verify replacement. ! auxiliary methods procedure , private , pass ( self ) :: colorize_str !< Colorize and stylize strings. procedure , private , pass ( self ) :: glob_character !< Glob search (character output). procedure , private , pass ( self ) :: glob_string !< Glob search (string output). procedure , private , pass ( self ) :: insert_string !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: insert_character !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , nopass :: strjoin_strings !< Return join string of an array of strings. procedure , private , nopass :: strjoin_characters !< Return join string of an array of strings. procedure , private , nopass :: strjoin_strings_array !< Return join 1D string array of an 2D array of strings in columns or rows. procedure , private , nopass :: strjoin_characters_array !< Return join 1D string array of an 2D array of characters in columns or rows. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. #ifndef _NVF procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. #endif procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. ! assignments procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. ! concatenation operators procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). ! logical operators procedure , private , pass ( lhs ) :: string_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: string_eq_character !< Equal to character logical operator. procedure , private , pass ( rhs ) :: character_eq_string !< Equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ne_string !< Not equal to string logical operator. procedure , private , pass ( lhs ) :: string_ne_character !< Not equal to character logical operator. procedure , private , pass ( rhs ) :: character_ne_string !< Not equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_lt_string !< Lower than to string logical operator. procedure , private , pass ( lhs ) :: string_lt_character !< Lower than to character logical operator. procedure , private , pass ( rhs ) :: character_lt_string !< Lower than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_le_string !< Lower equal than to string logical operator. procedure , private , pass ( lhs ) :: string_le_character !< Lower equal than to character logical operator. procedure , private , pass ( rhs ) :: character_le_string !< Lower equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ge_string !< Greater equal than to string logical operator. procedure , private , pass ( lhs ) :: string_ge_character !< Greater equal than to character logical operator. procedure , private , pass ( rhs ) :: character_ge_string !< Greater equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_gt_string !< Greater than to string logical operator. procedure , private , pass ( lhs ) :: string_gt_character !< Greater than to character logical operator. procedure , private , pass ( rhs ) :: character_gt_string !< Greater than to character (inverted) logical operator. ! IO procedure , private , pass ( dtv ) :: read_formatted !< Formatted input. procedure , private , pass ( dtv ) :: read_delimited !< Read a delimited input. procedure , private , pass ( dtv ) :: read_undelimited !< Read an undelimited input. procedure , private , pass ( dtv ) :: read_undelimited_listdirected !< Read an undelimited list directed input. procedure , private , pass ( dtv ) :: write_formatted !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted !< Unformatted output. ! miscellanea procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string","tags":"","loc":"type/string.html"},{"title":"read_file – StringiFor","text":"public subroutine read_file(file, lines, form, iostat, iomsg) Read a file as a single string stream. The lines are returned as an array of strings that are read until the eof is reached.\n The line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) call read_file ( file = 'read_file_test.tmp' , lines = strings , iostat = iostat , iomsg = iomsg ) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) call read_file ( file = 'read_file_test.tmp' , lines = strings , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Calls proc~~read_file~~CallsGraph proc~read_file read_file proc~read_lines read_lines proc~read_file->proc~read_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_file~~CalledByGraph proc~read_file read_file program~volatile_doctest~111 volatile_doctest program~volatile_doctest~111->proc~read_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_file Source Code subroutine read_file ( file , lines , form , iostat , iomsg ) !< Read a file as a single string stream. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, file='read_file_test.tmp') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< close(scratch) !< call read_file(file='read_file_test.tmp', lines=strings, iostat=iostat, iomsg=iomsg) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< close(scratch) !< call read_file(file='read_file_test.tmp', lines=strings, form='unformatted', iostat=iostat, iomsg=iomsg) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< close(scratch, status='DELETE') !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call read_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_file","tags":"","loc":"proc/read_file.html"},{"title":"read_lines – StringiFor","text":"public subroutine read_lines(unit, lines, form, iostat, iomsg) Read lines (records) from a connected-formatted unit. Note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. The lines are returned as an array of strings that are read until the eof is reached.\nThe line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. Note There is no doctests, this being tested by means of read_file doctests. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Called by proc~~read_lines~~CalledByGraph proc~read_lines read_lines proc~read_file read_file proc~read_file->proc~read_lines program~volatile_doctest~111 volatile_doctest program~volatile_doctest~111->proc~read_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_lines Source Code subroutine read_lines ( unit , lines , form , iostat , iomsg ) !< Read lines (records) from a connected-formatted unit. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !< @note There is no doctests, this being tested by means of [[read_file]] doctests. integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = 1 ) :: ch !< Character storage. integer :: l !< Counter. form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) select case ( form_ % chars ()) case ( 'FORMATTED' ) l = 0 do read ( unit , * , err = 10 , end = 10 ) l = l + 1 enddo case ( 'UNFORMATTED' ) l = 0 do read ( unit , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) l = l + 1 enddo endselect 10 rewind ( unit ) if ( l > 0 ) then allocate ( lines ( 1 : l )) l = 1 iostat_ = 0 do call lines ( l )% read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if (( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )). or .( l >= size ( lines , dim = 1 ))) then exit endif l = l + 1 enddo endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_lines","tags":"","loc":"proc/read_lines.html"},{"title":"write_file – StringiFor","text":"public subroutine write_file(file, lines, form, iostat, iomsg) Write a single string stream into file. Note For unformatted read only access='stream' is supported with new_line as line terminator. type ( string ) :: astring type ( string ) :: anotherstring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) call write_file ( file = 'write_file_test.tmp' , lines = line , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo call write_file ( file = 'write_file_test.tmp' , lines = line , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( scratch , status = 'DELETE' ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Calls proc~~write_file~~CallsGraph proc~write_file write_file proc~write_lines write_lines proc~write_file->proc~write_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_file~~CalledByGraph proc~write_file write_file program~volatile_doctest~110 volatile_doctest program~volatile_doctest~110->proc~write_file program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~write_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_file Source Code subroutine write_file ( file , lines , form , iostat , iomsg ) !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string)              :: anotherstring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< anotherstring = anotherstring%join(array=line, sep=new_line('a')) !< call write_file(file='write_file_test.tmp', lines=line, iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< call write_file(file='write_file_test.tmp', lines=line, form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='write_file_test.tmp') !< close(scratch, status='DELETE') !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call write_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_file","tags":"","loc":"proc/write_file.html"},{"title":"write_lines – StringiFor","text":"public subroutine write_lines(unit, lines, form, iostat, iomsg) Write lines (records) to a connected-formatted unit. Note There is no doctests, this being tested by means of write_file doctests. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Called by proc~~write_lines~~CalledByGraph proc~write_lines write_lines proc~write_file write_file proc~write_file->proc~write_lines program~volatile_doctest~110 volatile_doctest program~volatile_doctest~110->proc~write_file program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->proc~write_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_lines Source Code subroutine write_lines ( unit , lines , form , iostat , iomsg ) !< Write lines (records) to a connected-formatted unit. !< !< @note There is no doctests, this being tested by means of [[write_file]] doctests. integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: l !< Counter. do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endsubroutine write_lines","tags":"","loc":"proc/write_lines.html"},{"title":"string_ – StringiFor","text":"private pure function string_(c) Return a string given a character input. print \"(L1)\" , string ( 'Hello World' ) // '' == 'Hello World' Arguments Type Intent Optional Attributes Name character, intent(in) :: c Character. Return Value type( string ) String. Contents Source Code string_ Source Code pure function string_ ( c ) !< Return a string given a character input. !< !<```fortran !< print \"(L1)\", string('Hello World')//''=='Hello World' !<``` !=> T <<< character ( * ), intent ( in ) :: c !< Character. type ( string ) :: string_ !< String. string_ % raw = c endfunction string_","tags":"","loc":"proc/string_.html"},{"title":"sadjustl_character – StringiFor","text":"private pure function sadjustl_character(s) result(adjusted) Left adjust a string by removing leading spaces (character output). type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , adjustl ( astring ) == 'Hello World!   ' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK,len=:),allocatable Adjusted string. Called by proc~~sadjustl_character~~CalledByGraph proc~sadjustl_character sadjustl_character interface~adjustl adjustl interface~adjustl->proc~sadjustl_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sadjustl_character Source Code pure function sadjustl_character ( s ) result ( adjusted ) !< Left adjust a string by removing leading spaces (character output). !< !<```fortran !< type(string) :: astring !< astring = '   Hello World!' !< print \"(L1)\", adjustl(astring)=='Hello World!   ' !<``` !=> T <<< class ( string ), intent ( in ) :: s !< String. character ( kind = CK , len = :), allocatable :: adjusted !< Adjusted string. if ( allocated ( s % raw )) adjusted = adjustl ( s % raw ) endfunction sadjustl_character","tags":"","loc":"proc/sadjustl_character.html"},{"title":"sadjustr_character – StringiFor","text":"private pure function sadjustr_character(s) result(adjusted) Right adjust a string by removing leading spaces (character output). type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , adjustr ( astring ) == '   Hello World!' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK,len=:),allocatable Adjusted string. Called by proc~~sadjustr_character~~CalledByGraph proc~sadjustr_character sadjustr_character interface~adjustr adjustr interface~adjustr->proc~sadjustr_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sadjustr_character Source Code pure function sadjustr_character ( s ) result ( adjusted ) !< Right adjust a string by removing leading spaces (character output). !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", adjustr(astring)=='   Hello World!' !<``` !=> T <<< class ( string ), intent ( in ) :: s !< String. character ( kind = CK , len = :), allocatable :: adjusted !< Adjusted string. if ( allocated ( s % raw )) adjusted = adjustr ( s % raw ) endfunction sadjustr_character","tags":"","loc":"proc/sadjustr_character.html"},{"title":"count_substring – StringiFor","text":"private elemental function count_substring(s, substring) result(No) Count the number of occurences of a substring into a string. print \"(L1)\" , count ( 'hello' , substring = 'll' ) == 1 Arguments Type Intent Optional Attributes Name character, intent(in) :: s String. character, intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Called by proc~~count_substring~~CalledByGraph proc~count_substring count_substring interface~count count interface~count->proc~count_substring Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code count_substring Source Code elemental function count_substring ( s , substring ) result ( No ) !< Count the number of occurences of a substring into a string. !< !<```fortran !< print \"(L1)\", count('hello', substring='ll')==1 !<``` !=> T <<< character ( * ), intent ( in ) :: s !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. No = 0 if ( len ( substring ) > len ( s )) return c1 = 1 do c2 = index ( string = s ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo endfunction count_substring","tags":"","loc":"proc/count_substring.html"},{"title":"sindex_character_string – StringiFor","text":"private elemental function sindex_character_string(s, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = index ( s = 'Hello World Hello!' , substring = string1 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = index ( s = 'Hello World Hello!' , substring = string1 , back = . true .) == index ( string = 'Hello World Hello!' , & substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s String. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sindex_character_string~~CalledByGraph proc~sindex_character_string sindex_character_string interface~index index interface~index->proc~sindex_character_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sindex_character_string Source Code elemental function sindex_character_string ( s , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'llo' !< test_passed(1) = index(s='Hello World Hello!', substring=string1)==index(string='Hello World Hello!', substring='llo') !< test_passed(2) = index(s='Hello World Hello!', substring=string1, back=.true.)==index(string='Hello World Hello!', & !<                                                                                       substring='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: s !< String. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( substring % raw )) then i = index ( string = s , substring = substring % raw , back = back ) else i = 0 endif endfunction sindex_character_string","tags":"","loc":"proc/sindex_character_string.html"},{"title":"sscan_character_string – StringiFor","text":"private elemental function sscan_character_string(s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = scan ( s = 'Hello World Hello!' , set = string1 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = scan ( s = 'Hello World Hello!' , set = string1 , back = . true .) == scan ( string = 'Hello World Hello!' , & set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sscan_character_string~~CalledByGraph proc~sscan_character_string sscan_character_string interface~scan scan interface~scan->proc~sscan_character_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sscan_character_string Source Code elemental function sscan_character_string ( s , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'llo' !< test_passed(1) = scan(s='Hello World Hello!', set=string1)==scan(string='Hello World Hello!', set='llo') !< test_passed(2) = scan(s='Hello World Hello!', set=string1, back=.true.)==scan(string='Hello World Hello!', & !<                                                                               set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: s !< String. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( set % raw )) then i = scan ( string = s , set = set % raw , back = back ) else i = 0 endif endfunction sscan_character_string","tags":"","loc":"proc/sscan_character_string.html"},{"title":"sverify_character_string – StringiFor","text":"private elemental function sverify_character_string(s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'ell' test_passed ( 1 ) = verify ( s = 'Hello World Hello!' , set = string1 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = verify ( s = 'Hello World Hello!' , set = string1 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sverify_character_string~~CalledByGraph proc~sverify_character_string sverify_character_string interface~verify verify interface~verify->proc~sverify_character_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sverify_character_string Source Code elemental function sverify_character_string ( s , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'ell' !< test_passed(1) = verify(s='Hello World Hello!', set=string1)==verify(string='Hello World Hello!', set='llo') !< test_passed(2) = verify(s='Hello World Hello!', set=string1, back=.true.)==verify(string='Hello World Hello!', set='llo', & !<                                                                                   back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: s !< String. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( set % raw )) then i = verify ( string = s , set = set % raw , back = back ) else i = 0 endif endfunction sverify_character_string","tags":"","loc":"proc/sverify_character_string.html"},{"title":"sadjustl – StringiFor","text":"private elemental function sadjustl(self) result(adjusted) Left adjust a string by removing leading spaces. type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , astring % adjustl () // '' == 'Hello World!   ' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Contents Source Code sadjustl Source Code elemental function sadjustl ( self ) result ( adjusted ) !< Left adjust a string by removing leading spaces. !< !<```fortran !< type(string) :: astring !< astring = '   Hello World!' !< print \"(L1)\", astring%adjustl()//''=='Hello World!   ' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) endfunction sadjustl","tags":"","loc":"proc/sadjustl.html"},{"title":"sadjustr – StringiFor","text":"private elemental function sadjustr(self) result(adjusted) Right adjust a string by removing leading spaces. type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % adjustr () // '' == '   Hello World!' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Contents Source Code sadjustr Source Code elemental function sadjustr ( self ) result ( adjusted ) !< Right adjust a string by removing leading spaces. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%adjustr()//''=='   Hello World!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) endfunction sadjustr","tags":"","loc":"proc/sadjustr.html"},{"title":"scount – StringiFor","text":"private elemental function scount(self, substring, ignore_isolated) result(No) Count the number of occurences of a substring into a string. Note If ignore_isolated is set to true the eventual “isolated” occurences are ignored: an isolated occurrences are those\n occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a\n right companion). type ( string ) :: astring logical :: test_passed ( 4 ) astring = '   Hello World  !    ' test_passed ( 1 ) = astring % count ( substring = ' ' ) == 10 astring = 'Hello World  !    ' test_passed ( 2 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 6 astring = '    Hello World  !' test_passed ( 3 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 6 astring = '   Hello World  !    ' test_passed ( 4 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 8 print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore “isolated” occurrences. Return Value integer Number of occurrences. Contents Source Code scount Source Code elemental function scount ( self , substring , ignore_isolated ) result ( No ) !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = '   Hello World  !    ' !< test_passed(1) = astring%count(substring=' ')==10 !< astring = 'Hello World  !    ' !< test_passed(2) = astring%count(substring=' ', ignore_isolated=.true.)==6 !< astring = '    Hello World  !' !< test_passed(3) = astring%count(substring=' ', ignore_isolated=.true.)==6 !< astring = '   Hello World  !    ' !< test_passed(4) = astring%count(substring=' ', ignore_isolated=.true.)==8 !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated c1 = 1 do c2 = index ( string = self % raw ( c1 :), substring = substring ) if ( c2 == 0 ) return if (. not . ignore_isolated_ ) then No = No + 1 else if (. not .(( c1 == 1. and . c2 == 1 ) . or . ( c1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif endfunction scount","tags":"","loc":"proc/scount.html"},{"title":"sindex_string_string – StringiFor","text":"private elemental function sindex_string_string(self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % index ( substring = string2 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = string2 , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sindex_string_string~~CalledByGraph proc~sindex_string_string sindex_string_string interface~index index interface~index->proc~sindex_string_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sindex_string_string Source Code elemental function sindex_string_string ( self , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !< !<```fortran !< type(string) :: string1 !< type(string) :: string2 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< string2 = 'llo' !< test_passed(1) = string1%index(substring=string2)==index(string='Hello World Hello!', substring='llo') !< test_passed(2) = string1%index(substring=string2, back=.true.)==index(string='Hello World Hello!', substring='llo', & !<                                                                       back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring % raw , back = back ) else i = 0 endif endfunction sindex_string_string","tags":"","loc":"proc/sindex_string_string.html"},{"title":"sindex_string_character – StringiFor","text":"private elemental function sindex_string_character(self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % index ( substring = 'llo' ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = 'llo' , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sindex_string_character~~CalledByGraph proc~sindex_string_character sindex_string_character interface~index index interface~index->proc~sindex_string_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sindex_string_character Source Code elemental function sindex_string_character ( self , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< test_passed(1) = string1%index(substring='llo')==index(string='Hello World Hello!', substring='llo') !< test_passed(2) = string1%index(substring='llo', back=.true.)==index(string='Hello World Hello!', substring='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif endfunction sindex_string_character","tags":"","loc":"proc/sindex_string_character.html"},{"title":"slen – StringiFor","text":"private elemental function slen(self) result(l) Return the length of a string. type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len () == len ( 'Hello World!   ' ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Contents Source Code slen Source Code elemental function slen ( self ) result ( l ) !< Return the length of a string. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%len()==len('Hello World!   ') !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif endfunction slen","tags":"","loc":"proc/slen.html"},{"title":"slen_trim – StringiFor","text":"private elemental function slen_trim(self) result(l) Return the length of a string, ignoring any trailing blanks. type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len_trim () == len_trim ( 'Hello World!   ' ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Called by proc~~slen_trim~~CalledByGraph proc~slen_trim slen_trim interface~len_trim len_trim interface~len_trim->proc~slen_trim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code slen_trim Source Code elemental function slen_trim ( self ) result ( l ) !< Return the length of a string, ignoring any trailing blanks. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%len_trim()==len_trim('Hello World!   ') !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif endfunction slen_trim","tags":"","loc":"proc/slen_trim.html"},{"title":"srepeat_string_string – StringiFor","text":"private elemental function srepeat_string_string(self, ncopies) result(repeated) Concatenates several copies of an input string. type ( string ) :: astring astring = 'x' print \"(L1)\" , astring % repeat ( 5 ) // '' == 'xxxxx' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Called by proc~~srepeat_string_string~~CalledByGraph proc~srepeat_string_string srepeat_string_string interface~repeat repeat interface~repeat->proc~srepeat_string_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code srepeat_string_string Source Code elemental function srepeat_string_string ( self , ncopies ) result ( repeated ) !< Concatenates several copies of an input string. !< !<```fortran !< type(string) :: astring !< astring = 'x' !< print \"(L1)\", astring%repeat(5)//''=='xxxxx' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. #ifdef _NVF character ( 9999 ) :: nvf_bug !< Work around for NVFortran bug. #endif #ifdef _NVF nvf_bug = self % raw repeated % raw = repeat ( string = trim ( nvf_bug ), ncopies = ncopies ) #else repeated % raw = repeat ( string = self % raw , ncopies = ncopies ) #endif endfunction srepeat_string_string","tags":"","loc":"proc/srepeat_string_string.html"},{"title":"srepeat_character_string – StringiFor","text":"private elemental function srepeat_character_string(rstring, ncopies) result(repeated) Concatenates several copies of an input string. type ( string ) :: astring astring = 'y' print \"(L1)\" , astring % repeat ( 'x' , 5 ) // '' == 'xxxxx' Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Contents Source Code srepeat_character_string Source Code elemental function srepeat_character_string ( rstring , ncopies ) result ( repeated ) !< Concatenates several copies of an input string. !< !<```fortran !< type(string) :: astring !< astring = 'y' !< print \"(L1)\", astring%repeat('x', 5)//''=='xxxxx' !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. repeated % raw = repeat ( string = rstring , ncopies = ncopies ) endfunction srepeat_character_string","tags":"","loc":"proc/srepeat_character_string.html"},{"title":"sscan_string_string – StringiFor","text":"private elemental function sscan_string_string(self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % scan ( set = string2 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = string2 , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sscan_string_string~~CalledByGraph proc~sscan_string_string sscan_string_string interface~scan scan interface~scan->proc~sscan_string_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sscan_string_string Source Code elemental function sscan_string_string ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !< !<```fortran !< type(string) :: string1 !< type(string) :: string2 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< string2 = 'llo' !< test_passed(1) = string1%scan(set=string2)==scan(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%scan(set=string2, back=.true.)==scan(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = scan ( string = self % raw , set = set % raw , back = back ) else i = 0 endif endfunction sscan_string_string","tags":"","loc":"proc/sscan_string_string.html"},{"title":"sscan_string_character – StringiFor","text":"private elemental function sscan_string_character(self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % scan ( set = 'llo' ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = 'llo' , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sscan_string_character~~CalledByGraph proc~sscan_string_character sscan_string_character interface~scan scan interface~scan->proc~sscan_string_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sscan_string_character Source Code elemental function sscan_string_character ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< test_passed(1) = string1%scan(set='llo')==scan(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%scan(set='llo', back=.true.)==scan(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif endfunction sscan_string_character","tags":"","loc":"proc/sscan_string_character.html"},{"title":"strim – StringiFor","text":"private elemental function strim(self) result(trimmed) Remove trailing spaces. type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % trim () == trim ( 'Hello World!   ' ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Called by proc~~strim~~CalledByGraph proc~strim strim interface~trim trim interface~trim->proc~strim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code strim Source Code elemental function strim ( self ) result ( trimmed ) !< Remove trailing spaces. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%trim()==trim('Hello World!   ') !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) endfunction strim","tags":"","loc":"proc/strim.html"},{"title":"sverify_string_string – StringiFor","text":"private elemental function sverify_string_string(self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % verify ( set = string2 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = string2 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sverify_string_string~~CalledByGraph proc~sverify_string_string sverify_string_string interface~verify verify interface~verify->proc~sverify_string_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sverify_string_string Source Code elemental function sverify_string_string ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !< !<```fortran !< type(string) :: string1 !< type(string) :: string2 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< string2 = 'llo' !< test_passed(1) = string1%verify(set=string2)==verify(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%verify(set=string2, back=.true.)==verify(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = verify ( string = self % raw , set = set % raw , back = back ) else i = 0 endif endfunction sverify_string_string","tags":"","loc":"proc/sverify_string_string.html"},{"title":"sverify_string_character – StringiFor","text":"private elemental function sverify_string_character(self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % verify ( set = 'llo' ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = 'llo' , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Called by proc~~sverify_string_character~~CalledByGraph proc~sverify_string_character sverify_string_character interface~verify verify interface~verify->proc~sverify_string_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sverify_string_character Source Code elemental function sverify_string_character ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< test_passed(1) = string1%verify(set='llo')==verify(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%verify(set='llo', back=.true.)==verify(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif endfunction sverify_string_character","tags":"","loc":"proc/sverify_string_character.html"},{"title":"basedir – StringiFor","text":"private elemental function basedir(self, sep) Return the base directory name of a string containing a file name. type ( string ) :: string1 logical :: test_passed ( 4 ) string1 = '/bar/foo.tar.bz2' test_passed ( 1 ) = string1 % basedir () // '' == '/bar' string1 = './bar/foo.tar.bz2' test_passed ( 2 ) = string1 % basedir () // '' == './bar' string1 = 'bar/foo.tar.bz2' test_passed ( 3 ) = string1 % basedir () // '' == 'bar' string1 = '\\bar\\foo.tar.bz2' test_passed ( 4 ) = string1 % basedir ( sep = '\\')//''==' \\ bar ' print ' ( L1 ) ' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Contents Source Code basedir Source Code elemental function basedir ( self , sep ) !< Return the base directory name of a string containing a file name. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(4) !< string1 = '/bar/foo.tar.bz2' !< test_passed(1) = string1%basedir()//''=='/bar' !< string1 = './bar/foo.tar.bz2' !< test_passed(2) = string1%basedir()//''=='./bar' !< string1 = 'bar/foo.tar.bz2' !< test_passed(3) = string1%basedir()//''=='bar' !< string1 = '\\bar\\foo.tar.bz2' !< test_passed(4) = string1%basedir(sep='\\')//''=='\\bar' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif endfunction basedir","tags":"","loc":"proc/basedir.html"},{"title":"basename – StringiFor","text":"private elemental function basename(self, sep, extension, strip_last_extension) Return the base file name of a string containing a file name. Optionally, the extension is also stripped if provided or the last one if required, e.g. type ( string ) :: astring logical :: test_passed ( 5 ) astring = 'bar/foo.tar.bz2' test_passed ( 1 ) = astring % basename () // '' == 'foo.tar.bz2' test_passed ( 2 ) = astring % basename ( extension = '.tar.bz2' ) // '' == 'foo' test_passed ( 3 ) = astring % basename ( strip_last_extension = . true .) // '' == 'foo.tar' astring = '\\bar\\foo.tar.bz2' test_passed ( 4 ) = astring % basename ( sep = '\\')//''==' foo . tar . bz2 ' astring = ' bar ' test_passed(5) = astring%basename(strip_last_extension=.true.)//''==' bar ' print ' ( L1 ) ' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Contents Source Code basename Source Code elemental function basename ( self , sep , extension , strip_last_extension ) !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(5) !< astring = 'bar/foo.tar.bz2' !< test_passed(1) = astring%basename()//''=='foo.tar.bz2' !< test_passed(2) = astring%basename(extension='.tar.bz2')//''=='foo' !< test_passed(3) = astring%basename(strip_last_extension=.true.)//''=='foo.tar' !< astring = '\\bar\\foo.tar.bz2' !< test_passed(4) = astring%basename(sep='\\')//''=='foo.tar.bz2' !< astring = 'bar' !< test_passed(5) = astring%basename(strip_last_extension=.true.)//''=='bar' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) if ( present ( extension )) then pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then pos = index ( basename % raw , '.' , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) endif endif endif endfunction basename","tags":"","loc":"proc/basename.html"},{"title":"camelcase – StringiFor","text":"private elemental function camelcase(self, sep) Return a string with all words capitalized without spaces. Note Multiple subsequent separators are collapsed to one occurence. type ( string ) :: astring astring = 'caMeL caSe var' print '(L1)' , astring % camelcase () // '' == 'CamelCaseVar' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Contents Source Code camelcase Source Code elemental function camelcase ( self , sep ) !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(L1)', astring%camelcase()//''=='CamelCaseVar' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif endfunction camelcase","tags":"","loc":"proc/camelcase.html"},{"title":"capitalize – StringiFor","text":"private elemental function capitalize(self) result(capitalized) Return a string with its first character capitalized and the rest lowercased. type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % capitalize () // '' == 'Say all hello world!' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Contents Source Code capitalize Source Code elemental function capitalize ( self ) result ( capitalized ) !< Return a string with its first character capitalized and the rest lowercased. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%capitalize()//''=='Say all hello world!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif endfunction capitalize","tags":"","loc":"proc/capitalize.html"},{"title":"chars – StringiFor","text":"private pure function chars(self) result(raw) Return the raw characters data. type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % chars () == 'say all Hello WorLD!' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),allocatable Raw characters data. Contents Source Code chars Source Code pure function chars ( self ) result ( raw ) !< Return the raw characters data. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%chars()=='say all Hello WorLD!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif endfunction chars","tags":"","loc":"proc/chars.html"},{"title":"colorize_str – StringiFor","text":"private pure function colorize_str(self, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, DEFAULT kind. type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % colorize ( color_fg = 'red' ) == '\u001b[31msay all Hello WorLD!\u001b[0m' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:),allocatable Colorized string. Calls proc~~colorize_str~~CallsGraph proc~colorize_str colorize_str colorize colorize proc~colorize_str->colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code colorize_str Source Code pure function colorize_str ( self , color_fg , color_bg , style ) result ( colorized ) !< Colorize and stylize strings, DEFAULT kind. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%colorize(color_fg='red')=='\u001b[31msay all Hello WorLD!\u001b[0m' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :), allocatable :: colorized !< Colorized string. colorized = colorize ( string = self % chars (), color_fg = color_fg , color_bg = color_bg , style = style ) endfunction colorize_str","tags":"","loc":"proc/colorize_str.html"},{"title":"decode – StringiFor","text":"private elemental function decode(self, codec) result(decoded) Return a string decoded accordingly the codec. Note Only BASE64 codec is currently available. type ( string ) :: astring astring = 'SG93IGFyZSB5b3U/' print '(L1)' , astring % decode ( codec = 'base64' ) // '' == 'How are you?' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. Calls proc~~decode~~CallsGraph proc~decode decode b64_decode b64_decode proc~decode->b64_decode Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code decode Source Code elemental function decode ( self , codec ) result ( decoded ) !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(L1)', astring%decode(codec='base64')//''=='How are you?' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif endfunction decode","tags":"","loc":"proc/decode.html"},{"title":"encode – StringiFor","text":"private elemental function encode(self, codec) result(encoded) Return a string encoded accordingly the codec. Note Only BASE64 codec is currently available. type ( string ) :: astring astring = 'How are you?' print '(L1)' , astring % encode ( codec = 'base64' ) // '' == 'SG93IGFyZSB5b3U/' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. Calls proc~~encode~~CallsGraph proc~encode encode b64_encode b64_encode proc~encode->b64_encode Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code encode Source Code elemental function encode ( self , codec ) result ( encoded ) !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(L1)', astring%encode(codec='base64')//''=='SG93IGFyZSB5b3U/' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif endfunction encode","tags":"","loc":"proc/encode.html"},{"title":"escape – StringiFor","text":"private elemental function escape(self, to_escape, esc) result(escaped) Escape backslashes (or custom escape character). type ( string ) :: astring logical :: test_passed ( 2 ) astring = '&#94;\\s \\d+\\s*' test_passed ( 1 ) = astring % escape ( to_escape = '\\')//''==' &#94;\\\\ s \\\\ d + \\\\ s * ' test_passed(2) = astring%escape(to_escape=' \\ ', esc=' | ')//''==' &#94;|\\ s |\\ d + |\\ s * ' print ' ( L1 ) ' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Contents Source Code escape Source Code elemental function escape ( self , to_escape , esc ) result ( escaped ) !< Escape backslashes (or custom escape character). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '&#94;\\s \\d+\\s*' !< test_passed(1) = astring%escape(to_escape='\\')//''=='&#94;\\\\s \\\\d+\\\\s*' !< test_passed(2) = astring%escape(to_escape='\\', esc='|')//''=='&#94;|\\s |\\d+|\\s*' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif endfunction escape","tags":"","loc":"proc/escape.html"},{"title":"extension – StringiFor","text":"private elemental function extension(self) Return the extension of a string containing a file name. type ( string ) :: astring astring = '/bar/foo.tar.bz2' print '(L1)' , astring % extension () // '' == '.bz2' Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Contents Source Code extension Source Code elemental function basename ( self , sep , extension , strip_last_extension ) !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(5) !< astring = 'bar/foo.tar.bz2' !< test_passed(1) = astring%basename()//''=='foo.tar.bz2' !< test_passed(2) = astring%basename(extension='.tar.bz2')//''=='foo' !< test_passed(3) = astring%basename(strip_last_extension=.true.)//''=='foo.tar' !< astring = '\\bar\\foo.tar.bz2' !< test_passed(4) = astring%basename(sep='\\')//''=='foo.tar.bz2' !< astring = 'bar' !< test_passed(5) = astring%basename(strip_last_extension=.true.)//''=='bar' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) if ( present ( extension )) then pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then pos = index ( basename % raw , '.' , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) endif endif endif endfunction basename elemental function camelcase ( self , sep ) !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(L1)', astring%camelcase()//''=='CamelCaseVar' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !< Return a string with its first character capitalized and the rest lowercased. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%capitalize()//''=='Say all hello world!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif endfunction capitalize pure function chars ( self ) result ( raw ) !< Return the raw characters data. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%chars()=='say all Hello WorLD!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif endfunction chars pure function colorize_str ( self , color_fg , color_bg , style ) result ( colorized ) !< Colorize and stylize strings, DEFAULT kind. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%colorize(color_fg='red')=='\u001b[31msay all Hello WorLD!\u001b[0m' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :), allocatable :: colorized !< Colorized string. colorized = colorize ( string = self % chars (), color_fg = color_fg , color_bg = color_bg , style = style ) endfunction colorize_str elemental function decode ( self , codec ) result ( decoded ) !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(L1)', astring%decode(codec='base64')//''=='How are you?' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif endfunction decode elemental function encode ( self , codec ) result ( encoded ) !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(L1)', astring%encode(codec='base64')//''=='SG93IGFyZSB5b3U/' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif endfunction encode elemental function escape ( self , to_escape , esc ) result ( escaped ) !< Escape backslashes (or custom escape character). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '&#94;\\s \\d+\\s*' !< test_passed(1) = astring%escape(to_escape='\\')//''=='&#94;\\\\s \\\\d+\\\\s*' !< test_passed(2) = astring%escape(to_escape='\\', esc='|')//''=='&#94;|\\s |\\d+|\\s*' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif endfunction escape elemental function extension ( self ) !< Return the extension of a string containing a file name. !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(L1)', astring%extension()//''=='.bz2' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) if ( pos > 0 ) extension % raw = self % raw ( pos :) endif endfunction extension","tags":"","loc":"proc/extension.html"},{"title":"fill – StringiFor","text":"private elemental function fill(self, width, right, filling_char) result(filled) Pad string on the left (or right) with zeros (or other char) to fill width. type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'this is string example....wow!!!' test_passed ( 1 ) = astring % fill ( width = 40 ) // '' == '00000000this is string example....wow!!!' test_passed ( 2 ) = astring % fill ( width = 50 ) // '' == '000000000000000000this is string example....wow!!!' test_passed ( 3 ) = astring % fill ( width = 50 , right = . true .) // '' == 'this is string example....wow!!!000000000000000000' test_passed ( 4 ) = astring % fill ( width = 40 , filling_char = '*' ) // '' == '********this is string example....wow!!!' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default “0”). Return Value type( string ) Filled string. Contents Source Code fill Source Code elemental function fill ( self , width , right , filling_char ) result ( filled ) !< Pad string on the left (or right) with zeros (or other char) to fill width. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = 'this is string example....wow!!!' !< test_passed(1) = astring%fill(width=40)//''=='00000000this is string example....wow!!!' !< test_passed(2) = astring%fill(width=50)//''=='000000000000000000this is string example....wow!!!' !< test_passed(3) = astring%fill(width=50, right=.true.)//''=='this is string example....wow!!!000000000000000000' !< test_passed(4) = astring%fill(width=40, filling_char='*')//''=='********this is string example....wow!!!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif endfunction fill","tags":"","loc":"proc/fill.html"},{"title":"insert_character – StringiFor","text":"private elemental function insert_character(self, substring, pos) result(inserted) Insert substring into string at a specified position. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 5 ) astring = 'this is string example wow!!!' acharacter = '... ' test_passed ( 1 ) = astring % insert ( substring = acharacter , pos = 1 ) // '' == '... this is string example wow!!!' test_passed ( 2 ) = astring % insert ( substring = acharacter , pos = 23 ) // '' == 'this is string example...  wow!!!' test_passed ( 3 ) = astring % insert ( substring = acharacter , pos = 29 ) // '' == 'this is string example wow!!!... ' test_passed ( 4 ) = astring % insert ( substring = acharacter , pos =- 1 ) // '' == '... this is string example wow!!!' test_passed ( 5 ) = astring % insert ( substring = acharacter , pos = 100 ) // '' == 'this is string example wow!!!... ' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Contents Source Code insert_character Source Code elemental function insert_character ( self , substring , pos ) result ( inserted ) !< Insert substring into string at a specified position. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(5) !< astring = 'this is string example wow!!!' !< acharacter = '... ' !< test_passed(1) = astring%insert(substring=acharacter, pos=1)//''=='... this is string example wow!!!' !< test_passed(2) = astring%insert(substring=acharacter, pos=23)//''=='this is string example...  wow!!!' !< test_passed(3) = astring%insert(substring=acharacter, pos=29)//''=='this is string example wow!!!... ' !< test_passed(4) = astring%insert(substring=acharacter, pos=-1)//''=='... this is string example wow!!!' !< test_passed(5) = astring%insert(substring=acharacter, pos=100)//''=='this is string example wow!!!... ' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. if ( allocated ( self % raw )) then inserted = self safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring // self % raw ( safepos :) endif else inserted % raw = substring endif endfunction insert_character","tags":"","loc":"proc/insert_character.html"},{"title":"insert_string – StringiFor","text":"private elemental function insert_string(self, substring, pos) result(inserted) Insert substring into string at a specified position. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 5 ) astring = 'this is string example wow!!!' anotherstring = '... ' test_passed ( 1 ) = astring % insert ( substring = anotherstring , pos = 1 ) // '' == '... this is string example wow!!!' test_passed ( 2 ) = astring % insert ( substring = anotherstring , pos = 23 ) // '' == 'this is string example...  wow!!!' test_passed ( 3 ) = astring % insert ( substring = anotherstring , pos = 29 ) // '' == 'this is string example wow!!!... ' test_passed ( 4 ) = astring % insert ( substring = anotherstring , pos =- 1 ) // '' == '... this is string example wow!!!' test_passed ( 5 ) = astring % insert ( substring = anotherstring , pos = 100 ) // '' == 'this is string example wow!!!... ' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Contents Source Code insert_string Source Code elemental function insert_string ( self , substring , pos ) result ( inserted ) !< Insert substring into string at a specified position. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(5) !< astring = 'this is string example wow!!!' !< anotherstring = '... ' !< test_passed(1) = astring%insert(substring=anotherstring, pos=1)//''=='... this is string example wow!!!' !< test_passed(2) = astring%insert(substring=anotherstring, pos=23)//''=='this is string example...  wow!!!' !< test_passed(3) = astring%insert(substring=anotherstring, pos=29)//''=='this is string example wow!!!... ' !< test_passed(4) = astring%insert(substring=anotherstring, pos=-1)//''=='... this is string example wow!!!' !< test_passed(5) = astring%insert(substring=anotherstring, pos=100)//''=='this is string example wow!!!... ' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. if ( allocated ( self % raw )) then inserted = self if ( allocated ( substring % raw )) then safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring % raw // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring % raw else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring % raw // self % raw ( safepos :) endif endif else if ( allocated ( substring % raw )) inserted % raw = substring % raw endif endfunction insert_string","tags":"","loc":"proc/insert_string.html"},{"title":"join_strings – StringiFor","text":"private pure function join_strings(self, array, sep) result(join) Return a string that is a join of an array of strings. The join-separator is set equals to self if self has a value or it is set to a null string ‘’. This value can be overridden\n passing a custom separator. type ( string ) :: astring type ( string ) :: strings ( 3 ) logical :: test_passed ( 5 ) strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 1 ) = ( astring % join ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) test_passed ( 2 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 3 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free test_passed ( 4 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' test_passed ( 5 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Contents Source Code join_strings Source Code pure function join_strings ( self , array , sep ) result ( join ) !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !< !<```fortran !< type(string) :: astring !< type(string) :: strings(3) !< logical      :: test_passed(5) !< strings(1) = 'one' !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(1) = (astring%join(array=strings)//''==strings(1)//strings(2)//strings(3)) !< test_passed(2) = (astring%join(array=strings, sep='-')//''==strings(1)//'-'//strings(2)//'-'//strings(3)) !< call strings(1)%free !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(3) = (astring%join(array=strings, sep='-')//''==strings(2)//'-'//strings(3)) !< strings(1) = 'one' !< strings(2) = 'two' !< call strings(3)%free !< test_passed(4) = (astring%join(array=strings, sep='-')//''==strings(1)//'-'//strings(2)) !< strings(1) = 'one' !< call strings(2)%free !< strings(3) = 'three' !< test_passed(5) = (astring%join(array=strings, sep='-')//''==strings(1)//'-'//strings(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction join_strings","tags":"","loc":"proc/join_strings.html"},{"title":"join_characters – StringiFor","text":"private pure function join_characters(self, array, sep) result(join) Return a string that is a join of an array of characters. The join-separator is set equals to self if self has a value or it is set to a null string ‘’. This value can be overridden\n passing a custom separator. type ( string ) :: astring character ( 5 ) :: characters ( 3 ) logical :: test_passed ( 6 ) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 1 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) test_passed ( 2 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 3 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 4 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 5 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' astring = '_' test_passed ( 6 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // '_' // characters ( 2 ) // '_' // characters ( 3 )) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Contents Source Code join_characters Source Code pure function join_characters ( self , array , sep ) result ( join ) !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !< !<```fortran !< type(string) :: astring !< character(5) :: characters(3) !< logical      :: test_passed(6) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(1) = (astring%join(array=characters)//''==characters(1)//characters(2)//characters(3)) !< test_passed(2) = (astring%join(array=characters, sep='-')//''==characters(1)//'-'//characters(2)//'-'//characters(3)) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(3) = (astring%join(array=characters, sep='-')//''==characters(2)//'-'//characters(3)) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(4) = (astring%join(array=characters, sep='-')//''==characters(1)//'-'//characters(2)) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(5) = (astring%join(array=characters, sep='-')//''==characters(1)//'-'//characters(3)) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = 'three' !< astring = '_' !< test_passed(6) = (astring%join(array=characters)//''==characters(1)//'_'//characters(2)//'_'//characters(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction join_characters","tags":"","loc":"proc/join_characters.html"},{"title":"strjoin_strings – StringiFor","text":"private pure function strjoin_strings(array, sep) result(join) Return a string that is a join of an array of strings. The join-separator is set equals to a null string ‘’ if custom separator isn’t specified. type ( string ) :: strings ( 3 ) logical :: test_passed ( 5 ) strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 1 ) = ( strjoin ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) test_passed ( 2 ) = ( strjoin ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 3 ) = ( strjoin ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free test_passed ( 4 ) = ( strjoin ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' test_passed ( 5 ) = ( strjoin ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Called by proc~~strjoin_strings~~CalledByGraph proc~strjoin_strings strjoin_strings proc~strjoin_strings_array strjoin_strings_array proc~strjoin_strings_array->proc~strjoin_strings interface~strjoin strjoin interface~strjoin->proc~strjoin_strings interface~strjoin->proc~strjoin_strings_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code strjoin_strings Source Code pure function strjoin_strings ( array , sep ) result ( join ) !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< !<```fortran !< type(string)     :: strings(3) !< logical          :: test_passed(5) !< strings(1) = 'one' !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(1) = (strjoin(array=strings)//''==strings(1)//strings(2)//strings(3)) !< test_passed(2) = (strjoin(array=strings, sep='-')//''==strings(1)//'-'//strings(2)//'-'//strings(3)) !< call strings(1)%free !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(3) = (strjoin(array=strings, sep='-')//''==strings(2)//'-'//strings(3)) !< strings(1) = 'one' !< strings(2) = 'two' !< call strings(3)%free !< test_passed(4) = (strjoin(array=strings, sep='-')//''==strings(1)//'-'//strings(2)) !< strings(1) = 'one' !< call strings(2)%free !< strings(3) = 'three' !< test_passed(5) = (strjoin(array=strings, sep='-')//''==strings(1)//'-'//strings(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. sep_ = '' if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction strjoin_strings","tags":"","loc":"proc/strjoin_strings.html"},{"title":"strjoin_characters – StringiFor","text":"private pure function strjoin_characters(array, sep, is_trim) result(join) Return a string that is a join of an array of characters. The join-separator is set equals to a null string ‘’ if custom separator isn’t specified.\n The trim function is applied to array items if optional logical is_trim variable isn’t set to .false. character ( 5 ) :: characters ( 3 ) logical :: test_passed ( 13 ) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 1 ) = ( strjoin ( array = characters ) // '' == trim ( characters ( 1 )) // trim ( characters ( 2 )) // trim ( characters ( 3 ))) test_passed ( 2 ) = ( strjoin ( array = characters , sep = '-' ) // '' == trim ( characters ( 1 )) // '-' // trim ( characters ( 2 )) // '-' // trim ( characters ( 3 ))) test_passed ( 3 ) = ( strjoin ( array = characters , is_trim = . false .) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) test_passed ( 4 ) = ( strjoin ( array = characters , sep = '-' , is_trim = . false .) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 5 ) = ( strjoin ( array = characters ) // '' == trim ( characters ( 2 )) // trim ( characters ( 3 ))) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 6 ) = ( strjoin ( array = characters ) // '' == trim ( characters ( 1 )) // trim ( characters ( 2 ))) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 7 ) = ( strjoin ( array = characters ) // '' == trim ( characters ( 1 )) // trim ( characters ( 3 ))) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 8 ) = ( strjoin ( array = characters , sep = '-' ) // '' == trim ( characters ( 2 )) // '-' // trim ( characters ( 3 ))) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 9 ) = ( strjoin ( array = characters , sep = '-' ) // '' == trim ( characters ( 1 )) // '-' // trim ( characters ( 2 ))) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 10 ) = ( strjoin ( array = characters , sep = '-' ) // '' == trim ( characters ( 1 )) // '-' // trim ( characters ( 3 ))) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 11 ) = ( strjoin ( array = characters , sep = '-' , is_trim = . false .) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 12 ) = ( strjoin ( array = characters , sep = '-' , is_trim = . false .) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 13 ) = ( strjoin ( array = characters , sep = '-' , is_trim = . false .) // '' == characters ( 1 ) // '-' // characters ( 3 )) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not Return Value type( string ) The join of array. Called by proc~~strjoin_characters~~CalledByGraph proc~strjoin_characters strjoin_characters proc~strjoin_characters_array strjoin_characters_array proc~strjoin_characters_array->proc~strjoin_characters interface~strjoin strjoin interface~strjoin->proc~strjoin_characters interface~strjoin->proc~strjoin_characters_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code strjoin_characters Source Code pure function strjoin_characters ( array , sep , is_trim ) result ( join ) !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< The trim function is applied to array items if optional logical is_trim variable isn't set to .false. !< !<```fortran !< character(5) :: characters(3) !< logical      :: test_passed(13) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(1) = (strjoin(array=characters)//''==trim(characters(1))//trim(characters(2))//trim(characters(3))) !< test_passed(2) = (strjoin(array=characters, sep='-')//''==trim(characters(1))//'-'//trim(characters(2))//'-'//trim(characters(3))) !< test_passed(3) = ( strjoin(array=characters, is_trim=.false.)//''==characters(1)//characters(2)//characters(3)) !< test_passed(4) = ( strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(1)//'-'//characters(2)//'-'//characters(3)) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(5) = (strjoin(array=characters)//''==trim(characters(2))//trim(characters(3))) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(6) = (strjoin(array=characters)//''==trim(characters(1))//trim(characters(2))) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(7) = (strjoin(array=characters)//''==trim(characters(1))//trim(characters(3))) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(8) = (strjoin(array=characters, sep='-')//''==trim(characters(2))//'-'//trim(characters(3))) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(9) = (strjoin(array=characters, sep='-')//''==trim(characters(1))//'-'//trim(characters(2))) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(10) = (strjoin(array=characters, sep='-')//''==trim(characters(1))//'-'//trim(characters(3))) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(11) = (strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(2)//'-'//characters(3)) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(12) = (strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(1)//'-'//characters(2)) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(13) = (strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(1)//'-'//characters(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. logical , intent ( in ), optional :: is_trim !< Flag to setup trim character or not type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. logical :: is_trim_ !< Flag to setup trim character or not integer :: a !< Counter. sep_ = '' if ( present ( sep )) sep_ = sep is_trim_ = . true . ; if ( present ( is_trim )) is_trim_ = is_trim join = '' if ( is_trim_ ) then do a = 2 , size ( array , dim = 1 ) if ( trim ( array ( a )) /= '' ) join % raw = join % raw // sep_ // trim ( array ( a )) enddo if ( trim ( array ( 1 )) /= '' ) then join % raw = trim ( array ( 1 )) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif else do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endif endfunction strjoin_characters","tags":"","loc":"proc/strjoin_characters.html"},{"title":"strjoin_strings_array – StringiFor","text":"private pure function strjoin_strings_array(array, sep, is_col) result(join) Return a string that is a join of columns or rows of an array of strings. The join-separator is set equals to a null string ‘’ if custom separator isn’t specified.\n The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). type ( string ), allocatable :: strings_arr (:, :) logical :: test_passed ( 5 ) strings_arr = reshape ( source = & [ string ( 'one' ), string ( 'two' ), string ( 'three' ), & string ( 'ONE' ), string ( 'TWO' ), string ( 'THREE' )], & shape = [ 3 , 2 ] ) test_passed ( 1 ) = all ( strjoin ( array = strings_arr ) == & reshape ([ string ( 'onetwothree' ), string ( 'ONETWOTHREE' )], & shape = [ 2 ]) ) test_passed ( 2 ) = all ( strjoin ( array = strings_arr , sep = '_' ) == & reshape ([ string ( 'one_two_three' ), string ( 'ONE_TWO_THREE' )], & shape = [ 2 ]) ) test_passed ( 3 ) = all ( strjoin ( array = strings_arr , is_col = . false .) == & reshape ([ string ( 'oneONE' ), string ( 'twoTWO' ), string ( 'threeTHREE' )], & shape = [ 3 ]) ) test_passed ( 4 ) = all ( strjoin ( array = strings_arr , sep = '_' , is_col = . false .) == & reshape ([ string ( 'one_ONE' ), string ( 'two_TWO' ), string ( 'three_THREE' )], & shape = [ 3 ]) ) call strings_arr ( 2 , 1 )% free test_passed ( 5 ) = all ( strjoin ( array = strings_arr , sep = '_' , is_col = . false .) == & reshape ([ string ( 'one_ONE' ), string ( 'TWO' ), string ( 'three_THREE' )], & shape = [ 3 ]) ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ),allocatable,(:) The join of array. Calls proc~~strjoin_strings_array~~CallsGraph proc~strjoin_strings_array strjoin_strings_array proc~strjoin_strings strjoin_strings proc~strjoin_strings_array->proc~strjoin_strings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~strjoin_strings_array~~CalledByGraph proc~strjoin_strings_array strjoin_strings_array interface~strjoin strjoin interface~strjoin->proc~strjoin_strings_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code strjoin_strings_array Source Code pure function strjoin_strings_array ( array , sep , is_col ) result ( join ) !< Return a string that is a join of columns or rows of an array of strings. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). !< !<```fortran !< type(string), allocatable :: strings_arr(:, :) !< logical                   :: test_passed(5) !< !< strings_arr = reshape( source = & !<                        [string('one'), string('two'), string('three'),  & !<                         string('ONE'), string('TWO'), string('THREE')], & !<                        shape = [3, 2] ) !< !< test_passed(1) = all( strjoin(array=strings_arr) == & !<                       reshape([string('onetwothree'), string('ONETWOTHREE')], & !<                       shape = [2]) ) !< !< test_passed(2) = all( strjoin(array=strings_arr, sep='_') == & !<                       reshape([string('one_two_three'), string('ONE_TWO_THREE')], & !<                       shape = [2]) ) !< !<  test_passed(3) = all( strjoin(array=strings_arr, is_col=.false.) == & !<                        reshape([string('oneONE'), string('twoTWO'), string('threeTHREE')], & !<                        shape = [3]) ) !< !<  test_passed(4) = all( strjoin(array=strings_arr, sep='_', is_col=.false.) == & !<                        reshape([string('one_ONE'), string('two_TWO'), string('three_THREE')], & !<                        shape = [3]) ) !< !< call strings_arr(2, 1)%free !< test_passed(5) = all( strjoin(array=strings_arr, sep='_', is_col=.false.) == & !<                  reshape([string('one_ONE'), string('TWO'), string('three_THREE')], & !<                  shape = [3]) ) !< !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: array ( 1 :, 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. logical , intent ( in ), optional :: is_col !< Direction: 'columns' if .true. or 'rows' if .false. type ( string ), allocatable :: join (:) !< The join of array. type ( string ), allocatable :: slice (:) !< The column or row slice of array character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. logical :: is_col_ !< Direction, default value. integer :: a , join_size , slice_size !< Counter, sizes of join vector and of slice of array sep_ = '' ; if ( present ( sep )) sep_ = sep is_col_ = . true . ; if ( present ( is_col )) is_col_ = is_col if ( is_col_ ) then join_size = size ( array , dim = 2 ) slice_size = size ( array , dim = 1 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( slice ( slice_size )) do a = 1 , join_size slice (:) = array (:, a ) join ( a ) = strjoin_strings ( slice , sep_ ) end do else join_size = size ( array , dim = 1 ) slice_size = size ( array , dim = 2 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( slice ( slice_size )) do a = 1 , join_size slice (:) = array ( a , :) join ( a ) = strjoin_strings ( slice , sep_ ) end do endif endfunction strjoin_strings_array","tags":"","loc":"proc/strjoin_strings_array.html"},{"title":"strjoin_characters_array – StringiFor","text":"private pure function strjoin_characters_array(array, sep, is_trim, is_col) result(join) Return a string that is a join of columns or rows of an array of characters. The join-separator is set equals to a null string ‘’ if custom separator isn’t specified.\n The trim function is applied to array items if optional logical is_trim variable isn’t set to .false.\n The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). character ( len = 10 ) :: chars_arr ( 3 , 2 ) logical :: test_passed ( 9 ) chars_arr (:, 1 ) = [ 'one       ' , 'two       ' , 'three     ' ] chars_arr (:, 2 ) = [ 'ONE       ' , 'TWO       ' , 'THREE     ' ] test_passed ( 1 ) = all ( strjoin ( array = chars_arr ) == & reshape ([ string ( 'onetwothree' ), string ( 'ONETWOTHREE' )], & shape = [ 2 ]) ) test_passed ( 2 ) = all ( strjoin ( array = chars_arr , is_trim = . false .) == & reshape ([ string ( 'one       two       three     ' ), & string ( 'ONE       TWO       THREE     ' )], & shape = [ 2 ]) ) test_passed ( 3 ) = all ( strjoin ( array = chars_arr , sep = '_' ) == & reshape ([ string ( 'one_two_three' ), string ( 'ONE_TWO_THREE' )], & shape = [ 2 ]) ) test_passed ( 4 ) = all ( strjoin ( array = chars_arr , sep = '_' , is_trim = . false .) == & reshape ([ string ( 'one       _two       _three     ' ), & string ( 'ONE       _TWO       _THREE     ' )], & shape = [ 2 ]) ) test_passed ( 5 ) = all ( strjoin ( array = chars_arr , is_col = . false .) == & reshape ([ string ( 'oneONE' ), string ( 'twoTWO' ), string ( 'threeTHREE' )], & shape = [ 3 ]) ) test_passed ( 6 ) = all ( strjoin ( array = chars_arr , is_trim = . false ., is_col = . false .) == & reshape ([ string ( 'one       ONE       ' ), & string ( 'two       TWO       ' ), & string ( 'three     THREE     ' )], & shape = [ 3 ]) ) test_passed ( 7 ) = all ( strjoin ( array = chars_arr , sep = '_' , is_col = . false .) == & reshape ([ string ( 'one_ONE' ), string ( 'two_TWO' ), string ( 'three_THREE' )], & shape = [ 3 ]) ) test_passed ( 8 ) = all ( strjoin ( array = chars_arr , sep = '_' , is_trim = . false ., is_col = . false .) == & reshape ([ string ( 'one       _ONE       ' ), & string ( 'two       _TWO       ' ), & string ( 'three     _THREE     ' )], & shape = [ 3 ]) ) chars_arr ( 2 , 1 ) = '' test_passed ( 9 ) = all ( strjoin ( array = chars_arr , sep = '_' , is_col = . false .) == & reshape ([ string ( 'one_ONE' ), & string ( 'TWO' ), & string ( 'three_THREE' )], & shape = [ 3 ]) ) print '(L1)' , all ( test_passed ) all items of character array have equal lengths Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ),allocatable,(:) The join of array. Calls proc~~strjoin_characters_array~~CallsGraph proc~strjoin_characters_array strjoin_characters_array proc~strjoin_characters strjoin_characters proc~strjoin_characters_array->proc~strjoin_characters Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~strjoin_characters_array~~CalledByGraph proc~strjoin_characters_array strjoin_characters_array interface~strjoin strjoin interface~strjoin->proc~strjoin_characters_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code strjoin_characters_array Source Code pure function strjoin_characters_array ( array , sep , is_trim , is_col ) result ( join ) !< Return a string that is a join of columns or rows of an array of characters. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< The trim function is applied to array items if optional logical is_trim variable isn't set to .false. !< The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). !< !<```fortran !< character(len=10)         :: chars_arr(3, 2) !< logical                   :: test_passed(9) !< chars_arr(:, 1) = ['one       ', 'two       ', 'three     '] !< chars_arr(:, 2) = ['ONE       ', 'TWO       ', 'THREE     '] !< !< test_passed(1) = all( strjoin(array=chars_arr) == & !<                       reshape([string('onetwothree'), string('ONETWOTHREE')], & !<                       shape = [2]) ) !< !< test_passed(2) = all( strjoin(array=chars_arr, is_trim=.false.) ==  & !<                       reshape([string('one       two       three     '),  & !<                                string('ONE       TWO       THREE     ')], & !<                       shape = [2]) ) !< !< test_passed(3) = all( strjoin(array=chars_arr, sep='_') == & !<                       reshape([string('one_two_three'), string('ONE_TWO_THREE')], & !<                       shape = [2]) ) !< !< test_passed(4) = all( strjoin(array=chars_arr, sep='_', is_trim=.false.) ==  & !<                       reshape([string('one       _two       _three     '),  & !<                                string('ONE       _TWO       _THREE     ')], & !<                       shape = [2]) ) !< !< test_passed(5) = all( strjoin(array=chars_arr, is_col=.false.) == & !<                       reshape([string('oneONE'), string('twoTWO'), string('threeTHREE')], & !<                       shape = [3]) ) !< !< test_passed(6) = all( strjoin(array=chars_arr, is_trim=.false., is_col=.false.) ==  & !<                       reshape([string('one       ONE       '),  & !<                                string('two       TWO       '),  & !<                                string('three     THREE     ')], & !<                       shape = [3]) ) !< !< test_passed(7) = all( strjoin(array=chars_arr, sep='_', is_col=.false.) == & !<                       reshape([string('one_ONE'), string('two_TWO'), string('three_THREE')], & !<                       shape = [3]) ) !< !< test_passed(8) = all( strjoin(array=chars_arr, sep='_', is_trim=.false., is_col=.false.) ==  & !<                       reshape([string('one       _ONE       '),  & !<                                string('two       _TWO       '),  & !<                                string('three     _THREE     ')], & !<                       shape = [3]) ) !< !< chars_arr(2,1) = '' !< test_passed(9) = all( strjoin(array=chars_arr, sep='_', is_col=.false.) ==  & !<                       reshape([string('one_ONE'),  & !<                                string('TWO'),  & !<                                string('three_THREE')], & !<                       shape = [3]) ) !< !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :, 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. logical , intent ( in ), optional :: is_trim !< Flag to setup trim character or not logical , intent ( in ), optional :: is_col !< Direction: 'columns' if .true. or 'rows' if .false. type ( string ), allocatable :: join (:) !< The join of array. character ( kind = CK , len = :), allocatable :: slice (:) !< The column or row slice of array character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. logical :: is_trim_ !< Flag to setup trim character or not logical :: is_col_ !< Direction, default value. integer :: a , join_size , slice_size !< Counter, sizes of join vector and of slice of array integer :: item_len !< Length of array item (all items of character array have equal lengths) item_len = len ( array ( 1 , 1 )) !< all items of character array have equal lengths sep_ = '' ; if ( present ( sep )) sep_ = sep is_trim_ = . true . ; if ( present ( is_trim )) is_trim_ = is_trim is_col_ = . true . ; if ( present ( is_col )) is_col_ = is_col if ( is_col_ ) then join_size = size ( array , dim = 2 ) slice_size = size ( array , dim = 1 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( character ( len = item_len ) :: slice ( slice_size )) do a = 1 , join_size slice (:) = array (:, a ) join ( a ) = strjoin_characters ( slice , sep_ , is_trim_ ) end do else join_size = size ( array , dim = 1 ) slice_size = size ( array , dim = 2 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( character ( len = item_len ) :: slice ( slice_size )) do a = 1 , join_size slice (:) = array ( a , :) join ( a ) = strjoin_characters ( slice , sep_ , is_trim_ ) end do endif endfunction strjoin_characters_array","tags":"","loc":"proc/strjoin_characters_array.html"},{"title":"lower – StringiFor","text":"private elemental function lower(self) Return a string with all lowercase characters. type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % lower () // '' == 'hello world!' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Contents Source Code lower Source Code elemental function lower ( self ) !< Return a string with all lowercase characters. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%lower()//''=='hello world!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif endfunction lower","tags":"","loc":"proc/lower.html"},{"title":"partition – StringiFor","text":"private pure function partition(self, sep) result(partitions) Split string at separator and return the 3 parts (before, the separator and after). type ( string ) :: astring type ( string ) :: strings ( 3 ) logical :: test_passed ( 3 ) astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )(1:3) after the separator. Contents Source Code partition Source Code pure function partition ( self , sep ) result ( partitions ) !< Split string at separator and return the 3 parts (before, the separator and after). !< !<```fortran !< type(string) :: astring !< type(string) :: strings(3) !< logical      :: test_passed(3) !< astring = 'Hello WorLD!' !< strings = astring%partition(sep='lo Wo') !< test_passed(1) = (strings(1)//''=='Hel'.and.strings(2)//''=='lo Wo'.and.strings(3)//''=='rLD!') !< strings = astring%partition(sep='Hello') !< test_passed(2) = (strings(1)//''==''.and.strings(2)//''=='Hello'.and.strings(3)//''==' WorLD!') !< astring = 'Hello WorLD!' !< strings = astring%partition() !< test_passed(3) = (strings(1)//''=='Hello'.and.strings(2)//''==' '.and.strings(3)//''=='WorLD!') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) endif endif endfunction partition","tags":"","loc":"proc/partition.html"},{"title":"replace – StringiFor","text":"private elemental function replace(self, old, new, count) result(replaced) Return a string with all occurrences of substring old replaced by new. type ( string ) :: astring logical :: test_passed ( 3 ) astring = 'When YOU are sad YOU should think to me :-)' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) astring = repeat ( new_line ( 'a' ) // 'abcd' , 20 ) astring = astring % replace ( old = new_line ( 'a' ), new = '|cr|' ) astring = astring % replace ( old = '|cr|' , new = new_line ( 'a' ) // '    ' ) test_passed ( 3 ) = ( astring // '' == repeat ( new_line ( 'a' ) // '    ' // 'abcd' , 20 )) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Contents Source Code replace Source Code elemental function replace ( self , old , new , count ) result ( replaced ) !< Return a string with all occurrences of substring old replaced by new. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(3) !< astring = 'When YOU are sad YOU should think to me :-)' !< test_passed(1) = (astring%replace(old='YOU', new='THEY')//''=='When THEY are sad THEY should think to me :-)') !< test_passed(2) = (astring%replace(old='YOU', new='THEY', count=1)//''=='When THEY are sad YOU should think to me :-)') !< astring = repeat(new_line('a')//'abcd', 20) !< astring = astring%replace(old=new_line('a'), new='|cr|') !< astring = astring%replace(old='|cr|', new=new_line('a')//'    ') !< test_passed(3) = (astring//''==repeat(new_line('a')//'    '//'abcd', 20)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif endfunction replace","tags":"","loc":"proc/replace.html"},{"title":"reverse – StringiFor","text":"private elemental function reverse(self) result(reversed) Return a reversed string. type ( string ) :: astring logical :: test_passed ( 2 ) astring = 'abcdefghilmnopqrstuvz' test_passed ( 1 ) = ( astring % reverse () // '' == 'zvutsrqponmlihgfedcba' ) astring = '0123456789' test_passed ( 2 ) = ( astring % reverse () // '' == '9876543210' ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Contents Source Code reverse Source Code elemental function reverse ( self ) result ( reversed ) !< Return a reversed string. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = 'abcdefghilmnopqrstuvz' !< test_passed(1) = (astring%reverse()//''=='zvutsrqponmlihgfedcba') !< astring = '0123456789' !< test_passed(2) = (astring%reverse()//''=='9876543210') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif endfunction reverse","tags":"","loc":"proc/reverse.html"},{"title":"search – StringiFor","text":"private function search(self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Search for tagged record into string, return the first record found (if any) matching the tags. Optionally, returns the indexes of tag start/end, thus this is not an elemental function. Note The tagged record is searched into self if allocated otherwise into in_string if passed or, eventually, into in_character is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are\n zero. type ( string ) :: astring type ( string ) :: anotherstring character ( len = :), allocatable :: acharacter integer :: istart integer :: iend logical :: test_passed ( 5 ) astring = '<test> <first> hello </first> <first> not the first </first> </test>' anotherstring = astring % search ( tag_start = '<first>' , tag_end = '</first>' ) test_passed ( 1 ) = anotherstring // '' == '<first> hello </first>' astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' anotherstring = astring % search ( tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 2 ) = anotherstring // '' == '<a> <a> <a> the nested a </a> </a> </a>' call astring % free anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_string = anotherstring , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 3 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' call astring % free acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 4 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<sec>' , tag_end = '</sec>' , istart = istart , iend = iend ) test_passed ( 5 ) = astring // '' == acharacter ( 31 : 67 ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Contents Source Code search Source Code function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. !< !<```fortran !< type(string)                  :: astring !< type(string)                  :: anotherstring !< character(len=:), allocatable :: acharacter !< integer                       :: istart !< integer                       :: iend !< logical                       :: test_passed(5) !< astring = '<test> <first> hello </first> <first> not the first </first> </test>' !< anotherstring = astring%search(tag_start='<first>', tag_end='</first>') !< test_passed(1) = anotherstring//''=='<first> hello </first>' !< astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' !< anotherstring = astring%search(tag_start='<a>', tag_end='</a>') !< test_passed(2) = anotherstring//''=='<a> <a> <a> the nested a </a> </a> </a>' !< call astring%free !< anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' !< astring = astring%search(in_string=anotherstring, tag_start='<a>', tag_end='</a>') !< test_passed(3) = astring//''=='<a> <a> <a> the nested a </a> </a> </a>' !< call astring%free !< acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' !< astring = astring%search(in_character=acharacter, tag_start='<a>', tag_end='</a>') !< test_passed(4) = astring//''=='<a> <a> <a> the nested a </a> </a> </a>' !< acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' !< astring = astring%search(in_character=acharacter, tag_start='<sec>', tag_end='</sec>', istart=istart, iend=iend) !< test_passed(5) = astring//''==acharacter(31:67) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) raw = self % raw endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % count ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ endfunction search","tags":"","loc":"proc/search.html"},{"title":"slice – StringiFor","text":"private pure function slice(self, istart, iend) result(raw) Return the raw characters data sliced. type ( string ) :: astring astring = 'the Quick Brown fox Jumps over the Lazy Dog.' print \"(A)\" , astring % slice ( 11 , 25 ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK,len=:),allocatable Raw characters data. Contents Source Code slice Source Code pure function slice ( self , istart , iend ) result ( raw ) !< Return the raw characters data sliced. !< !<```fortran !< type(string) :: astring !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< print \"(A)\", astring%slice(11,25) !<``` !=> Brown fox Jumps <<< class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: istart !< Slice start index. integer , intent ( in ) :: iend !< Slice end   index. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. if ( allocated ( self % raw )) then raw = self % raw ( istart : iend ) else raw = '' endif endfunction slice","tags":"","loc":"proc/slice.html"},{"title":"snakecase – StringiFor","text":"private elemental function snakecase(self, sep) Return a string with all words lowercase separated by “_”. Note Multiple subsequent separators are collapsed to one occurence. type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % snakecase () // '' == 'the_quick_brown_fox_jumps_over_the_lazy_dog.' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Contents Source Code snakecase Source Code elemental function snakecase ( self , sep ) !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< test_passed(1) = astring%snakecase()//''=='the_quick_brown_fox_jumps_over_the_lazy_dog.' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif endfunction snakecase","tags":"","loc":"proc/snakecase.html"},{"title":"startcase – StringiFor","text":"private elemental function startcase(self, sep) Return a string with all words capitalized, e.g. title case. Note Multiple subsequent separators are collapsed to one occurence. type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % startcase () // '' == 'The Quick Brown Fox Jumps Over The Lazy Dog.' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Contents Source Code startcase Source Code elemental function startcase ( self , sep ) !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< test_passed(1) = astring%startcase()//''=='The Quick Brown Fox Jumps Over The Lazy Dog.' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif endfunction startcase","tags":"","loc":"proc/startcase.html"},{"title":"strip – StringiFor","text":"private elemental function strip(self, remove_nulls) Return a copy of the string with the leading and trailing characters removed. Note Multiple subsequent separators are collapsed to one occurence. type ( string ) :: astring logical :: test_passed ( 1 ) astring = '  Hello World!   ' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. Contents Source Code strip Source Code elemental function strip ( self , remove_nulls ) !< Return a copy of the string with the leading and trailing characters removed. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = '  Hello World!   ' !< test_passed(1) = astring%strip()//''=='Hello World!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: remove_nulls !< Remove null characters at the end. type ( string ) :: strip !< The stripped string. integer :: c !< Counter. if ( allocated ( self % raw )) then strip = self % adjustl () strip = strip % trim () if ( present ( remove_nulls )) then if ( remove_nulls ) then c = index ( self % raw , char ( 0 )) if ( c > 0 ) strip % raw = strip % raw ( 1 : c - 1 ) endif endif endif endfunction strip","tags":"","loc":"proc/strip.html"},{"title":"swapcase – StringiFor","text":"private elemental function swapcase(self) Return a copy of the string with uppercase characters converted to lowercase and vice versa. type ( string ) :: astring logical :: test_passed ( 1 ) astring = '  Hello World!   ' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Contents Source Code swapcase Source Code elemental function swapcase ( self ) !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = '  Hello World!   ' !< test_passed(1) = astring%swapcase()//''=='  hELLO wORLD!   ' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif endfunction swapcase","tags":"","loc":"proc/swapcase.html"},{"title":"tempname – StringiFor","text":"private function tempname(self, is_file, prefix, path) Return a safe temporary name suitable for temporary file or directories. type ( string ) :: astring character ( len = :), allocatable :: tmpname logical :: test_passed ( 5 ) tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 1 )) test_passed ( 1 ) = . not . test_passed ( 1 ) tmpname = astring % tempname ( is_file = . false .) inquire ( file = tmpname , exist = test_passed ( 2 )) test_passed ( 2 ) = . not . test_passed ( 2 ) tmpname = astring % tempname ( path = './' ) inquire ( file = tmpname , exist = test_passed ( 3 )) test_passed ( 3 ) = . not . test_passed ( 3 ) astring = 'me-' tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 4 )) test_passed ( 4 ) = . not . test_passed ( 4 ) tmpname = astring % tempname ( prefix = 'you-' ) inquire ( file = tmpname , exist = test_passed ( 5 )) test_passed ( 5 ) = . not . test_passed ( 5 ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: is_file True if tempname should be used for file (the default). character, intent(in), optional :: prefix Name prefix, otherwise self is used (if allocated). character, intent(in), optional :: path Path where file/directory should be used, default ./ . Return Value character(len=:),allocatable Safe (unique) temporary name. Contents Source Code tempname Source Code function tempname ( self , is_file , prefix , path ) !< Return a safe temporary name suitable for temporary file or directories. !< !<```fortran !< type(string) :: astring !< character(len=:), allocatable :: tmpname !< logical                       :: test_passed(5) !< tmpname = astring%tempname() !< inquire(file=tmpname, exist=test_passed(1)) !< test_passed(1) = .not.test_passed(1) !< tmpname = astring%tempname(is_file=.false.) !< inquire(file=tmpname, exist=test_passed(2)) !< test_passed(2) = .not.test_passed(2) !< tmpname = astring%tempname(path='./') !< inquire(file=tmpname, exist=test_passed(3)) !< test_passed(3) = .not.test_passed(3) !< astring = 'me-' !< tmpname = astring%tempname() !< inquire(file=tmpname, exist=test_passed(4)) !< test_passed(4) = .not.test_passed(4) !< tmpname = astring%tempname(prefix='you-') !< inquire(file=tmpname, exist=test_passed(5)) !< test_passed(5) = .not.test_passed(5) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: is_file !< True if tempname should be used for file (the default). character ( * ), intent ( in ), optional :: prefix !< Name prefix, otherwise self is used (if allocated). character ( * ), intent ( in ), optional :: path !< Path where file/directory should be used, default `./`. character ( len = :), allocatable :: tempname !< Safe (unique) temporary name. logical :: is_file_ !< True if tempname should be used for file (the default). character ( len = :), allocatable :: prefix_ !< Name prefix, otherwise self is used (if allocated). character ( len = :), allocatable :: path_ !< Path where file/directory should be used, default `./`. logical , save :: is_initialized = . false . !< Status of random seed initialization. real ( R4P ) :: random_real !< Random number (real). integer ( I4P ) :: random_integer !< Random number (integer). logical :: is_hold !< Flag to check if a safe tempname has been found. is_file_ = . true . ; if ( present ( is_file )) is_file_ = is_file path_ = '' ; if ( present ( path )) path_ = path prefix_ = '' if ( present ( prefix )) then prefix_ = prefix elseif ( allocated ( self % raw )) then prefix_ = self % raw endif if (. not . is_initialized ) then call random_seed is_initialized = . true . endif tempname = repeat ( ' ' , len ( path_ ) + len ( prefix_ ) + 10 ) ! [path_] + [prefix_] + 6 random chars + [.tmp] do call random_number ( random_real ) random_integer = transfer ( random_real , random_integer ) random_integer = iand ( random_integer , 16777215_I4P ) if ( is_file_ ) then write ( tempname , '(A,Z6.6,A)' ) path_ // prefix_ , random_integer , '.tmp' else write ( tempname , '(A,Z6.6)' ) path_ // prefix_ , random_integer tempname = trim ( tempname ) endif inquire ( file = tempname , exist = is_hold ) if (. not . is_hold ) exit enddo endfunction tempname","tags":"","loc":"proc/tempname.html"},{"title":"to_integer_I1P – StringiFor","text":"private elemental function to_integer_I1P(self, kind) result(to_number) Cast string to integer (I1P). use penf type ( string ) :: astring integer ( I1P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I1P ) test_passed ( 1 ) = integer_ == 127_I1P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Contents Source Code to_integer_I1P Source Code elemental function to_integer_I1P ( self , kind ) result ( to_number ) !< Cast string to integer (I1P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I1P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I1P) !< test_passed(1) = integer_==127_I1P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I1P","tags":"","loc":"proc/to_integer_i1p.html"},{"title":"to_integer_I2P – StringiFor","text":"private elemental function to_integer_I2P(self, kind) result(to_number) Cast string to integer (I2P). use penf type ( string ) :: astring integer ( I2P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I2P ) test_passed ( 1 ) = integer_ == 127_I2P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Contents Source Code to_integer_I2P Source Code elemental function to_integer_I2P ( self , kind ) result ( to_number ) !< Cast string to integer (I2P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I2P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I2P) !< test_passed(1) = integer_==127_I2P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I2P","tags":"","loc":"proc/to_integer_i2p.html"},{"title":"to_integer_I4P – StringiFor","text":"private elemental function to_integer_I4P(self, kind) result(to_number) Cast string to integer (I4P). use penf type ( string ) :: astring integer ( I4P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I4P ) test_passed ( 1 ) = integer_ == 127_I4P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Contents Source Code to_integer_I4P Source Code elemental function to_integer_I4P ( self , kind ) result ( to_number ) !< Cast string to integer (I4P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I4P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I4P) !< test_passed(1) = integer_==127_I4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I4P","tags":"","loc":"proc/to_integer_i4p.html"},{"title":"to_integer_I8P – StringiFor","text":"private elemental function to_integer_I8P(self, kind) result(to_number) Cast string to integer (I8P). use penf type ( string ) :: astring integer ( I8P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I8P ) test_passed ( 1 ) = integer_ == 127_I8P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Contents Source Code to_integer_I8P Source Code elemental function to_integer_I8P ( self , kind ) result ( to_number ) !< Cast string to integer (I8P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I8P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I8P) !< test_passed(1) = integer_==127_I8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I8P","tags":"","loc":"proc/to_integer_i8p.html"},{"title":"to_real_R4P – StringiFor","text":"private elemental function to_real_R4P(self, kind) result(to_number) Cast string to real (R4P). use penf type ( string ) :: astring real ( R4P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R4P ) test_passed ( 1 ) = real_ == 3.4e9_R4P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Contents Source Code to_real_R4P Source Code elemental function to_real_R4P ( self , kind ) result ( to_number ) !< Cast string to real (R4P). !< !<```fortran !< use penf !< type(string) :: astring !< real(R4P)    :: real_ !< logical      :: test_passed(1) !< astring = '3.4e9' !< real_ = astring%to_number(kind=1._R4P) !< test_passed(1) = real_==3.4e9_R4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R4P","tags":"","loc":"proc/to_real_r4p.html"},{"title":"to_real_R8P – StringiFor","text":"private elemental function to_real_R8P(self, kind) result(to_number) Cast string to real (R8P). use penf type ( string ) :: astring real ( R8P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R8P ) test_passed ( 1 ) = real_ == 3.4e9_R8P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Contents Source Code to_real_R8P Source Code elemental function to_real_R8P ( self , kind ) result ( to_number ) !< Cast string to real (R8P). !< !<```fortran !< use penf !< type(string) :: astring !< real(R8P)    :: real_ !< logical      :: test_passed(1) !< astring = '3.4e9' !< real_ = astring%to_number(kind=1._R8P) !< test_passed(1) = real_==3.4e9_R8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R8P","tags":"","loc":"proc/to_real_r8p.html"},{"title":"to_real_R16P – StringiFor","text":"private elemental function to_real_R16P(self, kind) result(to_number) Cast string to real (R16P). use penf type ( string ) :: astring real ( R16P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R16P ) test_passed ( 1 ) = real_ == 3.4e9_R16P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Contents Source Code to_real_R16P Source Code elemental function to_real_R16P ( self , kind ) result ( to_number ) !< Cast string to real (R16P). !< !<```fortran !< use penf !< type(string) :: astring !< real(R16P)   :: real_ !< logical      :: test_passed(1) !< astring = '3.4e9' !< real_ = astring%to_number(kind=1._R16P) !< test_passed(1) = real_==3.4e9_R16P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R16P","tags":"","loc":"proc/to_real_r16p.html"},{"title":"unescape – StringiFor","text":"private elemental function unescape(self, to_unescape, unesc) result(unescaped) Unescape double backslashes (or custom escaped character). type ( string ) :: astring logical :: test_passed ( 2 ) astring = '&#94;\\\\s \\\\d+\\\\s*' test_passed ( 1 ) = ( astring % unescape ( to_unescape = '\\')//''==' &#94;\\ s \\ d + \\ s * ') test_passed(2) = (astring%unescape(to_unescape=' s ')//''==' &#94;\\ s \\\\ d + \\ s * ') print ' ( L1 ) ' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK,len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. Contents Source Code unescape Source Code elemental function unescape ( self , to_unescape , unesc ) result ( unescaped ) !< Unescape double backslashes (or custom escaped character). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '&#94;\\\\s \\\\d+\\\\s*' !< test_passed(1) = (astring%unescape(to_unescape='\\')//''=='&#94;\\s \\d+\\s*') !< test_passed(2) = (astring%unescape(to_unescape='s')//''=='&#94;\\s \\\\d+\\s*') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_unescape !< Character to be unescaped. character ( kind = CK , len =* ), intent ( in ), optional :: unesc !< Character used to unescape. type ( string ) :: unescaped !< Escaped string. character ( kind = CK , len = :), allocatable :: unesc_ !< Character to unescape, local variable. integer :: c !< Character counter. if ( allocated ( self % raw )) then unesc_ = '' ; if ( present ( unesc )) unesc_ = unesc unescaped % raw = '' c = 1 do if ( c > len ( self % raw )) exit if ( c == len ( self % raw )) then unescaped % raw = unescaped % raw // self % raw ( c : c ) exit else if ( self % raw ( c : c + 1 ) == BACKSLASH // to_unescape ) then unescaped % raw = unescaped % raw // to_unescape c = c + 2 else unescaped % raw = unescaped % raw // self % raw ( c : c ) c = c + 1 endif endif enddo endif endfunction unescape","tags":"","loc":"proc/unescape.html"},{"title":"unique – StringiFor","text":"private elemental function unique(self, substring) result(uniq) Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. For example the string ‘ ab-cre-cre-ab’ is reduce to ‘ab-cre-ab’ if the substring is ‘-cre’. Note Eventual multiple trailing white space are not reduced to one occurrence. type ( string ) :: astring logical :: test_passed ( 1 ) astring = '+++ab-++cre-++cre-ab+++++' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Contents Source Code unique Source Code elemental function unique ( self , substring ) result ( uniq ) !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = '+++ab-++cre-++cre-ab+++++' !< test_passed(1) = astring%unique(substring='+')//''=='+ab-+cre-+cre-ab+' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. #ifdef _NVF character ( 9999 ) :: nvf_bug !< Work around for NVFortran bug. #endif if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do #ifdef _NVF nvf_bug = substring_ if (. not . uniq % index ( repeat ( trim ( nvf_bug ), 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( trim ( nvf_bug ), 2 ), new = substring_ ) #else if (. not . uniq % index ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) #endif enddo endif endfunction unique","tags":"","loc":"proc/unique.html"},{"title":"upper – StringiFor","text":"private elemental function upper(self) Return a string with all uppercase characters. type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Contents Source Code upper Source Code elemental function upper ( self ) !< Return a string with all uppercase characters. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%upper()//''=='HELLO WORLD!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif endfunction upper","tags":"","loc":"proc/upper.html"},{"title":"end_with – StringiFor","text":"private elemental function end_with(self, suffix, start, end, ignore_null_eof) Return true if a string ends with a specified suffix. type ( string ) :: astring logical :: test_passed ( 5 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . test_passed ( 2 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . test_passed ( 3 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . test_passed ( 4 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . test_passed ( 5 ) = astring % end_with ( suffix = '!' ). eqv .. true . print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. logical, intent(in), optional :: ignore_null_eof Ignore null character at the end of file. Return Value logical Result of the test. Contents Source Code end_with Source Code elemental function end_with ( self , suffix , start , end , ignore_null_eof ) !< Return true if a string ends with a specified suffix. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(5) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%end_with(suffix='LD!').eqv..true. !< test_passed(2) = astring%end_with(suffix='lD!').eqv..false. !< test_passed(3) = astring%end_with(suffix='orLD!', start=5).eqv..true. !< test_passed(4) = astring%end_with(suffix='orLD!', start=8, end=12).eqv..true. !< test_passed(5) = astring%end_with(suffix='!').eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical , intent ( in ), optional :: ignore_null_eof !< Ignore null character at the end of file. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. logical :: ignore_null_eof_ !< Ignore null character at the end of file, local variable. end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end ignore_null_eof_ = . false . ; if ( present ( ignore_null_eof )) ignore_null_eof_ = ignore_null_eof if ( ignore_null_eof_ . and .( self % raw ( end_ : end_ ) == char ( 0 ))) end_ = end_ - 1 if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = self % raw ( end_ - len ( suffix ) + 1 : end_ ) == suffix endif endif endfunction end_with","tags":"","loc":"proc/end_with.html"},{"title":"is_allocated – StringiFor","text":"private elemental function is_allocated(self) Return true if the string is allocated. type ( string ) :: astring logical :: test_passed ( 2 ) test_passed ( 1 ) = astring % is_allocated (). eqv .. false . astring = 'hello' test_passed ( 2 ) = astring % is_allocated (). eqv .. true . print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Contents Source Code is_allocated Source Code elemental function is_allocated ( self ) !< Return true if the string is allocated. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< test_passed(1) = astring%is_allocated().eqv..false. !< astring = 'hello' !< test_passed(2) = astring%is_allocated().eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. is_allocated = allocated ( self % raw ) endfunction is_allocated","tags":"","loc":"proc/is_allocated.html"},{"title":"is_digit – StringiFor","text":"private elemental function is_digit(self) Return true if all characters in the string are digits. type ( string ) :: astring logical :: test_passed ( 2 ) astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Contents Source Code is_digit Source Code elemental function is_digit ( self ) !< Return true if all characters in the string are digits. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '   -1212112.3 ' !< test_passed(1) = astring%is_digit().eqv..false. !< astring = '12121123' !< test_passed(2) = astring%is_digit().eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif endfunction is_digit","tags":"","loc":"proc/is_digit.html"},{"title":"is_integer – StringiFor","text":"private elemental function is_integer(self, allow_spaces) Return true if the string contains an integer. The regular expression is \\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s* . The parse algorithm is done in stages: S0 S1 S2 S3 S4 S5 S6 \\s* [\\+\\-]? \\d+ [eE] \\+? \\d+ \\s* Exit on stages-parsing results in: S0 S1 S2 S3 S4 S5 S6 F F T F F T T Note This implementation is courtesy of tomedunn type ( string ) :: astring logical :: test_passed ( 6 ) astring = '   -1212112 ' test_passed ( 1 ) = astring % is_integer (). eqv .. true . astring = '   -1212112' test_passed ( 2 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . astring = '-1212112   ' test_passed ( 3 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . astring = '+2e20' test_passed ( 4 ) = astring % is_integer (). eqv .. true . astring = ' -2E13 ' test_passed ( 5 ) = astring % is_integer (). eqv .. true . astring = ' -2 E13 ' test_passed ( 6 ) = astring % is_integer (). eqv .. false . print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Contents Source Code is_integer Source Code elemental function is_integer ( self , allow_spaces ) !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(6) !< astring = '   -1212112 ' !< test_passed(1) = astring%is_integer().eqv..true. !< astring = '   -1212112' !< test_passed(2) = astring%is_integer(allow_spaces=.false.).eqv..false. !< astring = '-1212112   ' !< test_passed(3) = astring%is_integer(allow_spaces=.false.).eqv..false. !< astring = '+2e20' !< test_passed(4) = astring%is_integer().eqv..true. !< astring = ' -2E13 ' !< test_passed(5) = astring%is_integer().eqv..true. !< astring = ' -2 E13 ' !< test_passed(6) = astring%is_integer().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif endfunction is_integer","tags":"","loc":"proc/is_integer.html"},{"title":"is_lower – StringiFor","text":"private elemental function is_lower(self) Return true if all characters in the string are lowercase. type ( string ) :: astring logical :: test_passed ( 3 ) astring = ' Hello World' test_passed ( 1 ) = astring % is_lower (). eqv .. false . astring = ' HELLO WORLD' test_passed ( 2 ) = astring % is_lower (). eqv .. false . astring = ' hello world' test_passed ( 3 ) = astring % is_lower (). eqv .. true . print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Contents Source Code is_lower Source Code elemental function is_lower ( self ) !< Return true if all characters in the string are lowercase. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(3) !< astring = ' Hello World' !< test_passed(1) = astring%is_lower().eqv..false. !< astring = ' HELLO WORLD' !< test_passed(2) = astring%is_lower().eqv..false. !< astring = ' hello world' !< test_passed(3) = astring%is_lower().eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif endfunction is_lower","tags":"","loc":"proc/is_lower.html"},{"title":"is_number – StringiFor","text":"private elemental function is_number(self, allow_spaces) Return true if the string contains a number (real or integer). type ( string ) :: astring logical :: test_passed ( 7 ) astring = '   -1212112 ' test_passed ( 1 ) = astring % is_number (). eqv .. true . astring = '   -121.2112 ' test_passed ( 2 ) = astring % is_number (). eqv .. true . astring = '   -1212112' test_passed ( 3 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . astring = '-12121.12   ' test_passed ( 4 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . astring = '+2e20' test_passed ( 5 ) = astring % is_number (). eqv .. true . astring = ' -2.4E13 ' test_passed ( 6 ) = astring % is_number (). eqv .. true . astring = ' -2 E13 ' test_passed ( 7 ) = astring % is_number (). eqv .. false . print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Contents Source Code is_number Source Code elemental function is_number ( self , allow_spaces ) !< Return true if the string contains a number (real or integer). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(7) !< astring = '   -1212112 ' !< test_passed(1) = astring%is_number().eqv..true. !< astring = '   -121.2112 ' !< test_passed(2) = astring%is_number().eqv..true. !< astring = '   -1212112' !< test_passed(3) = astring%is_number(allow_spaces=.false.).eqv..false. !< astring = '-12121.12   ' !< test_passed(4) = astring%is_number(allow_spaces=.false.).eqv..false. !< astring = '+2e20' !< test_passed(5) = astring%is_number().eqv..true. !< astring = ' -2.4E13 ' !< test_passed(6) = astring%is_number().eqv..true. !< astring = ' -2 E13 ' !< test_passed(7) = astring%is_number().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) endfunction is_number","tags":"","loc":"proc/is_number.html"},{"title":"is_real – StringiFor","text":"private elemental function is_real(self, allow_spaces) Return true if the string contains a real. The regular expression is \\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s* . The parse algorithm is done in stages: S0 S1 S2 S3 S4 S5 S6 S7 S8 \\s* [\\+\\-]? \\d* \\.? \\d* [deDE] [\\+\\-]? \\d* \\s* Exit on stages-parsing results in: S0 S1 S2 S3 S4 S5 S6 S7 S8 Note This implementation is courtesy of tomedunn type ( string ) :: astring logical :: test_passed ( 6 ) astring = '   -1212112.d0 ' test_passed ( 1 ) = astring % is_real (). eqv .. true . astring = '   -1212112.d0' test_passed ( 2 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . astring = '-1212112.d0   ' test_passed ( 3 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . astring = '+2.e20' test_passed ( 4 ) = astring % is_real (). eqv .. true . astring = ' -2.01E13 ' test_passed ( 5 ) = astring % is_real (). eqv .. true . astring = ' -2.01 E13 ' test_passed ( 6 ) = astring % is_real (). eqv .. false . print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Contents Source Code is_real Source Code elemental function is_real ( self , allow_spaces ) !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(6) !< astring = '   -1212112.d0 ' !< test_passed(1) = astring%is_real().eqv..true. !< astring = '   -1212112.d0' !< test_passed(2) = astring%is_real(allow_spaces=.false.).eqv..false. !< astring = '-1212112.d0   ' !< test_passed(3) = astring%is_real(allow_spaces=.false.).eqv..false. !< astring = '+2.e20' !< test_passed(4) = astring%is_real().eqv..true. !< astring = ' -2.01E13 ' !< test_passed(5) = astring%is_real().eqv..true. !< astring = ' -2.01 E13 ' !< test_passed(6) = astring%is_real().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif endfunction is_real","tags":"","loc":"proc/is_real.html"},{"title":"is_upper – StringiFor","text":"private elemental function is_upper(self) Return true if all characters in the string are uppercase. type ( string ) :: astring logical :: test_passed ( 3 ) astring = ' Hello World' test_passed ( 1 ) = astring % is_upper (). eqv .. false . astring = ' HELLO WORLD' test_passed ( 2 ) = astring % is_upper (). eqv .. true . astring = ' hello world' test_passed ( 3 ) = astring % is_upper (). eqv .. false . print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Contents Source Code is_upper Source Code elemental function is_upper ( self ) !< Return true if all characters in the string are uppercase. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(3) !< astring = ' Hello World' !< test_passed(1) = astring%is_upper().eqv..false. !< astring = ' HELLO WORLD' !< test_passed(2) = astring%is_upper().eqv..true. !< astring = ' hello world' !< test_passed(3) = astring%is_upper().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif endfunction is_upper","tags":"","loc":"proc/is_upper.html"},{"title":"start_with – StringiFor","text":"private elemental function start_with(self, prefix, start, end) Return true if a string starts with a specified prefix. type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Contents Source Code start_with Source Code elemental function start_with ( self , prefix , start , end ) !< Return true if a string starts with a specified prefix. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%start_with(prefix='Hello').eqv..true. !< test_passed(2) = astring%start_with(prefix='hell').eqv..false. !< test_passed(3) = astring%start_with(prefix='llo Wor', start=3).eqv..true. !< test_passed(4) = astring%start_with(prefix='lo W', start=4, end=7).eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif endfunction start_with","tags":"","loc":"proc/start_with.html"},{"title":"string_concat_string – StringiFor","text":"private pure function string_concat_string(lhs, rhs) result(concat) Concatenation with string. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 1 ) astring = 'Hello ' anotherstring = 'Bye bye' test_passed ( 1 ) = astring // anotherstring == 'Hello Bye bye' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),allocatable Concatenated string. Contents Source Code string_concat_string Source Code pure function string_concat_string ( lhs , rhs ) result ( concat ) !< Concatenation with string. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(1) !< astring = 'Hello ' !< anotherstring = 'Bye bye' !< test_passed(1) = astring//anotherstring=='Hello Bye bye' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw endfunction string_concat_string","tags":"","loc":"proc/string_concat_string.html"},{"title":"string_concat_character – StringiFor","text":"private pure function string_concat_character(lhs, rhs) result(concat) Concatenation with character. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' test_passed ( 1 ) = astring // acharacter == 'Hello World!' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),allocatable Concatenated string. Contents Source Code string_concat_character Source Code pure function string_concat_character ( lhs , rhs ) result ( concat ) !< Concatenation with character. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< test_passed(1) = astring//acharacter=='Hello World!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif endfunction string_concat_character","tags":"","loc":"proc/string_concat_character.html"},{"title":"character_concat_string – StringiFor","text":"private pure function character_concat_string(lhs, rhs) result(concat) Concatenation with character (inverted). type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' test_passed ( 1 ) = acharacter // astring == 'World!Hello ' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),allocatable Concatenated string. Contents Source Code character_concat_string Source Code pure function character_concat_string ( lhs , rhs ) result ( concat ) !< Concatenation with character (inverted). !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< test_passed(1) = acharacter//astring=='World!Hello ' !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif endfunction character_concat_string","tags":"","loc":"proc/character_concat_string.html"},{"title":"string_concat_string_string – StringiFor","text":"private elemental function string_concat_string_string(lhs, rhs) result(concat) Concatenation with string. type ( string ) :: astring type ( string ) :: anotherstring type ( string ) :: yetanotherstring logical :: test_passed ( 1 ) astring = 'Hello ' anotherstring = 'Bye bye' yetanotherstring = astring . cat . anotherstring test_passed ( 1 ) = yetanotherstring % chars () == 'Hello Bye bye' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Contents Source Code string_concat_string_string Source Code elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !< Concatenation with string. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< type(string) :: yetanotherstring !< logical      :: test_passed(1) !< astring = 'Hello ' !< anotherstring = 'Bye bye' !< yetanotherstring = astring.cat.anotherstring !< test_passed(1) = yetanotherstring%chars()=='Hello Bye bye' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary endfunction string_concat_string_string","tags":"","loc":"proc/string_concat_string_string.html"},{"title":"string_concat_character_string – StringiFor","text":"private elemental function string_concat_character_string(lhs, rhs) result(concat) Concatenation with character. type ( string ) :: astring type ( string ) :: yetanotherstring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' yetanotherstring = astring . cat . acharacter test_passed ( 1 ) = yetanotherstring % chars () == 'Hello World!' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Contents Source Code string_concat_character_string Source Code elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !< Concatenation with character. !< !<```fortran !< type(string)                  :: astring !< type(string)                  :: yetanotherstring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< yetanotherstring = astring.cat.acharacter !< test_passed(1) = yetanotherstring%chars()=='Hello World!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif endfunction string_concat_character_string","tags":"","loc":"proc/string_concat_character_string.html"},{"title":"character_concat_string_string – StringiFor","text":"private elemental function character_concat_string_string(lhs, rhs) result(concat) Concatenation with character (inverted). type ( string ) :: astring type ( string ) :: yetanotherstring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' yetanotherstring = acharacter . cat . astring test_passed ( 1 ) = yetanotherstring % chars () == 'World!Hello ' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Contents Source Code character_concat_string_string Source Code elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !< Concatenation with character (inverted). !< !<```fortran !< type(string)                  :: astring !< type(string)                  :: yetanotherstring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< yetanotherstring = acharacter.cat.astring !< test_passed(1) = yetanotherstring%chars()=='World!Hello ' !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif endfunction character_concat_string_string","tags":"","loc":"proc/character_concat_string_string.html"},{"title":"string_eq_string – StringiFor","text":"private elemental function string_eq_string(lhs, rhs) result(is_it) Equal to string logical operator. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = '  one ' anotherstring = 'two' test_passed ( 1 ) = (( astring == anotherstring ). eqv .. false .) astring = 'the same ' anotherstring = 'the same ' test_passed ( 2 ) = (( astring == anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code string_eq_string Source Code elemental function string_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = '  one ' !< anotherstring = 'two' !< test_passed(1) = ((astring==anotherstring).eqv..false.) !< astring = 'the same ' !< anotherstring = 'the same ' !< test_passed(2) = ((astring==anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw == rhs % raw endfunction string_eq_string","tags":"","loc":"proc/string_eq_string.html"},{"title":"string_eq_character – StringiFor","text":"private elemental function string_eq_character(lhs, rhs) result(is_it) Equal to character logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( astring == acharacter ). eqv .. false .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( astring == acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code string_eq_character Source Code elemental function string_eq_character ( lhs , rhs ) result ( is_it ) !< Equal to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((astring==acharacter).eqv..false.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((astring==acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw == rhs endfunction string_eq_character","tags":"","loc":"proc/string_eq_character.html"},{"title":"character_eq_string – StringiFor","text":"private elemental function character_eq_string(lhs, rhs) result(is_it) Equal to character (inverted) logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( acharacter == astring ). eqv .. false .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( acharacter == astring ). eqv .. true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code character_eq_string Source Code elemental function character_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((acharacter==astring).eqv..false.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((acharacter==astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = rhs % raw == lhs endfunction character_eq_string","tags":"","loc":"proc/character_eq_string.html"},{"title":"string_ne_string – StringiFor","text":"private elemental function string_ne_string(lhs, rhs) result(is_it) Not equal to string logical operator. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = '  one ' anotherstring = 'two' test_passed ( 1 ) = (( astring /= anotherstring ). eqv .. true .) astring = 'the same ' anotherstring = 'the same ' test_passed ( 2 ) = (( astring /= anotherstring ). eqv .. false .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code string_ne_string Source Code elemental function string_ne_string ( lhs , rhs ) result ( is_it ) !< Not equal to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = '  one ' !< anotherstring = 'two' !< test_passed(1) = ((astring/=anotherstring).eqv..true.) !< astring = 'the same ' !< anotherstring = 'the same ' !< test_passed(2) = ((astring/=anotherstring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw /= rhs % raw endfunction string_ne_string","tags":"","loc":"proc/string_ne_string.html"},{"title":"string_ne_character – StringiFor","text":"private elemental function string_ne_character(lhs, rhs) result(is_it) Not equal to character logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( astring /= acharacter ). eqv .. true .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( astring /= acharacter ). eqv .. false .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code string_ne_character Source Code elemental function string_ne_character ( lhs , rhs ) result ( is_it ) !< Not equal to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((astring/=acharacter).eqv..true.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((astring/=acharacter).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw /= rhs endfunction string_ne_character","tags":"","loc":"proc/string_ne_character.html"},{"title":"character_ne_string – StringiFor","text":"private elemental function character_ne_string(lhs, rhs) result(is_it) Not equal to character (inverted) logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( acharacter /= astring ). eqv .. true .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( acharacter /= astring ). eqv .. false .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code character_ne_string Source Code elemental function character_ne_string ( lhs , rhs ) result ( is_it ) !< Not equal to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((acharacter/=astring).eqv..true.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((acharacter/=astring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = rhs % raw /= lhs endfunction character_ne_string","tags":"","loc":"proc/character_ne_string.html"},{"title":"string_lt_string – StringiFor","text":"private elemental function string_lt_string(lhs, rhs) result(is_it) Lower than to string logical operator. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring < anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring < anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code string_lt_string Source Code elemental function string_lt_string ( lhs , rhs ) result ( is_it ) !< Lower than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring<anotherstring).eqv..false.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring<anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw < rhs % raw endfunction string_lt_string","tags":"","loc":"proc/string_lt_string.html"},{"title":"string_lt_character – StringiFor","text":"private elemental function string_lt_character(lhs, rhs) result(is_it) Lower than to character logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring < acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring < acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code string_lt_character Source Code elemental function string_lt_character ( lhs , rhs ) result ( is_it ) !< Lower than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring<acharacter).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring<acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw < rhs endfunction string_lt_character","tags":"","loc":"proc/string_lt_character.html"},{"title":"character_lt_string – StringiFor","text":"private elemental function character_lt_string(lhs, rhs) result(is_it) Lower than to character (inverted) logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter < astring ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter < astring ). eqv .. false .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code character_lt_string Source Code elemental function character_lt_string ( lhs , rhs ) result ( is_it ) !< Lower than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter<astring).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter<astring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs < rhs % raw endfunction character_lt_string","tags":"","loc":"proc/character_lt_string.html"},{"title":"string_le_string – StringiFor","text":"private elemental function string_le_string(lhs, rhs) result(is_it) Lower equal than to string logical operator. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 3 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring <= anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring <= anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'ONE' test_passed ( 3 ) = (( astring <= anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code string_le_string Source Code elemental function string_le_string ( lhs , rhs ) result ( is_it ) !< Lower equal than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(3) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring<=anotherstring).eqv..false.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring<=anotherstring).eqv..true.) !< astring = 'ONE' !< anotherstring = 'ONE' !< test_passed(3) = ((astring<=anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw <= rhs % raw endfunction string_le_string","tags":"","loc":"proc/string_le_string.html"},{"title":"string_le_character – StringiFor","text":"private elemental function string_le_character(lhs, rhs) result(is_it) Lower equal than to character logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring <= acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring <= acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( astring <= acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code string_le_character Source Code elemental function string_le_character ( lhs , rhs ) result ( is_it ) !< Lower equal than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring<=acharacter).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring<=acharacter).eqv..true.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((astring<=acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw <= rhs endfunction string_le_character","tags":"","loc":"proc/string_le_character.html"},{"title":"character_le_string – StringiFor","text":"private elemental function character_le_string(lhs, rhs) result(is_it) Lower equal than to character (inverted) logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter <= astring ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter <= astring ). eqv .. false .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( acharacter <= astring ). eqv .. true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code character_le_string Source Code elemental function character_le_string ( lhs , rhs ) result ( is_it ) !< Lower equal than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter<=astring).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter<=astring).eqv..false.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((acharacter<=astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs <= rhs % raw endfunction character_le_string","tags":"","loc":"proc/character_le_string.html"},{"title":"string_ge_string – StringiFor","text":"private elemental function string_ge_string(lhs, rhs) result(is_it) Greater equal than to string logical operator. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 3 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring >= anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring >= anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'ONE' test_passed ( 3 ) = (( astring >= anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code string_ge_string Source Code elemental function string_ge_string ( lhs , rhs ) result ( is_it ) !< Greater equal than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(3) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring>=anotherstring).eqv..true.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring>=anotherstring).eqv..false.) !< astring = 'ONE' !< anotherstring = 'ONE' !< test_passed(3) = ((astring>=anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw >= rhs % raw endfunction string_ge_string","tags":"","loc":"proc/string_ge_string.html"},{"title":"string_ge_character – StringiFor","text":"private elemental function string_ge_character(lhs, rhs) result(is_it) Greater equal than to character logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring >= acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring >= acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( astring >= acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code string_ge_character Source Code elemental function string_ge_character ( lhs , rhs ) result ( is_it ) !< Greater equal than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring>=acharacter).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring>=acharacter).eqv..false.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((astring>=acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw >= rhs endfunction string_ge_character","tags":"","loc":"proc/string_ge_character.html"},{"title":"character_ge_string – StringiFor","text":"private elemental function character_ge_string(lhs, rhs) result(is_it) Greater equal than to character (inverted) logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter >= astring ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter >= astring ). eqv .. true .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( acharacter >= astring ). eqv .. true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code character_ge_string Source Code elemental function character_ge_string ( lhs , rhs ) result ( is_it ) !< Greater equal than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter>=astring).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter>=astring).eqv..true.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((acharacter>=astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs >= rhs % raw endfunction character_ge_string","tags":"","loc":"proc/character_ge_string.html"},{"title":"string_gt_string – StringiFor","text":"private elemental function string_gt_string(lhs, rhs) result(is_it) Greater than to string logical operator. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring > anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring > anotherstring ). eqv .. false .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code string_gt_string Source Code elemental function string_gt_string ( lhs , rhs ) result ( is_it ) !< Greater than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring>anotherstring).eqv..true.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring>anotherstring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw > rhs % raw endfunction string_gt_string","tags":"","loc":"proc/string_gt_string.html"},{"title":"string_gt_character – StringiFor","text":"private elemental function string_gt_character(lhs, rhs) result(is_it) Greater than to character logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring > acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring > acharacter ). eqv .. false .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code string_gt_character Source Code elemental function string_gt_character ( lhs , rhs ) result ( is_it ) !< Greater than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring>acharacter).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring>acharacter).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw > rhs endfunction string_gt_character","tags":"","loc":"proc/string_gt_character.html"},{"title":"character_gt_string – StringiFor","text":"private elemental function character_gt_string(lhs, rhs) result(is_it) Greater than to character (inverted) logical operator. type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter > astring ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter > astring ). eqv .. true .) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Contents Source Code character_gt_string Source Code elemental function character_gt_string ( lhs , rhs ) result ( is_it ) !< Greater than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter>astring).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter>astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs > rhs % raw endfunction character_gt_string","tags":"","loc":"proc/character_gt_string.html"},{"title":"replace_one_occurrence – StringiFor","text":"private elemental function replace_one_occurrence(self, old, new) result(replaced) Return a string with the first occurrence of substring old replaced by new. Note The doctest is not necessary, this being tested by replace . Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Contents Source Code replace_one_occurrence Source Code elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !< Return a string with the first occurrence of substring old replaced by new. !< !< @note The doctest is not necessary, this being tested by [[string:replace]]. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif endif endif endfunction replace_one_occurrence","tags":"","loc":"proc/replace_one_occurrence.html"},{"title":"free – StringiFor","text":"private elemental subroutine free(self) Free dynamic memory. type ( string ) :: astring astring = 'this is string example....wow!!!' call astring % free print '(L1)' , astring % is_allocated (). eqv .. false . Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Contents Source Code free Source Code elemental subroutine free ( self ) !< Free dynamic memory. !< !<```fortran !< type(string) :: astring !< astring = 'this is string example....wow!!!' !< call astring%free !< print '(L1)', astring%is_allocated().eqv..false. !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. if ( allocated ( self % raw )) deallocate ( self % raw ) endsubroutine free","tags":"","loc":"proc/free.html"},{"title":"glob_character – StringiFor","text":"private subroutine glob_character(self, pattern, list) Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Note Method not portable: works only on Unix/GNU Linux OS. type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_chr ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr print '(L1)' , test_passed Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: pattern Given pattern. character(len=:), intent(out), allocatable :: list (:) List of matching pathnames. Called by proc~~glob_character~~CalledByGraph proc~glob_character glob_character interface~glob glob interface~glob->proc~glob_character program~volatile_doctest~53 volatile_doctest program~volatile_doctest~53->interface~glob Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code glob_character Source Code subroutine glob_character ( self , pattern , list ) !< Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. !< !< @note Method not portable: works only on Unix/GNU Linux OS. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: alist_chr(:) !< integer, parameter            :: Nf=5 !< character(14)                 :: files(1:Nf) !< integer                       :: file_unit !< integer                       :: f !< integer                       :: ff !< logical                       :: test_passed !< do f=1, Nf !<    files(f) = astring%tempname(prefix='foo-') !<    open(newunit=file_unit, file=files(f)) !<    write(file_unit, *)f !<    close(unit=file_unit) !< enddo !< call astring%glob(pattern='foo-*', list=alist_chr) !< do f=1, Nf !<    open(newunit=file_unit, file=files(f)) !<    close(unit=file_unit, status='delete') !< enddo !< test_passed = .false. !< outer_chr: do f=1, size(alist_chr, dim=1) !<    do ff=1, Nf !<       test_passed = alist_chr(f) == files(ff) !<       if (test_passed) cycle outer_chr !<    enddo !< enddo outer_chr !< print '(L1)', test_passed !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: pattern !< Given pattern. character ( len = :), allocatable , intent ( out ) :: list (:) !< List of matching pathnames. type ( string ), allocatable :: list_ (:) !< List of matching pathnames. integer ( I4P ) :: max_len !< Maximum length. integer ( I4P ) :: matches_number !< Matches number. integer ( I4P ) :: m !< Counter. call self % glob ( pattern = pattern , list = list_ ) if ( allocated ( list_ )) then matches_number = size ( list_ , dim = 1 ) max_len = 0 do m = 1 , matches_number max_len = max ( max_len , list_ ( m )% len ()) enddo allocate ( character ( max_len ) :: list ( 1 : matches_number )) do m = 1 , matches_number list ( m ) = list_ ( m )% chars () enddo endif endsubroutine glob_character","tags":"","loc":"proc/glob_character.html"},{"title":"glob_string – StringiFor","text":"private subroutine glob_string(self, pattern, list) Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Note Method not portable: works only on Unix/GNU Linux OS. type ( string ) :: astring type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str print '(L1)' , test_passed Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: pattern Given pattern. type( string ), intent(out), allocatable :: list (:) List of matching pathnames. Called by proc~~glob_string~~CalledByGraph proc~glob_string glob_string interface~glob glob interface~glob->proc~glob_string program~volatile_doctest~53 volatile_doctest program~volatile_doctest~53->interface~glob Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code glob_string Source Code subroutine glob_string ( self , pattern , list ) !< Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. !< !< @note Method not portable: works only on Unix/GNU Linux OS. !< !<```fortran !< type(string)                  :: astring !< type(string),     allocatable :: alist_str(:) !< integer, parameter            :: Nf=5 !< character(14)                 :: files(1:Nf) !< integer                       :: file_unit !< integer                       :: f !< integer                       :: ff !< logical                       :: test_passed !< !< do f=1, Nf !<    files(f) = astring%tempname(prefix='foo-') !<    open(newunit=file_unit, file=files(f)) !<    write(file_unit, *)f !<    close(unit=file_unit) !< enddo !< call astring%glob(pattern='foo-*', list=alist_str) !< do f=1, Nf !<    open(newunit=file_unit, file=files(f)) !<    close(unit=file_unit, status='delete') !< enddo !< test_passed = .false. !< outer_str: do f=1, size(alist_str, dim=1) !<    do ff=1, Nf !<       test_passed = alist_str(f) == files(ff) !<       if (test_passed) cycle outer_str !<    enddo !< enddo outer_str !< print '(L1)', test_passed !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: pattern !< Given pattern. type ( string ), allocatable , intent ( out ) :: list (:) !< List of matching pathnames. type ( string ) :: tempfile !< Safe temporary file. character ( len = :), allocatable :: tempname !< Safe temporary name. integer ( I4P ) :: tempunit !< Unit of temporary file. tempname = self % tempname () call execute_command_line ( 'ls -1 ' // trim ( adjustl ( pattern )) // ' > ' // tempname ) call tempfile % read_file ( file = tempname ) call tempfile % split ( sep = new_line ( 'a' ), tokens = list ) open ( newunit = tempunit , file = tempname ) close ( unit = tempunit , status = 'delete' ) endsubroutine glob_string","tags":"","loc":"proc/glob_string.html"},{"title":"read_file – StringiFor","text":"private subroutine read_file(self, file, is_fast, form, iostat, iomsg) Read a file as a single string stream. Note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a new_line character. Note For unformatted read only access='stream' is supported with new_line as line terminator. Note Fast file reading allows a very efficient reading of streamed file, but it dumps file as single streamed string. type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 9 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) call astring % read_file ( file = 'read_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat ) test_passed ( 9 ) = ( iostat /= 0 ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. logical, intent(in), optional :: is_fast Flag to enable (super) fast file reading. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Contents Source Code read_file Source Code subroutine read_file ( self , file , is_fast , form , iostat , iomsg ) !< Read a file as a single string stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !< @note *Fast* file reading allows a very efficient reading of streamed file, but it dumps file as single streamed string. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(9) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, file='read_file_test.tmp') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< close(scratch) !< call astring%read_file(file='read_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< close(scratch) !< call astring%read_file(file='read_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< close(scratch, status='DELETE') !< call astring%read_file(file='read_file_test.tmp', iostat=iostat) !< test_passed(9) = (iostat/=0) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. logical , intent ( in ), optional :: is_fast !< Flag to enable (super) fast file reading. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. logical :: is_fast_ !< Flag to enable (super) fast file reading, local variable. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. integer ( I4P ) :: filesize !< Size of the file for fast reading. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then is_fast_ = . false . ; if ( present ( is_fast )) is_fast_ = is_fast if ( is_fast_ ) then open ( newunit = unit , file = file , access = 'STREAM' , form = 'UNFORMATTED' , iomsg = iomsg_ , iostat = iostat_ ) inquire ( file = file , size = filesize ) if ( allocated ( self % raw )) deallocate ( self % raw ) allocate ( character ( len = filesize ) :: self % raw ) read ( unit = unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw close ( unit ) else form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % read_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif else iostat_ = 1 iomsg_ = 'file not found' endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_file","tags":"","loc":"proc/read_file~2.html"},{"title":"read_line – StringiFor","text":"private subroutine read_line(self, unit, form, iostat, iomsg) Read line (record) from a connected unit. The line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. type ( string ) :: astring type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 6 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then exit else test_passed ( l ) = ( astring == line ( l )) endif enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg , form = 'UnfORMatteD' ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then exit else test_passed ( l + 3 ) = ( astring == line ( l )) endif enddo close ( scratch ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Contents Source Code read_line Source Code subroutine read_line ( self , unit , form , iostat , iomsg ) !< Read line (record) from a connected unit. !< !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)      :: astring !< type(string)      :: line(3) !< integer           :: iostat !< character(len=99) :: iomsg !< integer           :: scratch !< integer           :: l !< logical           :: test_passed(6) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, status='SCRATCH') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< rewind(scratch) !< l = 0 !< iostat = 0 !< do !<   l = l + 1 !<   call astring%read_line(unit=scratch, iostat=iostat, iomsg=iomsg) !<   if (iostat/=0.and..not.is_iostat_eor(iostat)) then !<     exit !<   else !<     test_passed(l) = (astring==line(l)) !<   endif !< enddo !< close(scratch) !< open(newunit=scratch, status='SCRATCH', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< rewind(scratch) !< l = 0 !< iostat = 0 !< do !<   l = l + 1 !<   call astring%read_line(unit=scratch, iostat=iostat, iomsg=iomsg, form='UnfORMatteD') !<   if (iostat/=0.and..not.is_iostat_eor(iostat)) then !<     exit !<   else !<     test_passed(l+3) = (astring==line(l)) !<   endif !< enddo !< close(scratch) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = :), allocatable :: line !< Line storage. character ( kind = CK , len = 1 ) :: ch !< Character storage. form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg line = '' select case ( form_ % chars ()) case ( 'FORMATTED' ) do read ( unit , \"(A)\" , advance = 'no' , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 , eor = 10 ) ch line = line // ch enddo case ( 'UNFORMATTED' ) do read ( unit , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) then iostat_ = iostat_eor exit endif line = line // ch enddo endselect 10 if ( line /= '' ) self % raw = line if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_line","tags":"","loc":"proc/read_line.html"},{"title":"read_lines – StringiFor","text":"private subroutine read_lines(self, unit, form, iostat, iomsg) Read (all) lines (records) from a connected unit as a single ascii stream. Note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a new_line character. The line is read as an ascii stream read until the eor is reached. Note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. Note For unformatted read only access='stream' is supported with new_line as line terminator. type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) call astring % read_lines ( unit = scratch , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo close ( scratch ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Contents Source Code read_lines Source Code subroutine read_lines ( self , unit , form , iostat , iomsg ) !< Read (all) lines (records) from a connected unit as a single ascii stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. The line is read as an ascii stream read until the eor is reached. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, status='SCRATCH') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< call astring%read_lines(unit=scratch, iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< close(scratch) !< open(newunit=scratch, status='SCRATCH', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< call astring%read_lines(unit=scratch, form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< close(scratch) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. type ( string ) :: lines !< Lines storage. type ( string ) :: line !< Line storage. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) iostat_ = 0 lines % raw = '' do line % raw = '' call line % read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if ( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )) then exit elseif ( line /= '' ) then lines % raw = lines % raw // line % raw // new_line ( 'a' ) endif enddo if ( lines % raw /= '' ) self % raw = lines % raw if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_lines","tags":"","loc":"proc/read_lines~2.html"},{"title":"split – StringiFor","text":"private pure subroutine split(self, tokens, sep, max_tokens) Return a list of substring in the string, using sep as the delimiter string. Note Multiple subsequent separators are collapsed to one occurrence. Note If max_tokens is passed the returned number of tokens is either max_tokens or max_tokens + 1 . type ( string ) :: astring type ( string ), allocatable :: strings (:) logical :: test_passed ( 11 ) astring = '+ab-++cre-++cre-ab+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'ab-++cre-++cre-ab+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'ab-++cre-++cre-ab' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'Hello ' // new_line ( 'a' ) // 'World!' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) astring = 'Hello World!' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) astring = '+ab-' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 6 ) = ( strings ( 1 ) // '' == 'ab-' ) astring = '+ab-' call astring % split ( tokens = strings , sep = '-' ) test_passed ( 7 ) = ( strings ( 1 ) // '' == '+ab' ) astring = '+ab-+cd-' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 8 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = 'ab-+cd-+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 9 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = '+ab-+cd-+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 10 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = '1-2-3-4-5-6-7-8' call astring % split ( tokens = strings , sep = '-' , max_tokens = 3 ) test_passed ( 11 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4-5-6-7-8' ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. integer, intent(in), optional :: max_tokens Fix the maximum number of returned tokens. Contents Source Code split Source Code pure subroutine split ( self , tokens , sep , max_tokens ) !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurrence. !< !< @note If `max_tokens` is passed the returned number of tokens is either `max_tokens` or `max_tokens + 1`. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< logical                   :: test_passed(11) !< astring = '+ab-++cre-++cre-ab+' !< call astring%split(tokens=strings, sep='+') !< test_passed(1) = (strings(1)//''=='ab-'.and.strings(2)//''=='cre-'.and.strings(3)//''=='cre-ab') !< astring = 'ab-++cre-++cre-ab+' !< call astring%split(tokens=strings, sep='+') !< test_passed(2) = (strings(1)//''=='ab-'.and.strings(2)//''=='cre-'.and.strings(3)//''=='cre-ab') !< astring = 'ab-++cre-++cre-ab' !< call astring%split(tokens=strings, sep='+') !< test_passed(3) = (strings(1)//''=='ab-'.and.strings(2)//''=='cre-'.and.strings(3)//''=='cre-ab') !< astring = 'Hello '//new_line('a')//'World!' !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(4) = (strings(1)//''=='Hello '.and.strings(2)//''=='World!') !< astring = 'Hello World!' !< call astring%split(tokens=strings) !< test_passed(5) = (strings(1)//''=='Hello'.and.strings(2)//''=='World!') !< astring = '+ab-' !< call astring%split(tokens=strings, sep='+') !< test_passed(6) = (strings(1)//''=='ab-') !< astring = '+ab-' !< call astring%split(tokens=strings, sep='-') !< test_passed(7) = (strings(1)//''=='+ab') !< astring = '+ab-+cd-' !< call astring%split(tokens=strings, sep='+') !< test_passed(8) = (strings(1)//''=='ab-'.and.strings(2)//''=='cd-') !< astring = 'ab-+cd-+' !< call astring%split(tokens=strings, sep='+') !< test_passed(9) = (strings(1)//''=='ab-'.and.strings(2)//''=='cd-') !< astring = '+ab-+cd-+' !< call astring%split(tokens=strings, sep='+') !< test_passed(10) = (strings(1)//''=='ab-'.and.strings(2)//''=='cd-') !< astring = '1-2-3-4-5-6-7-8' !< call astring%split(tokens=strings, sep='-', max_tokens=3) !< test_passed(11) = (strings(1)//''=='1'.and.strings(2)//''=='2'.and.strings(3)//''=='3'.and.strings(4)//''=='4-5-6-7-8') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. integer , intent ( in ), optional :: max_tokens !< Fix the maximum number of returned tokens. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % count ( sep_ ) if ( No > 0 ) then if ( present ( max_tokens )) then if ( max_tokens < No . and . max_tokens > 0 ) No = max_tokens endif allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No - 1 tokens ( t ) = temp_toks ( 1 , t + 1 ) enddo tokens ( No ) = temp_toks ( 3 , No ) else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif else allocate ( tokens ( 1 )) tokens ( 1 ) = self endif endif endsubroutine split","tags":"","loc":"proc/split.html"},{"title":"split_chunked – StringiFor","text":"private pure subroutine split_chunked(self, tokens, chunks, sep) Return a list of substring in the string, using sep as the delimiter string, chunked (memory-efficient) algorithm. Note Multiple subsequent separators are collapsed to one occurrence. Note The split is performed in chunks of #chunks to avoid excessive memory consumption. type ( string ) :: astring type ( string ), allocatable :: strings (:) logical :: test_passed ( 1 ) astring = '-1-2-3-4-5-6-7-8-' call astring % split_chunked ( tokens = strings , sep = '-' , chunks = 3 ) test_passed ( 1 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4' . and . & strings ( 5 ) // '' == '5' . and . strings ( 6 ) // '' == '6' . and . strings ( 7 ) // '' == '7' . and . strings ( 8 ) // '' == '8' ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. integer, intent(in) :: chunks Number of chunks. character(kind=CK,len=*), intent(in), optional :: sep Separator. Contents Source Code split_chunked Source Code pure subroutine split_chunked ( self , tokens , chunks , sep ) !< Return a list of substring in the string, using sep as the delimiter string, chunked (memory-efficient) algorithm. !< !< @note Multiple subsequent separators are collapsed to one occurrence. !< !< @note The split is performed in chunks of `#chunks` to avoid excessive memory consumption. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< logical                   :: test_passed(1) !< astring = '-1-2-3-4-5-6-7-8-' !< call astring%split_chunked(tokens=strings, sep='-', chunks=3) !< test_passed(1) = (strings(1)//''=='1'.and.strings(2)//''=='2'.and.strings(3)//''=='3'.and.strings(4)//''=='4'.and. & !<                   strings(5)//''=='5'.and.strings(6)//''=='6'.and.strings(7)//''=='7'.and.strings(8)//''=='8') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. integer , intent ( in ) :: chunks !< Number of chunks. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: Nt !< Number of actual tokens. integer :: t !< Counter. logical :: isok if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep Nt = self % count ( sep_ ) if ( self % start_with ( prefix = sep_ )) Nt = Nt - 1 if ( self % end_with ( suffix = sep_ )) Nt = Nt - 1 t = 0 call self % split ( tokens = tokens , sep = sep_ , max_tokens = chunks ) do t = size ( tokens , dim = 1 ) if ( t > Nt ) exit call split_last_token ( tokens = tokens , max_tokens = chunks , isok = isok ) if ( isok ) then else exit endif enddo t = size ( tokens , dim = 1 ) if ( tokens ( t )% count ( sep_ ) > 0 ) then call split_last_token ( tokens = tokens , isok = isok ) endif endif contains pure subroutine split_last_token ( tokens , max_tokens , isok ) !< Split last token. type ( string ), allocatable , intent ( inout ) :: tokens (:) !< Tokens substring. integer , intent ( in ), optional :: max_tokens !< Max tokens returned. type ( string ), allocatable :: tokens_ (:) !< Temporary tokens. type ( string ), allocatable :: tokens_swap (:) !< Swap tokens. integer :: Nt_ !< Number of last created tokens. logical , intent ( out ) :: isok isok = . true . call tokens ( t )% split ( tokens = tokens_ , sep = sep_ , max_tokens = max_tokens ) if ( allocated ( tokens_ )) then Nt_ = size ( tokens_ , dim = 1 ) if ( Nt_ >= 1 ) then allocate ( tokens_swap ( 1 : t - 1 + Nt_ )) tokens_swap ( 1 : t - 1 ) = tokens ( 1 : t - 1 ) tokens_swap ( t :) = tokens_ (:) call move_alloc ( from = tokens_swap , to = tokens ) endif if ( Nt_ == 1 ) then isok = . false . end if deallocate ( tokens_ ) endif endsubroutine split_last_token endsubroutine split_chunked","tags":"","loc":"proc/split_chunked.html"},{"title":"write_file – StringiFor","text":"private subroutine write_file(self, file, form, iostat, iomsg) Write a single string stream into file. Note For unformatted read only access='stream' is supported with new_line as line terminator. type ( string ) :: astring type ( string ) :: anotherstring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) call anotherstring % write_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo call anotherstring % write_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( unit = scratch , status = 'delete' ) print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Contents Source Code write_file Source Code subroutine write_file ( self , file , form , iostat , iomsg ) !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string)              :: anotherstring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< anotherstring = anotherstring%join(array=line, sep=new_line('a')) !< call anotherstring%write_file(file='write_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< call anotherstring%write_file(file='write_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='write_file_test.tmp') !< close(unit=scratch, status='delete') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % write_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_file","tags":"","loc":"proc/write_file~2.html"},{"title":"write_line – StringiFor","text":"private subroutine write_line(self, unit, form, iostat, iomsg) Write line (record) to a connected unit. Note If the connected unit is unformatted a new_line() character is added at the end (if necessary) to mark the end of line. Note There is no doctests, this being tested by means of write_file doctests. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Contents Source Code write_line Source Code subroutine write_line ( self , unit , form , iostat , iomsg ) !< Write line (record) to a connected unit. !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !< !< @note There is no doctests, this being tested by means of [[string:write_file]] doctests. class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. iostat_ = 0 iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg if ( allocated ( self % raw )) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) write ( unit , \"(A)\" , iostat = iostat_ , iomsg = iomsg_ ) self % raw case ( 'UNFORMATTED' ) if ( self % end_with ( new_line ( 'a' ))) then write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw else write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw // new_line ( 'a' ) endif endselect endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_line","tags":"","loc":"proc/write_line.html"},{"title":"write_lines – StringiFor","text":"private subroutine write_lines(self, unit, form, iostat, iomsg) Write lines (records) to a connected unit. This method checks if self contains more than one line (records) and writes them as lines (records). Note If the connected unit is unformatted a new_line() character is added at the end (if necessary) to mark the end of line. Note There is no doctests, this being tested by means of write_file doctests. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Contents Source Code write_lines Source Code subroutine write_lines ( self , unit , form , iostat , iomsg ) !< Write lines (records) to a connected unit. !< !< This method checks if self contains more than one line (records) and writes them as lines (records). !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !< !< @note There is no doctests, this being tested by means of [[string:write_file]] doctests. class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ), allocatable :: lines (:) !< Lines. integer :: l !< Counter. if ( allocated ( self % raw )) then call self % split ( tokens = lines , sep = new_line ( 'a' )) do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endif endsubroutine write_lines","tags":"","loc":"proc/write_lines~2.html"},{"title":"string_assign_string – StringiFor","text":"private pure subroutine string_assign_string(lhs, rhs) Assignment operator from string input. type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 1 ) astring = 'hello' anotherstring = astring test_passed ( 1 ) = astring % chars () == anotherstring % chars () print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Contents Source Code string_assign_string Source Code pure subroutine string_assign_string ( lhs , rhs ) !< Assignment operator from string input. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(1) !< astring = 'hello' !< anotherstring = astring !< test_passed(1) = astring%chars()==anotherstring%chars() !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( rhs % raw )) lhs % raw = rhs % raw endsubroutine string_assign_string","tags":"","loc":"proc/string_assign_string.html"},{"title":"string_assign_character – StringiFor","text":"private pure subroutine string_assign_character(lhs, rhs) Assignment operator from character input. type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'hello' test_passed ( 1 ) = astring % chars () == 'hello' print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Contents Source Code string_assign_character Source Code pure subroutine string_assign_character ( lhs , rhs ) !< Assignment operator from character input. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'hello' !< test_passed(1) = astring%chars()=='hello' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. lhs % raw = rhs endsubroutine string_assign_character","tags":"","loc":"proc/string_assign_character.html"},{"title":"string_assign_integer_I1P – StringiFor","text":"private pure subroutine string_assign_integer_I1P(lhs, rhs) Assignment operator from integer input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I1P test_passed ( 1 ) = astring % to_number ( kind = 1_I1P ) == 127_I1P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_integer_i1p~~CallsGraph proc~string_assign_integer_i1p string_assign_integer_I1P str str proc~string_assign_integer_i1p->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code string_assign_integer_I1P Source Code pure subroutine string_assign_integer_I1P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I1P !< test_passed(1) = astring%to_number(kind=1_I1P)==127_I1P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I1P","tags":"","loc":"proc/string_assign_integer_i1p.html"},{"title":"string_assign_integer_I2P – StringiFor","text":"private pure subroutine string_assign_integer_I2P(lhs, rhs) Assignment operator from integer input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I2P test_passed ( 1 ) = astring % to_number ( kind = 1_I2P ) == 127_I2P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_integer_i2p~~CallsGraph proc~string_assign_integer_i2p string_assign_integer_I2P str str proc~string_assign_integer_i2p->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code string_assign_integer_I2P Source Code pure subroutine string_assign_integer_I2P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I2P !< test_passed(1) = astring%to_number(kind=1_I2P)==127_I2P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I2P","tags":"","loc":"proc/string_assign_integer_i2p.html"},{"title":"string_assign_integer_I4P – StringiFor","text":"private pure subroutine string_assign_integer_I4P(lhs, rhs) Assignment operator from integer input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I4P test_passed ( 1 ) = astring % to_number ( kind = 1_I4P ) == 127_I4P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_integer_i4p~~CallsGraph proc~string_assign_integer_i4p string_assign_integer_I4P str str proc~string_assign_integer_i4p->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code string_assign_integer_I4P Source Code pure subroutine string_assign_integer_I4P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I4P !< test_passed(1) = astring%to_number(kind=1_I4P)==127_I4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I4P","tags":"","loc":"proc/string_assign_integer_i4p.html"},{"title":"string_assign_integer_I8P – StringiFor","text":"private pure subroutine string_assign_integer_I8P(lhs, rhs) Assignment operator from integer input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I8P test_passed ( 1 ) = astring % to_number ( kind = 1_I8P ) == 127_I8P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_integer_i8p~~CallsGraph proc~string_assign_integer_i8p string_assign_integer_I8P str str proc~string_assign_integer_i8p->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code string_assign_integer_I8P Source Code pure subroutine string_assign_integer_I8P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I8P !< test_passed(1) = astring%to_number(kind=1_I8P)==127_I8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I8P","tags":"","loc":"proc/string_assign_integer_i8p.html"},{"title":"string_assign_real_R4P – StringiFor","text":"private pure subroutine string_assign_real_R4P(lhs, rhs) Assignment operator from real input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R4P test_passed ( 1 ) = astring % to_number ( kind = 1._R4P ) == 3.021e6_R4P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_real_r4p~~CallsGraph proc~string_assign_real_r4p string_assign_real_R4P str str proc~string_assign_real_r4p->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code string_assign_real_R4P Source Code pure subroutine string_assign_real_R4P ( lhs , rhs ) !< Assignment operator from real input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 3.021e6_R4P !< test_passed(1) = astring%to_number(kind=1._R4P)==3.021e6_R4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R4P","tags":"","loc":"proc/string_assign_real_r4p.html"},{"title":"string_assign_real_R8P – StringiFor","text":"private pure subroutine string_assign_real_R8P(lhs, rhs) Assignment operator from real input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R8P test_passed ( 1 ) = astring % to_number ( kind = 1._R8P ) == 3.021e6_R8P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_real_r8p~~CallsGraph proc~string_assign_real_r8p string_assign_real_R8P str str proc~string_assign_real_r8p->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code string_assign_real_R8P Source Code pure subroutine string_assign_real_R8P ( lhs , rhs ) !< Assignment operator from real input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 3.021e6_R8P !< test_passed(1) = astring%to_number(kind=1._R8P)==3.021e6_R8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R8P","tags":"","loc":"proc/string_assign_real_r8p.html"},{"title":"string_assign_real_R16P – StringiFor","text":"private pure subroutine string_assign_real_R16P(lhs, rhs) Assignment operator from real input. use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R8P test_passed ( 1 ) = astring % to_number ( kind = 1._R8P ) == 3.021e6_R8P print '(L1)' , all ( test_passed ) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Calls proc~~string_assign_real_r16p~~CallsGraph proc~string_assign_real_r16p string_assign_real_R16P str str proc~string_assign_real_r16p->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code string_assign_real_R16P Source Code pure subroutine string_assign_real_R16P ( lhs , rhs ) !< Assignment operator from real input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 3.021e6_R8P !< test_passed(1) = astring%to_number(kind=1._R8P)==3.021e6_R8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R16P","tags":"","loc":"proc/string_assign_real_r16p.html"},{"title":"read_formatted – StringiFor","text":"private subroutine read_formatted(dtv, unit, iotype, v_list, iostat, iomsg) Formatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Bug Read listdirected with and without delimiters does not work. Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Calls proc~~read_formatted~~CallsGraph proc~read_formatted read_formatted proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~read_formatted->proc~get_next_non_blank_character_any_record proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_formatted Source Code subroutine read_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !< !< @bug Read listdirected with and without delimiters does not work. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. character ( kind = CK , len = 1 ) :: delim !< String delimiter, if any. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. if ( iotype == 'LISTDIRECTED' ) then call get_next_non_blank_character_any_record ( unit = unit , ch = delim , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return if ( delim == '\"' . OR . delim == \"'\" ) then call dtv % read_delimited ( unit = unit , delim = delim , iostat = iostat , iomsg = local_iomsg ) else ! step back before the non-blank read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited_listdirected ( unit = unit , iostat = iostat , iomsg = local_iomsg ) endif if ( is_iostat_eor ( iostat )) then ! suppress IOSTAT_EOR iostat = 0 elseif ( iostat /= 0 ) then iomsg = local_iomsg endif return else read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endif endsubroutine read_formatted","tags":"","loc":"proc/read_formatted.html"},{"title":"read_delimited – StringiFor","text":"private subroutine read_delimited(dtv, unit, delim, iostat, iomsg) Read a delimited string from a unit connected for formatted input. If the closing delimiter is followed by end of record, then we return end of record. Note This does not need a doctest, it being tested by [[string::read_formatted]]. Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Contents Source Code read_delimited Source Code subroutine read_delimited ( dtv , unit , delim , iostat , iomsg ) !< Read a delimited string from a unit connected for formatted input. !< !< If the closing delimiter is followed by end of record, then we return end of record. !< !< @note This does not need a doctest, it being tested by [[string::read_formatted]]. class ( string ), intent ( out ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( in ) :: delim !< String delimiter. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. logical :: was_delim !< Indicates that the last character read was a delimiter. was_delim = . false . dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then if ( was_delim ) then ! end of delimited string followed by end of record is end of the string. Pass back the ! end of record condition to the caller return else ! end of record without terminating delimiter - move along cycle endif elseif ( iostat /= 0 ) THEN return endif if ( ch == delim ) then if ( was_delim ) then ! doubled delimiter is one delimiter in the value dtv % raw = dtv % raw // ch was_delim = . false . else ! need to test next character to see what is happening was_delim = . true . endif elseif ( was_delim ) then ! the previous character was actually the delimiter for the end of the string. Put back this character read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) return else dtv % raw = dtv % raw // ch endif enddo endsubroutine read_delimited","tags":"","loc":"proc/read_delimited.html"},{"title":"read_undelimited_listdirected – StringiFor","text":"private subroutine read_undelimited_listdirected(dtv, unit, iostat, iomsg) Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. If input is terminated by end of record, then this procedure returns an end-of-record condition. Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Calls proc~~read_undelimited_listdirected~~CallsGraph proc~read_undelimited_listdirected read_undelimited_listdirected proc~get_decimal_mode get_decimal_mode proc~read_undelimited_listdirected->proc~get_decimal_mode Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_undelimited_listdirected Source Code subroutine read_undelimited_listdirected ( dtv , unit , iostat , iomsg ) !< Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. !< !< A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. !< !< If input is terminated by end of record, then this procedure returns an end-of-record condition. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. logical :: decimal_point !<True if DECIMAL=POINT in effect. call get_decimal_mode ( unit = unit , decimal_point = decimal_point , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited ( unit = unit , terminators = ' ' // '/' // merge ( CK_ ',' , CK_ ';' , decimal_point ), iostat = iostat , iomsg = iomsg ) endsubroutine read_undelimited_listdirected","tags":"","loc":"proc/read_undelimited_listdirected.html"},{"title":"read_undelimited – StringiFor","text":"private subroutine read_undelimited(dtv, unit, terminators, iostat, iomsg) Read an undelimited string up until end of record or a character from a set of terminators is encountered. If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the\nfile remains at end of record. Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: terminators Characters that are considered to terminate the string.\nBlanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Contents Source Code read_undelimited Source Code subroutine read_undelimited ( dtv , unit , terminators , iostat , iomsg ) !< Read an undelimited string up until end of record or a character from a set of terminators is encountered. !< !< If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the !< file remains at end of record. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: terminators !< Characters that are considered to terminate the string. !< Blanks in this string are meaningful. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then ! end of record just means end of string. We pass on the condition return elseif ( iostat /= 0 ) then ! something odd happened return endif if ( scan ( ch , terminators ) /= 0 ) then ! change the file position so that the next read sees the terminator read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return iostat = 0 return endif ! we got a character - append it dtv % raw = dtv % raw // ch enddo endsubroutine read_undelimited","tags":"","loc":"proc/read_undelimited.html"},{"title":"write_formatted – StringiFor","text":"private subroutine write_formatted(dtv, unit, iotype, v_list, iostat, iomsg) Formatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Contents Source Code write_formatted Source Code subroutine write_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !< Formatted output. class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif endsubroutine write_formatted","tags":"","loc":"proc/write_formatted.html"},{"title":"read_unformatted – StringiFor","text":"private subroutine read_unformatted(dtv, unit, iostat, iomsg) Unformatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Contents Source Code read_unformatted Source Code subroutine read_unformatted ( dtv , unit , iostat , iomsg ) !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endsubroutine read_unformatted","tags":"","loc":"proc/read_unformatted.html"},{"title":"write_unformatted – StringiFor","text":"private subroutine write_unformatted(dtv, unit, iostat, iomsg) Unformatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Contents Source Code write_unformatted Source Code subroutine write_unformatted ( dtv , unit , iostat , iomsg ) !< Unformatted output. class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif endsubroutine write_unformatted","tags":"","loc":"proc/write_unformatted.html"},{"title":"get_delimiter_mode – StringiFor","text":"private subroutine get_delimiter_mode(unit, delim, iostat, iomsg) Uses iso_fortran_env proc~~get_delimiter_mode~~UsesGraph proc~get_delimiter_mode get_delimiter_mode iso_fortran_env iso_fortran_env proc~get_delimiter_mode->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Get the DELIM changeable connection mode for the given unit. If the unit is connected to an internal file, then the default value of NONE is always returned. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit The unit for the connection. character(kind=CK,len=1), intent(out) :: delim Represents the value of the DELIM mode. integer, intent(out) :: iostat IOSTAT error code, non-zero on error. character, intent(inout) :: iomsg IOMSG explanatory message - only defined if iostat is non-zero. Contents Source Code get_delimiter_mode Source Code subroutine get_delimiter_mode ( unit , delim , iostat , iomsg ) !< Get the DELIM changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of NONE is always returned. use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit integer , intent ( in ) :: unit !< The unit for the connection. character ( len = 1 , kind = CK ), intent ( out ) :: delim !< Represents the value of the DELIM mode. integer , intent ( out ) :: iostat !< IOSTAT error code, non-zero on error. character ( * ), intent ( inout ) :: iomsg !< IOMSG explanatory message - only defined if iostat is non-zero. character ( 10 ) :: delim_buffer !< Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. ! get the string representation of the changeable mode inquire ( unit , delim = delim_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the DELIM mode for an internal file iostat = 0 delim = '' return elseif ( iostat /= 0 ) then iomsg = local_iomsg return endif ! interpret the DELIM string if ( delim_buffer == 'QUOTE' ) then delim = '\"' elseif ( delim_buffer == 'APOSTROPHE' ) then delim = '''' else delim = '\"' endif endsubroutine get_delimiter_mode","tags":"","loc":"proc/get_delimiter_mode.html"},{"title":"get_next_non_blank_character_this_record – StringiFor","text":"private subroutine get_next_non_blank_character_this_record(unit, ch, iostat, iomsg) Get the next non-blank character in the current record. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Called by proc~~get_next_non_blank_character_this_record~~CalledByGraph proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record proc~read_formatted read_formatted proc~read_formatted->proc~get_next_non_blank_character_any_record Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_next_non_blank_character_this_record Source Code subroutine get_next_non_blank_character_this_record ( unit , ch , iostat , iomsg ) !< Get the next non-blank character in the current record. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. do ! we spcify non-advancing, just in case we want this callable outside the context of a child input statement ! the PAD specifier simply saves the need for the READ statement to define ch if EOR is hit ! read(unit, \"(A)\", iostat=iostat, iomsg=iomsg, advance='NO') ch ! ...but that causes ifort to blow up at runtime read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg , pad = 'NO' ) ch if ( iostat /= 0 ) return if ( ch /= '' ) exit enddo endsubroutine get_next_non_blank_character_this_record","tags":"","loc":"proc/get_next_non_blank_character_this_record.html"},{"title":"get_next_non_blank_character_any_record – StringiFor","text":"private subroutine get_next_non_blank_character_any_record(unit, ch, iostat, iomsg) Get the next non-blank character, advancing records if necessary. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Calls proc~~get_next_non_blank_character_any_record~~CallsGraph proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_next_non_blank_character_any_record~~CalledByGraph proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~read_formatted read_formatted proc~read_formatted->proc~get_next_non_blank_character_any_record Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_next_non_blank_character_any_record Source Code subroutine get_next_non_blank_character_any_record ( unit , ch , iostat , iomsg ) !< Get the next non-blank character, advancing records if necessary. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. do call get_next_non_blank_character_this_record ( unit = unit , ch = ch , iostat = iostat , iomsg = local_iomsg ) if ( is_iostat_eor ( iostat )) then ! try again on the next record read ( unit , \"(/)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return elseif ( iostat /= 0 ) then ! some sort of problem iomsg = local_iomsg return else ! got it exit endif enddo endsubroutine get_next_non_blank_character_any_record","tags":"","loc":"proc/get_next_non_blank_character_any_record.html"},{"title":"get_decimal_mode – StringiFor","text":"private subroutine get_decimal_mode(unit, decimal_point, iostat, iomsg) Uses iso_fortran_env proc~~get_decimal_mode~~UsesGraph proc~get_decimal_mode get_decimal_mode iso_fortran_env iso_fortran_env proc~get_decimal_mode->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Get the DECIMAL changeable connection mode for the given unit. If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the\nactual value in force at the time of the call to this procedure. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. logical, intent(out) :: decimal_point True if the decimal mode is POINT, false otherwise. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Called by proc~~get_decimal_mode~~CalledByGraph proc~get_decimal_mode get_decimal_mode proc~read_undelimited_listdirected read_undelimited_listdirected proc~read_undelimited_listdirected->proc~get_decimal_mode Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_decimal_mode Source Code subroutine get_decimal_mode ( unit , decimal_point , iostat , iomsg ) !< Get the DECIMAL changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the !< actual value in force at the time of the call to this procedure. use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit integer , intent ( in ) :: unit !< Logical unit. logical , intent ( out ) :: decimal_point !< True if the decimal mode is POINT, false otherwise. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( 5 ) :: decimal_buffer !< Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character ( len ( iomsg )) :: local_iomsg !< Local iomsg, so it doesn't get inappropriately redefined. inquire ( unit , decimal = decimal_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the decimal mode for an internal file iostat = 0 decimal_point = . true . return else if ( iostat /= 0 ) then iomsg = local_iomsg return endif decimal_point = decimal_buffer == 'POINT' endsubroutine get_decimal_mode","tags":"","loc":"proc/get_decimal_mode.html"},{"title":"glob – StringiFor","text":"public interface glob Overloading glob procedure. type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call glob ( self = astring , pattern = 'foo-*' , list = alist_chr ) call glob ( self = astring , pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr if ( test_passed ) then test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str endif print '(L1)' , test_passed Calls interface~~glob~~CallsGraph interface~glob glob proc~glob_character glob_character interface~glob->proc~glob_character proc~glob_string glob_string interface~glob->proc~glob_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~glob~~CalledByGraph interface~glob glob program~volatile_doctest~53 volatile_doctest program~volatile_doctest~53->interface~glob Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures glob_character glob_string Module Procedures private subroutine glob_character (self, pattern, list) Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: pattern Given pattern. character(len=:), intent(out), allocatable :: list (:) List of matching pathnames. private subroutine glob_string (self, pattern, list) Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: pattern Given pattern. type( string ), intent(out), allocatable :: list (:) List of matching pathnames.","tags":"","loc":"interface/glob.html"},{"title":"strjoin – StringiFor","text":"public interface strjoin Calls interface~~strjoin~~CallsGraph interface~strjoin strjoin proc~strjoin_strings strjoin_strings interface~strjoin->proc~strjoin_strings proc~strjoin_strings_array strjoin_strings_array interface~strjoin->proc~strjoin_strings_array proc~strjoin_characters strjoin_characters interface~strjoin->proc~strjoin_characters proc~strjoin_characters_array strjoin_characters_array interface~strjoin->proc~strjoin_characters_array proc~strjoin_strings_array->proc~strjoin_strings proc~strjoin_characters_array->proc~strjoin_characters Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures strjoin_strings strjoin_characters strjoin_strings_array strjoin_characters_array Module Procedures private pure function strjoin_strings (array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function strjoin_characters (array, sep, is_trim) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not Return Value type( string ) The join of array. private pure function strjoin_strings_array (array, sep, is_col) result(join) Return a string that is a join of columns or rows of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ),allocatable, (:) The join of array. private pure function strjoin_characters_array (array, sep, is_trim, is_col) result(join) Return a string that is a join of columns or rows of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ),allocatable, (:) The join of array.","tags":"","loc":"interface/strjoin.html"},{"title":"adjustl – StringiFor","text":"public interface adjustl Builtin adjustl overloading. Calls interface~~adjustl~~CallsGraph interface~adjustl adjustl proc~sadjustl_character sadjustl_character interface~adjustl->proc~sadjustl_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sadjustl_character Module Procedures private pure function sadjustl_character (s) result(adjusted) Left adjust a string by removing leading spaces (character output). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK,len=:),allocatable Adjusted string.","tags":"","loc":"interface/adjustl.html"},{"title":"adjustr – StringiFor","text":"public interface adjustr Builtin adjustr overloading. Calls interface~~adjustr~~CallsGraph interface~adjustr adjustr proc~sadjustr_character sadjustr_character interface~adjustr->proc~sadjustr_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sadjustr_character Module Procedures private pure function sadjustr_character (s) result(adjusted) Right adjust a string by removing leading spaces (character output). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK,len=:),allocatable Adjusted string.","tags":"","loc":"interface/adjustr.html"},{"title":"count – StringiFor","text":"public interface count Builtin count overloading. Calls interface~~count~~CallsGraph interface~count count proc~count_substring count_substring interface~count->proc~count_substring Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures count_substring Module Procedures private elemental function count_substring (s, substring) result(No) Count the number of occurences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: s String. character, intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences.","tags":"","loc":"interface/count.html"},{"title":"index – StringiFor","text":"public interface index Builtin index overloading. Calls interface~~index~~CallsGraph interface~index index proc~sindex_string_string sindex_string_string interface~index->proc~sindex_string_string proc~sindex_character_string sindex_character_string interface~index->proc~sindex_character_string proc~sindex_string_character sindex_string_character interface~index->proc~sindex_string_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sindex_string_string sindex_string_character sindex_character_string Module Procedures private elemental function sindex_string_string (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sindex_string_character (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sindex_character_string (s, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s String. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search.","tags":"","loc":"interface/index.html"},{"title":"len_trim – StringiFor","text":"public interface len_trim Builtin len_trim overloading. Calls interface~~len_trim~~CallsGraph interface~len_trim len_trim proc~slen_trim slen_trim interface~len_trim->proc~slen_trim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures slen_trim Module Procedures private elemental function slen_trim (self) result(l) Return the length of a string, ignoring any trailing blanks. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length.","tags":"","loc":"interface/len_trim.html"},{"title":"repeat – StringiFor","text":"public interface repeat Builtin repeat overloading. Calls interface~~repeat~~CallsGraph interface~repeat repeat proc~srepeat_string_string srepeat_string_string interface~repeat->proc~srepeat_string_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures srepeat_string_string Module Procedures private elemental function srepeat_string_string (self, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string.","tags":"","loc":"interface/repeat.html"},{"title":"scan – StringiFor","text":"public interface scan Builtin scan overloading. Calls interface~~scan~~CallsGraph interface~scan scan proc~sscan_string_string sscan_string_string interface~scan->proc~sscan_string_string proc~sscan_string_character sscan_string_character interface~scan->proc~sscan_string_character proc~sscan_character_string sscan_character_string interface~scan->proc~sscan_character_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sscan_string_string sscan_string_character sscan_character_string Module Procedures private elemental function sscan_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_character_string (s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search.","tags":"","loc":"interface/scan.html"},{"title":"trim – StringiFor","text":"public interface trim Builtin trim overloading. Calls interface~~trim~~CallsGraph interface~trim trim proc~strim strim interface~trim->proc~strim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures strim Module Procedures private elemental function strim (self) result(trimmed) Remove trailing spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string.","tags":"","loc":"interface/trim.html"},{"title":"verify – StringiFor","text":"public interface verify Builtin verify overloading. Calls interface~~verify~~CallsGraph interface~verify verify proc~sverify_string_string sverify_string_string interface~verify->proc~sverify_string_string proc~sverify_character_string sverify_character_string interface~verify->proc~sverify_character_string proc~sverify_string_character sverify_string_character interface~verify->proc~sverify_string_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sverify_string_string sverify_string_character sverify_character_string Module Procedures private elemental function sverify_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_character_string (s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search.","tags":"","loc":"interface/verify.html"},{"title":"stringifor – StringiFor","text":"StringiFor, Strings Fortran Manipulator with steroids. Uses stringifor_string_t penf module~~stringifor~~UsesGraph module~stringifor stringifor module~stringifor_string_t stringifor_string_t module~stringifor->module~stringifor_string_t penf penf module~stringifor->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~stringifor~~UsedByGraph module~stringifor stringifor program~volatile_doctest~110 volatile_doctest program~volatile_doctest~110->module~stringifor program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->module~stringifor program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->module~stringifor program~volatile_doctest~111 volatile_doctest program~volatile_doctest~111->module~stringifor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines read_file read_lines write_file write_lines Subroutines public subroutine read_file (file, lines, form, iostat, iomsg) Read a file as a single string stream. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. public subroutine read_lines (unit, lines, form, iostat, iomsg) Read lines (records) from a connected-formatted unit. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. public subroutine write_file (file, lines, form, iostat, iomsg) Write a single string stream into file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. public subroutine write_lines (unit, lines, form, iostat, iomsg) Write lines (records) to a connected-formatted unit. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message.","tags":"","loc":"module/stringifor.html"},{"title":"stringifor_string_t – StringiFor","text":"StringiFor, definition of string type. Uses iso_fortran_env befor64 penf face module~~stringifor_string_t~~UsesGraph module~stringifor_string_t stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~stringifor_string_t~~UsedByGraph module~stringifor_string_t stringifor_string_t program~volatile_doctest~24 volatile_doctest program~volatile_doctest~24->module~stringifor_string_t program~volatile_doctest~56 volatile_doctest program~volatile_doctest~56->module~stringifor_string_t program~volatile_doctest~108 volatile_doctest program~volatile_doctest~108->module~stringifor_string_t program~volatile_doctest~35 volatile_doctest program~volatile_doctest~35->module~stringifor_string_t program~volatile_doctest~67 volatile_doctest program~volatile_doctest~67->module~stringifor_string_t program~volatile_doctest~14 volatile_doctest program~volatile_doctest~14->module~stringifor_string_t program~volatile_doctest~46 volatile_doctest program~volatile_doctest~46->module~stringifor_string_t program~volatile_doctest~78 volatile_doctest program~volatile_doctest~78->module~stringifor_string_t program~volatile_doctest~98 volatile_doctest program~volatile_doctest~98->module~stringifor_string_t program~volatile_doctest~25 volatile_doctest program~volatile_doctest~25->module~stringifor_string_t program~volatile_doctest~57 volatile_doctest program~volatile_doctest~57->module~stringifor_string_t program~volatile_doctest~109 volatile_doctest program~volatile_doctest~109->module~stringifor_string_t program~volatile_doctest volatile_doctest program~volatile_doctest->module~stringifor_string_t program~volatile_doctest~4 volatile_doctest program~volatile_doctest~4->module~stringifor_string_t program~volatile_doctest~36 volatile_doctest program~volatile_doctest~36->module~stringifor_string_t program~volatile_doctest~68 volatile_doctest program~volatile_doctest~68->module~stringifor_string_t program~volatile_doctest~88 volatile_doctest program~volatile_doctest~88->module~stringifor_string_t program~volatile_doctest~15 volatile_doctest program~volatile_doctest~15->module~stringifor_string_t program~volatile_doctest~47 volatile_doctest program~volatile_doctest~47->module~stringifor_string_t program~volatile_doctest~79 volatile_doctest program~volatile_doctest~79->module~stringifor_string_t program~volatile_doctest~99 volatile_doctest program~volatile_doctest~99->module~stringifor_string_t program~volatile_doctest~26 volatile_doctest program~volatile_doctest~26->module~stringifor_string_t program~volatile_doctest~58 volatile_doctest program~volatile_doctest~58->module~stringifor_string_t program~volatile_doctest~69 volatile_doctest program~volatile_doctest~69->module~stringifor_string_t program~volatile_doctest~5 volatile_doctest program~volatile_doctest~5->module~stringifor_string_t program~volatile_doctest~37 volatile_doctest program~volatile_doctest~37->module~stringifor_string_t program~volatile_doctest~89 volatile_doctest program~volatile_doctest~89->module~stringifor_string_t program~volatile_doctest~16 volatile_doctest program~volatile_doctest~16->module~stringifor_string_t program~volatile_doctest~48 volatile_doctest program~volatile_doctest~48->module~stringifor_string_t program~volatile_doctest~80 volatile_doctest program~volatile_doctest~80->module~stringifor_string_t program~volatile_doctest~100 volatile_doctest program~volatile_doctest~100->module~stringifor_string_t program~volatile_doctest~27 volatile_doctest program~volatile_doctest~27->module~stringifor_string_t program~volatile_doctest~59 volatile_doctest program~volatile_doctest~59->module~stringifor_string_t program~volatile_doctest~6 volatile_doctest program~volatile_doctest~6->module~stringifor_string_t program~volatile_doctest~38 volatile_doctest program~volatile_doctest~38->module~stringifor_string_t program~volatile_doctest~70 volatile_doctest program~volatile_doctest~70->module~stringifor_string_t program~volatile_doctest~90 volatile_doctest program~volatile_doctest~90->module~stringifor_string_t program~volatile_doctest~17 volatile_doctest program~volatile_doctest~17->module~stringifor_string_t program~volatile_doctest~49 volatile_doctest program~volatile_doctest~49->module~stringifor_string_t program~volatile_doctest~81 volatile_doctest program~volatile_doctest~81->module~stringifor_string_t program~volatile_doctest~101 volatile_doctest program~volatile_doctest~101->module~stringifor_string_t program~volatile_doctest~28 volatile_doctest program~volatile_doctest~28->module~stringifor_string_t program~volatile_doctest~60 volatile_doctest program~volatile_doctest~60->module~stringifor_string_t program~volatile_doctest~7 volatile_doctest program~volatile_doctest~7->module~stringifor_string_t program~volatile_doctest~39 volatile_doctest program~volatile_doctest~39->module~stringifor_string_t program~volatile_doctest~71 volatile_doctest program~volatile_doctest~71->module~stringifor_string_t program~volatile_doctest~91 volatile_doctest program~volatile_doctest~91->module~stringifor_string_t program~volatile_doctest~18 volatile_doctest program~volatile_doctest~18->module~stringifor_string_t program~volatile_doctest~50 volatile_doctest program~volatile_doctest~50->module~stringifor_string_t program~volatile_doctest~82 volatile_doctest program~volatile_doctest~82->module~stringifor_string_t program~volatile_doctest~102 volatile_doctest program~volatile_doctest~102->module~stringifor_string_t program~volatile_doctest~29 volatile_doctest program~volatile_doctest~29->module~stringifor_string_t program~volatile_doctest~61 volatile_doctest program~volatile_doctest~61->module~stringifor_string_t program~volatile_doctest~8 volatile_doctest program~volatile_doctest~8->module~stringifor_string_t program~volatile_doctest~40 volatile_doctest program~volatile_doctest~40->module~stringifor_string_t program~volatile_doctest~72 volatile_doctest program~volatile_doctest~72->module~stringifor_string_t program~volatile_doctest~92 volatile_doctest program~volatile_doctest~92->module~stringifor_string_t program~volatile_doctest~19 volatile_doctest program~volatile_doctest~19->module~stringifor_string_t program~volatile_doctest~51 volatile_doctest program~volatile_doctest~51->module~stringifor_string_t program~volatile_doctest~83 volatile_doctest program~volatile_doctest~83->module~stringifor_string_t program~volatile_doctest~103 volatile_doctest program~volatile_doctest~103->module~stringifor_string_t program~volatile_doctest~30 volatile_doctest program~volatile_doctest~30->module~stringifor_string_t program~volatile_doctest~62 volatile_doctest program~volatile_doctest~62->module~stringifor_string_t program~volatile_doctest~3 volatile_doctest program~volatile_doctest~3->module~stringifor_string_t program~volatile_doctest~9 volatile_doctest program~volatile_doctest~9->module~stringifor_string_t program~volatile_doctest~41 volatile_doctest program~volatile_doctest~41->module~stringifor_string_t program~volatile_doctest~73 volatile_doctest program~volatile_doctest~73->module~stringifor_string_t program~volatile_doctest~93 volatile_doctest program~volatile_doctest~93->module~stringifor_string_t program~volatile_doctest~20 volatile_doctest program~volatile_doctest~20->module~stringifor_string_t program~volatile_doctest~52 volatile_doctest program~volatile_doctest~52->module~stringifor_string_t program~volatile_doctest~84 volatile_doctest program~volatile_doctest~84->module~stringifor_string_t program~volatile_doctest~104 volatile_doctest program~volatile_doctest~104->module~stringifor_string_t program~volatile_doctest~31 volatile_doctest program~volatile_doctest~31->module~stringifor_string_t program~volatile_doctest~63 volatile_doctest program~volatile_doctest~63->module~stringifor_string_t program~volatile_doctest~10 volatile_doctest program~volatile_doctest~10->module~stringifor_string_t program~volatile_doctest~42 volatile_doctest program~volatile_doctest~42->module~stringifor_string_t program~volatile_doctest~74 volatile_doctest program~volatile_doctest~74->module~stringifor_string_t program~volatile_doctest~94 volatile_doctest program~volatile_doctest~94->module~stringifor_string_t program~volatile_doctest~2 volatile_doctest program~volatile_doctest~2->module~stringifor_string_t program~volatile_doctest~21 volatile_doctest program~volatile_doctest~21->module~stringifor_string_t program~volatile_doctest~53 volatile_doctest program~volatile_doctest~53->module~stringifor_string_t program~volatile_doctest~85 volatile_doctest program~volatile_doctest~85->module~stringifor_string_t program~volatile_doctest~105 volatile_doctest program~volatile_doctest~105->module~stringifor_string_t program~volatile_doctest~32 volatile_doctest program~volatile_doctest~32->module~stringifor_string_t program~volatile_doctest~64 volatile_doctest program~volatile_doctest~64->module~stringifor_string_t program~volatile_doctest~11 volatile_doctest program~volatile_doctest~11->module~stringifor_string_t program~volatile_doctest~43 volatile_doctest program~volatile_doctest~43->module~stringifor_string_t program~volatile_doctest~75 volatile_doctest program~volatile_doctest~75->module~stringifor_string_t program~volatile_doctest~95 volatile_doctest program~volatile_doctest~95->module~stringifor_string_t program~volatile_doctest~22 volatile_doctest program~volatile_doctest~22->module~stringifor_string_t program~volatile_doctest~54 volatile_doctest program~volatile_doctest~54->module~stringifor_string_t program~volatile_doctest~86 volatile_doctest program~volatile_doctest~86->module~stringifor_string_t program~volatile_doctest~106 volatile_doctest program~volatile_doctest~106->module~stringifor_string_t program~volatile_doctest~33 volatile_doctest program~volatile_doctest~33->module~stringifor_string_t program~volatile_doctest~65 volatile_doctest program~volatile_doctest~65->module~stringifor_string_t program~volatile_doctest~76 volatile_doctest program~volatile_doctest~76->module~stringifor_string_t program~volatile_doctest~12 volatile_doctest program~volatile_doctest~12->module~stringifor_string_t program~volatile_doctest~44 volatile_doctest program~volatile_doctest~44->module~stringifor_string_t program~volatile_doctest~96 volatile_doctest program~volatile_doctest~96->module~stringifor_string_t program~volatile_doctest~23 volatile_doctest program~volatile_doctest~23->module~stringifor_string_t program~volatile_doctest~55 volatile_doctest program~volatile_doctest~55->module~stringifor_string_t program~volatile_doctest~87 volatile_doctest program~volatile_doctest~87->module~stringifor_string_t program~volatile_doctest~107 volatile_doctest program~volatile_doctest~107->module~stringifor_string_t program~volatile_doctest~34 volatile_doctest program~volatile_doctest~34->module~stringifor_string_t program~volatile_doctest~66 volatile_doctest program~volatile_doctest~66->module~stringifor_string_t module~stringifor stringifor module~stringifor->module~stringifor_string_t program~volatile_doctest~13 volatile_doctest program~volatile_doctest~13->module~stringifor_string_t program~volatile_doctest~45 volatile_doctest program~volatile_doctest~45->module~stringifor_string_t program~volatile_doctest~77 volatile_doctest program~volatile_doctest~77->module~stringifor_string_t program~volatile_doctest~97 volatile_doctest program~volatile_doctest~97->module~stringifor_string_t program~volatile_doctest~110 volatile_doctest program~volatile_doctest~110->module~stringifor program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv program~stringifor_test_parse_large_csv->module~stringifor program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser program~stringifor_test_csv_naive_parser->module~stringifor program~volatile_doctest~111 volatile_doctest program~volatile_doctest~111->module~stringifor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables CK UPPER_ALPHABET LOWER_ALPHABET SPACE TAB UIX_DIR_SEP BACKSLASH Interfaces glob strjoin adjustl adjustr count index len_trim repeat scan trim verify Derived Types string Functions string_ sadjustl_character sadjustr_character count_substring sindex_character_string sscan_character_string sverify_character_string sadjustl sadjustr scount sindex_string_string sindex_string_character slen slen_trim srepeat_string_string srepeat_character_string sscan_string_string sscan_string_character strim sverify_string_string sverify_string_character basedir basename camelcase capitalize chars colorize_str decode encode escape extension fill insert_character insert_string join_strings join_characters strjoin_strings strjoin_characters strjoin_strings_array strjoin_characters_array lower partition replace reverse search slice snakecase startcase strip swapcase tempname to_integer_I1P to_integer_I2P to_integer_I4P to_integer_I8P to_real_R4P to_real_R8P to_real_R16P unescape unique upper end_with is_allocated is_digit is_integer is_lower is_number is_real is_upper start_with string_concat_string string_concat_character character_concat_string string_concat_string_string string_concat_character_string character_concat_string_string string_eq_string string_eq_character character_eq_string string_ne_string string_ne_character character_ne_string string_lt_string string_lt_character character_lt_string string_le_string string_le_character character_le_string string_ge_string string_ge_character character_ge_string string_gt_string string_gt_character character_gt_string replace_one_occurrence Subroutines free glob_character glob_string read_file read_line read_lines split split_chunked write_file write_line write_lines string_assign_string string_assign_character string_assign_integer_I1P string_assign_integer_I2P string_assign_integer_I4P string_assign_integer_I8P string_assign_real_R4P string_assign_real_R8P string_assign_real_R16P read_formatted read_delimited read_undelimited_listdirected read_undelimited write_formatted read_unformatted write_unformatted get_delimiter_mode get_next_non_blank_character_this_record get_next_non_blank_character_any_record get_decimal_mode Variables Type Visibility Attributes Name Initial integer, public, parameter :: CK = selected_char_kind('DEFAULT') Default character kind. character(kind=CK,len=26), private, parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(kind=CK,len=26), private, parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. character(kind=CK,len=1), private, parameter :: SPACE = ' ' Space character. character(kind=CK,len=1), private, parameter :: TAB = achar(9) Tab character. character(kind=CK,len=1), private, parameter :: UIX_DIR_SEP = char(47) Unix/Linux directories separator (/). character(kind=CK,len=1), private, parameter :: BACKSLASH = char(92) Backslash character. Interfaces public interface glob Overloading glob procedure. Read more… private subroutine glob_character (self, pattern, list) Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: pattern Given pattern. character(len=:), intent(out), allocatable :: list (:) List of matching pathnames. private subroutine glob_string (self, pattern, list) Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: pattern Given pattern. type( string ), intent(out), allocatable :: list (:) List of matching pathnames. public interface strjoin private pure function strjoin_strings (array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function strjoin_characters (array, sep, is_trim) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not Return Value type( string ) The join of array. private pure function strjoin_strings_array (array, sep, is_col) result(join) Return a string that is a join of columns or rows of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ),allocatable, (:) The join of array. private pure function strjoin_characters_array (array, sep, is_trim, is_col) result(join) Return a string that is a join of columns or rows of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ),allocatable, (:) The join of array. public interface adjustl Builtin adjustl overloading. private pure function sadjustl_character (s) result(adjusted) Left adjust a string by removing leading spaces (character output). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK,len=:),allocatable Adjusted string. public interface adjustr Builtin adjustr overloading. private pure function sadjustr_character (s) result(adjusted) Right adjust a string by removing leading spaces (character output). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK,len=:),allocatable Adjusted string. public interface count Builtin count overloading. private elemental function count_substring (s, substring) result(No) Count the number of occurences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: s String. character, intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. public interface index Builtin index overloading. private elemental function sindex_string_string (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sindex_string_character (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sindex_character_string (s, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s String. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. public interface len_trim Builtin len_trim overloading. private elemental function slen_trim (self) result(l) Return the length of a string, ignoring any trailing blanks. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. public interface repeat Builtin repeat overloading. private elemental function srepeat_string_string (self, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. public interface scan Builtin scan overloading. private elemental function sscan_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_character_string (s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. public interface trim Builtin trim overloading. private elemental function strim (self) result(trimmed) Remove trailing spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. public interface verify Builtin verify overloading. private elemental function sverify_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_character_string (s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Derived Types type, public :: string OOP designed string class. Components Type Visibility Attributes Name Initial character(kind=CK,len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: adjustl => sadjustl Adjustl replacement. procedure, public, pass(self) :: adjustr => sadjustr Adjustr replacement. procedure, public, pass(self) :: count => scount Count replacement. generic, public :: index => sindex_string_string, sindex_string_character Index replacement. procedure, public, pass(self) :: len => slen Len replacement. procedure, public, pass(self) :: len_trim => slen_trim Len_trim replacement. generic, public :: repeat => srepeat_string_string, srepeat_character_string Repeat replacement. generic, public :: scan => sscan_string_string, sscan_string_character Scan replacement. procedure, public, pass(self) :: trim => strim Trim replacement. generic, public :: verify => sverify_string_string, sverify_string_character Verify replacement. procedure, public, pass(self) :: basedir Return the base directory name of a string containing a file name. procedure, public, pass(self) :: basename Return the base file name of a string containing a file name. procedure, public, pass(self) :: camelcase Return a string with all words capitalized without spaces. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. procedure, public, pass(self) :: chars Return the raw characters data. generic, public :: colorize => colorize_str Colorize and stylize strings. procedure, public, pass(self) :: decode Decode string. procedure, public, pass(self) :: encode Encode string. procedure, public, pass(self) :: escape Escape backslashes (or custom escape character). procedure, public, pass(self) :: extension Return the extension of a string containing a file name. procedure, public, pass(self) :: fill Pad string on the left (or right) with zeros (or other char) to fill width. procedure, public, pass(self) :: free Free dynamic memory. generic, public :: glob => glob_character, glob_string Glob search, finds all the pathnames matching a given pattern. generic, public :: insert => insert_string, insert_character Insert substring into string at a specified position. generic, public :: join => join_strings, join_characters Return a string that is a join of an array of strings or characters. generic, public :: strjoin => strjoin_strings, strjoin_characters, strjoin_strings_array, strjoin_characters_array Return a string that is a join of an array of strings or characters;\nReturn join 1D string array of an 2D array of strings or characters in columns or rows. procedure, public, pass(self) :: lower Return a string with all lowercase characters. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). procedure, public, pass(self) :: read_file Read a file a single string stream. procedure, public, pass(self) :: read_line Read line (record) from a connected unit. procedure, public, pass(self) :: read_lines Read (all) lines (records) from a connected unit as a single ascii stream. procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. procedure, public, pass(self) :: reverse Return a reversed string. procedure, public, pass(self) :: search Search for tagged record into string. procedure, public, pass(self) :: slice Return the raw characters data sliced. procedure, public, pass(self) :: snakecase Return a string with all words lowercase separated by “_”. procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: split_chunked Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: startcase Return a string with all words capitalized, e.g. title case. procedure, public, pass(self) :: strip Return a string with the leading and trailing characters removed. procedure, public, pass(self) :: swapcase Return a string with uppercase chars converted to lowercase and vice versa. procedure, public, pass(self) :: tempname Return a safe temporary name suitable for temporary file or directories. generic, public :: to_number => to_integer_I1P, to_integer_I2P, to_integer_I4P, to_integer_I8P, to_real_R8P, to_real_R4P Cast string to number. procedure, public, pass(self) :: unescape Unescape double backslashes (or custom escaped character). procedure, public, pass(self) :: unique Reduce to one (unique) multiple occurrences of a substring into a string. procedure, public, pass(self) :: upper Return a string with all uppercase characters. procedure, public, pass(self) :: write_file Write a single string stream into file. procedure, public, pass(self) :: write_line Write line (record) to a connected unit. procedure, public, pass(self) :: write_lines Write lines (records) to a connected unit. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. procedure, public, pass(self) :: is_integer Return true if the string contains an integer. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. procedure, public, pass(self) :: is_number Return true if the string contains a number (real or integer). procedure, public, pass(self) :: is_real Return true if the string contains an real. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. generic, public :: assignment(=) => string_assign_string, string_assign_character, string_assign_integer_I1P, string_assign_integer_I2P, string_assign_integer_I4P, string_assign_integer_I8P, string_assign_real_R8P, string_assign_real_R4P Assignment operator overloading. generic, public :: operator(//) => string_concat_string, string_concat_character, character_concat_string Concatenation operator overloading. generic, public :: operator(.cat.) => string_concat_string_string, string_concat_character_string, character_concat_string_string Concatenation operator (string output) overloading. generic, public :: operator(==) => string_eq_string, string_eq_character, character_eq_string Equal operator overloading. generic, public :: operator(/=) => string_ne_string, string_ne_character, character_ne_string Not equal operator overloading. generic, public :: operator(<) => string_lt_string, string_lt_character, character_lt_string Lower than operator overloading. generic, public :: operator(<=) => string_le_string, string_le_character, character_le_string Lower equal than operator overloading. generic, public :: operator(>=) => string_ge_string, string_ge_character, character_ge_string Greater equal than operator overloading. generic, public :: operator(>) => string_gt_string, string_gt_character, character_gt_string Greater than operator overloading. generic, public :: read(formatted) => read_formatted Formatted input. generic, public :: write(formatted) => write_formatted Formatted output. generic, public :: read(unformatted) => read_unformatted Unformatted input. generic, public :: write(unformatted) => write_unformatted Unformatted output. procedure, private, pass(self) :: sindex_string_string Index replacement. procedure, private, pass(self) :: sindex_string_character Index replacement. procedure, private, pass(self) :: srepeat_string_string Repeat replacement. procedure, private, nopass :: srepeat_character_string Repeat replacement. procedure, private, pass(self) :: sscan_string_string Scan replacement. procedure, private, pass(self) :: sscan_string_character Scan replacement. procedure, private, pass(self) :: sverify_string_string Verify replacement. procedure, private, pass(self) :: sverify_string_character Verify replacement. procedure, private, pass(self) :: colorize_str Colorize and stylize strings. procedure, private, pass(self) :: glob_character Glob search (character output). procedure, private, pass(self) :: glob_string Glob search (string output). procedure, private, pass(self) :: insert_string Insert substring into string at a specified position. procedure, private, pass(self) :: insert_character Insert substring into string at a specified position. procedure, private, pass(self) :: join_strings Return join string of an array of strings. procedure, private, pass(self) :: join_characters Return join string of an array of characters. procedure, private, nopass :: strjoin_strings Return join string of an array of strings. procedure, private, nopass :: strjoin_characters Return join string of an array of strings. procedure, private, nopass :: strjoin_strings_array Return join 1D string array of an 2D array of strings in columns or rows. procedure, private, nopass :: strjoin_characters_array Return join 1D string array of an 2D array of characters in columns or rows. procedure, private, pass(self) :: to_integer_I1P Cast string to integer. procedure, private, pass(self) :: to_integer_I2P Cast string to integer. procedure, private, pass(self) :: to_integer_I4P Cast string to integer. procedure, private, pass(self) :: to_integer_I8P Cast string to integer. procedure, private, pass(self) :: to_real_R4P Cast string to real. procedure, private, pass(self) :: to_real_R8P Cast string to real. procedure, private, pass(self) :: to_real_R16P Cast string to real. procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. procedure, private, pass(lhs) :: string_assign_integer_I1P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I2P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I4P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I8P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_real_R4P Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R8P Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R16P Assignment operator from real input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). procedure, private, pass(lhs) :: string_eq_string Equal to string logical operator. procedure, private, pass(lhs) :: string_eq_character Equal to character logical operator. procedure, private, pass(rhs) :: character_eq_string Equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ne_string Not equal to string logical operator. procedure, private, pass(lhs) :: string_ne_character Not equal to character logical operator. procedure, private, pass(rhs) :: character_ne_string Not equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_lt_string Lower than to string logical operator. procedure, private, pass(lhs) :: string_lt_character Lower than to character logical operator. procedure, private, pass(rhs) :: character_lt_string Lower than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_le_string Lower equal than to string logical operator. procedure, private, pass(lhs) :: string_le_character Lower equal than to character logical operator. procedure, private, pass(rhs) :: character_le_string Lower equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ge_string Greater equal than to string logical operator. procedure, private, pass(lhs) :: string_ge_character Greater equal than to character logical operator. procedure, private, pass(rhs) :: character_ge_string Greater equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_gt_string Greater than to string logical operator. procedure, private, pass(lhs) :: string_gt_character Greater than to character logical operator. procedure, private, pass(rhs) :: character_gt_string Greater than to character (inverted) logical operator. procedure, private, pass(dtv) :: read_formatted Formatted input. procedure, private, pass(dtv) :: read_delimited Read a delimited input. procedure, private, pass(dtv) :: read_undelimited Read an undelimited input. procedure, private, pass(dtv) :: read_undelimited_listdirected Read an undelimited list directed input. procedure, private, pass(dtv) :: write_formatted Formatted output. procedure, private, pass(dtv) :: read_unformatted Unformatted input. procedure, private, pass(dtv) :: write_unformatted Unformatted output. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. Functions private pure function string_ (c) Return a string given a character input. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: c Character. Return Value type( string ) String. private pure function sadjustl_character (s) result(adjusted) Left adjust a string by removing leading spaces (character output). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK,len=:),allocatable Adjusted string. private pure function sadjustr_character (s) result(adjusted) Right adjust a string by removing leading spaces (character output). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: s String. Return Value character(kind=CK,len=:),allocatable Adjusted string. private elemental function count_substring (s, substring) result(No) Count the number of occurences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: s String. character, intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. private elemental function sindex_character_string (s, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s String. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_character_string (s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_character_string (s, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s String. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sadjustl (self) result(adjusted) Left adjust a string by removing leading spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. private elemental function sadjustr (self) result(adjusted) Right adjust a string by removing leading spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. private elemental function scount (self, substring, ignore_isolated) result(No) Count the number of occurences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore “isolated” occurrences. Return Value integer Number of occurrences. private elemental function sindex_string_string (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sindex_string_character (self, substring, back) result(i) Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function slen (self) result(l) Return the length of a string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. private elemental function slen_trim (self) result(l) Return the length of a string, ignoring any trailing blanks. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. private elemental function srepeat_string_string (self, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. private elemental function srepeat_character_string (rstring, ncopies) result(repeated) Concatenates several copies of an input string. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. private elemental function sscan_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sscan_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function strim (self) result(trimmed) Remove trailing spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. private elemental function sverify_string_string (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function sverify_string_character (self, set, back) result(i) Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. private elemental function basedir (self, sep) Return the base directory name of a string containing a file name. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. private elemental function basename (self, sep, extension, strip_last_extension) Return the base file name of a string containing a file name. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. private elemental function camelcase (self, sep) Return a string with all words capitalized without spaces. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. private elemental function capitalize (self) result(capitalized) Return a string with its first character capitalized and the rest lowercased. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. private pure function chars (self) result(raw) Return the raw characters data. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),allocatable Raw characters data. private pure function colorize_str (self, color_fg, color_bg, style) result(colorized) Colorize and stylize strings, DEFAULT kind. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:),allocatable Colorized string. private elemental function decode (self, codec) result(decoded) Return a string decoded accordingly the codec. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. private elemental function encode (self, codec) result(encoded) Return a string encoded accordingly the codec. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. private elemental function escape (self, to_escape, esc) result(escaped) Escape backslashes (or custom escape character). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. private elemental function extension (self) Return the extension of a string containing a file name. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. private elemental function fill (self, width, right, filling_char) result(filled) Pad string on the left (or right) with zeros (or other char) to fill width. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default “0”). Return Value type( string ) Filled string. private elemental function insert_character (self, substring, pos) result(inserted) Insert substring into string at a specified position. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. private elemental function insert_string (self, substring, pos) result(inserted) Insert substring into string at a specified position. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. private pure function join_strings (self, array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function join_characters (self, array, sep) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function strjoin_strings (array, sep) result(join) Return a string that is a join of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. private pure function strjoin_characters (array, sep, is_trim) result(join) Return a string that is a join of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not Return Value type( string ) The join of array. private pure function strjoin_strings_array (array, sep, is_col) result(join) Return a string that is a join of columns or rows of an array of strings. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ),allocatable, (:) The join of array. private pure function strjoin_characters_array (array, sep, is_trim, is_col) result(join) Return a string that is a join of columns or rows of an array of characters. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: array (1:,1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. logical, intent(in), optional :: is_trim Flag to setup trim character or not logical, intent(in), optional :: is_col Direction: ‘columns’ if .true. or ‘rows’ if .false. Return Value type( string ),allocatable, (:) The join of array. private elemental function lower (self) Return a string with all lowercase characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. private pure function partition (self, sep) result(partitions) Split string at separator and return the 3 parts (before, the separator and after). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )(1:3) after the separator. private elemental function replace (self, old, new, count) result(replaced) Return a string with all occurrences of substring old replaced by new. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. private elemental function reverse (self) result(reversed) Return a reversed string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. private function search (self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Search for tagged record into string, return the first record found (if any) matching the tags. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. private pure function slice (self, istart, iend) result(raw) Return the raw characters data sliced. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK,len=:),allocatable Raw characters data. private elemental function snakecase (self, sep) Return a string with all words lowercase separated by “_”. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. private elemental function startcase (self, sep) Return a string with all words capitalized, e.g. title case. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. private elemental function strip (self, remove_nulls) Return a copy of the string with the leading and trailing characters removed. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. private elemental function swapcase (self) Return a copy of the string with uppercase characters converted to lowercase and vice versa. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. private function tempname (self, is_file, prefix, path) Return a safe temporary name suitable for temporary file or directories. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: is_file True if tempname should be used for file (the default). character, intent(in), optional :: prefix Name prefix, otherwise self is used (if allocated). character, intent(in), optional :: path Path where file/directory should be used, default ./ . Return Value character(len=:),allocatable Safe (unique) temporary name. private elemental function to_integer_I1P (self, kind) result(to_number) Cast string to integer (I1P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. private elemental function to_integer_I2P (self, kind) result(to_number) Cast string to integer (I2P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. private elemental function to_integer_I4P (self, kind) result(to_number) Cast string to integer (I4P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. private elemental function to_integer_I8P (self, kind) result(to_number) Cast string to integer (I8P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. private elemental function to_real_R4P (self, kind) result(to_number) Cast string to real (R4P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. private elemental function to_real_R8P (self, kind) result(to_number) Cast string to real (R8P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. private elemental function to_real_R16P (self, kind) result(to_number) Cast string to real (R16P). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. private elemental function unescape (self, to_unescape, unesc) result(unescaped) Unescape double backslashes (or custom escaped character). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK,len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. private elemental function unique (self, substring) result(uniq) Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. private elemental function upper (self) Return a string with all uppercase characters. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. private elemental function end_with (self, suffix, start, end, ignore_null_eof) Return true if a string ends with a specified suffix. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. logical, intent(in), optional :: ignore_null_eof Ignore null character at the end of file. Return Value logical Result of the test. private elemental function is_allocated (self) Return true if the string is allocated. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. private elemental function is_digit (self) Return true if all characters in the string are digits. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. private elemental function is_integer (self, allow_spaces) Return true if the string contains an integer. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. private elemental function is_lower (self) Return true if all characters in the string are lowercase. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. private elemental function is_number (self, allow_spaces) Return true if the string contains a number (real or integer). Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. private elemental function is_real (self, allow_spaces) Return true if the string contains a real. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. private elemental function is_upper (self) Return true if all characters in the string are uppercase. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. private elemental function start_with (self, prefix, start, end) Return true if a string starts with a specified prefix. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. private pure function string_concat_string (lhs, rhs) result(concat) Concatenation with string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),allocatable Concatenated string. private pure function string_concat_character (lhs, rhs) result(concat) Concatenation with character. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),allocatable Concatenated string. private pure function character_concat_string (lhs, rhs) result(concat) Concatenation with character (inverted). Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),allocatable Concatenated string. private elemental function string_concat_string_string (lhs, rhs) result(concat) Concatenation with string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Concatenation with character. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. private elemental function character_concat_string_string (lhs, rhs) result(concat) Concatenation with character (inverted). Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. private elemental function string_eq_string (lhs, rhs) result(is_it) Equal to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_eq_character (lhs, rhs) result(is_it) Equal to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_eq_string (lhs, rhs) result(is_it) Equal to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_ne_string (lhs, rhs) result(is_it) Not equal to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_ne_character (lhs, rhs) result(is_it) Not equal to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_ne_string (lhs, rhs) result(is_it) Not equal to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_lt_string (lhs, rhs) result(is_it) Lower than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_lt_character (lhs, rhs) result(is_it) Lower than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_lt_string (lhs, rhs) result(is_it) Lower than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_le_string (lhs, rhs) result(is_it) Lower equal than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_le_character (lhs, rhs) result(is_it) Lower equal than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_le_string (lhs, rhs) result(is_it) Lower equal than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_ge_string (lhs, rhs) result(is_it) Greater equal than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_ge_character (lhs, rhs) result(is_it) Greater equal than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_ge_string (lhs, rhs) result(is_it) Greater equal than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_gt_string (lhs, rhs) result(is_it) Greater than to string logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function string_gt_character (lhs, rhs) result(is_it) Greater than to character logical operator. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function character_gt_string (lhs, rhs) result(is_it) Greater than to character (inverted) logical operator. Read more… Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. private elemental function replace_one_occurrence (self, old, new) result(replaced) Return a string with the first occurrence of substring old replaced by new. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Subroutines private elemental subroutine free (self) Free dynamic memory. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. private subroutine glob_character (self, pattern, list) Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: pattern Given pattern. character(len=:), intent(out), allocatable :: list (:) List of matching pathnames. private subroutine glob_string (self, pattern, list) Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character, intent(in) :: pattern Given pattern. type( string ), intent(out), allocatable :: list (:) List of matching pathnames. private subroutine read_file (self, file, is_fast, form, iostat, iomsg) Read a file as a single string stream. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. logical, intent(in), optional :: is_fast Flag to enable (super) fast file reading. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. private subroutine read_line (self, unit, form, iostat, iomsg) Read line (record) from a connected unit. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. private subroutine read_lines (self, unit, form, iostat, iomsg) Read (all) lines (records) from a connected unit as a single ascii stream. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. private pure subroutine split (self, tokens, sep, max_tokens) Return a list of substring in the string, using sep as the delimiter string. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. integer, intent(in), optional :: max_tokens Fix the maximum number of returned tokens. private pure subroutine split_chunked (self, tokens, chunks, sep) Return a list of substring in the string, using sep as the delimiter string, chunked (memory-efficient) algorithm. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. integer, intent(in) :: chunks Number of chunks. character(kind=CK,len=*), intent(in), optional :: sep Separator. private subroutine write_file (self, file, form, iostat, iomsg) Write a single string stream into file. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. private subroutine write_line (self, unit, form, iostat, iomsg) Write line (record) to a connected unit. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. private subroutine write_lines (self, unit, form, iostat, iomsg) Write lines (records) to a connected unit. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. private pure subroutine string_assign_string (lhs, rhs) Assignment operator from string input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. private pure subroutine string_assign_character (lhs, rhs) Assignment operator from character input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I1P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I2P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I4P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_integer_I8P (lhs, rhs) Assignment operator from integer input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_real_R4P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_real_R8P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. private pure subroutine string_assign_real_R16P (lhs, rhs) Assignment operator from real input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. private subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Formatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. private subroutine read_delimited (dtv, unit, delim, iostat, iomsg) Read a delimited string from a unit connected for formatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. private subroutine read_undelimited_listdirected (dtv, unit, iostat, iomsg) Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. private subroutine read_undelimited (dtv, unit, terminators, iostat, iomsg) Read an undelimited string up until end of record or a character from a set of terminators is encountered. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: terminators Characters that are considered to terminate the string.\nBlanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. private subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Formatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. private subroutine read_unformatted (dtv, unit, iostat, iomsg) Unformatted input. Read more… Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. private subroutine write_unformatted (dtv, unit, iostat, iomsg) Unformatted output. Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. private subroutine get_delimiter_mode (unit, delim, iostat, iomsg) Get the DELIM changeable connection mode for the given unit. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit The unit for the connection. character(kind=CK,len=1), intent(out) :: delim Represents the value of the DELIM mode. integer, intent(out) :: iostat IOSTAT error code, non-zero on error. character, intent(inout) :: iomsg IOMSG explanatory message - only defined if iostat is non-zero. private subroutine get_next_non_blank_character_this_record (unit, ch, iostat, iomsg) Get the next non-blank character in the current record. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. private subroutine get_next_non_blank_character_any_record (unit, ch, iostat, iomsg) Get the next non-blank character, advancing records if necessary. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. private subroutine get_decimal_mode (unit, decimal_point, iostat, iomsg) Get the DECIMAL changeable connection mode for the given unit. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. logical, intent(out) :: decimal_point True if the decimal mode is POINT, false otherwise. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message.","tags":"","loc":"module/stringifor_string_t.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~~UsesGraph program~volatile_doctest volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( acharacter == astring ). eqv .. false .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( acharacter == astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~2~~UsesGraph program~volatile_doctest~2 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~2->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 5 ) astring = 'bar/foo.tar.bz2' test_passed ( 1 ) = astring % basename () // '' == 'foo.tar.bz2' test_passed ( 2 ) = astring % basename ( extension = '.tar.bz2' ) // '' == 'foo' test_passed ( 3 ) = astring % basename ( strip_last_extension = . true .) // '' == 'foo.tar' astring = '\\bar\\foo.tar.bz2' test_passed ( 4 ) = astring % basename ( sep = '\\')//''==' foo . tar . bz2 ' astring = ' bar ' test_passed(5) = astring%basename(strip_last_extension=.true.)//''==' bar ' print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~2.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~3~~UsesGraph program~volatile_doctest~3 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~3->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter >= astring ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter >= astring ). eqv .. true .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( acharacter >= astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~3.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~4~~UsesGraph program~volatile_doctest~4 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~4->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring strings test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) logical :: test_passed ( 1 ) astring = '-1-2-3-4-5-6-7-8-' call astring % split_chunked ( tokens = strings , sep = '-' , chunks = 3 ) test_passed ( 1 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4' . and . & strings ( 5 ) // '' == '5' . and . strings ( 6 ) // '' == '6' . and . strings ( 7 ) // '' == '7' . and . strings ( 8 ) // '' == '8' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~4.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~5~~UsesGraph program~volatile_doctest~5 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~5->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % snakecase () // '' == 'the_quick_brown_fox_jumps_over_the_lazy_dog.' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~5.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~6~~UsesGraph program~volatile_doctest~6 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~6->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring strings test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: strings (3) logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: strings ( 3 ) logical :: test_passed ( 5 ) strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 1 ) = ( astring % join ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) test_passed ( 2 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 3 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free test_passed ( 4 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' test_passed ( 5 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~6.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~7~~UsesGraph program~volatile_doctest~7 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~7->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring strings test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: strings (3) logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: strings ( 3 ) logical :: test_passed ( 3 ) astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~7.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~8~~UsesGraph program~volatile_doctest~8 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~8->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = 'abcdefghilmnopqrstuvz' test_passed ( 1 ) = ( astring % reverse () // '' == 'zvutsrqponmlihgfedcba' ) astring = '0123456789' test_passed ( 2 ) = ( astring % reverse () // '' == '9876543210' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~8.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~9~~UsesGraph program~volatile_doctest~9 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~9->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring strings line iostat iomsg scratch l test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (8) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) call astring % read_lines ( unit = scratch , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo close ( scratch ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~9.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~10~~UsesGraph program~volatile_doctest~10 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~10->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = '  Hello World!   ' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~10.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~11~~UsesGraph program~volatile_doctest~11 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~11->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables string1 test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = scan ( s = 'Hello World Hello!' , set = string1 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = scan ( s = 'Hello World Hello!' , set = string1 , back = . true .) == scan ( string = 'Hello World Hello!' , & set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~11.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~12~~UsesGraph program~volatile_doctest~12 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~12->module~stringifor_string_t penf penf program~volatile_doctest~12->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring real_ test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring real(kind=R16P) :: real_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring real ( R16P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R16P ) test_passed ( 1 ) = real_ == 3.4e9_R16P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~12.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~13~~UsesGraph program~volatile_doctest~13 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~13->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (4) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~13.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~14~~UsesGraph program~volatile_doctest~14 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~14->module~stringifor_string_t penf penf program~volatile_doctest~14->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I8P test_passed ( 1 ) = astring % to_number ( kind = 1_I8P ) == 127_I8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~14.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~15~~UsesGraph program~volatile_doctest~15 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~15->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , adjustl ( astring ) == 'Hello World!   ' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~15.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~16~~UsesGraph program~volatile_doctest~16 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~16->module~stringifor_string_t penf penf program~volatile_doctest~16->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R8P test_passed ( 1 ) = astring % to_number ( kind = 1._R8P ) == 3.021e6_R8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~16.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~17~~UsesGraph program~volatile_doctest~17 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~17->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring anotherstring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = '  one ' anotherstring = 'two' test_passed ( 1 ) = (( astring /= anotherstring ). eqv .. true .) astring = 'the same ' anotherstring = 'the same ' test_passed ( 2 ) = (( astring /= anotherstring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~17.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~18~~UsesGraph program~volatile_doctest~18 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~18->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables string1 string2 test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: string1 type( string ) :: string2 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % index ( substring = string2 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = string2 , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~18.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~19~~UsesGraph program~volatile_doctest~19 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~19->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % trim () == trim ( 'Hello World!   ' ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~19.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~20~~UsesGraph program~volatile_doctest~20 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~20->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 3 ) astring = 'When YOU are sad YOU should think to me :-)' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) astring = repeat ( new_line ( 'a' ) // 'abcd' , 20 ) astring = astring % replace ( old = new_line ( 'a' ), new = '|cr|' ) astring = astring % replace ( old = '|cr|' , new = new_line ( 'a' ) // '    ' ) test_passed ( 3 ) = ( astring // '' == repeat ( new_line ( 'a' ) // '    ' // 'abcd' , 20 )) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~20.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~21~~UsesGraph program~volatile_doctest~21 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~21->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring anotherstring strings line iostat iomsg scratch l test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (8) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) call anotherstring % write_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo call anotherstring % write_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( unit = scratch , status = 'delete' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~21.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~22~~UsesGraph program~volatile_doctest~22 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~22->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 5 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . test_passed ( 2 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . test_passed ( 3 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . test_passed ( 4 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . test_passed ( 5 ) = astring % end_with ( suffix = '!' ). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~22.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~23~~UsesGraph program~volatile_doctest~23 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~23->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter > astring ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter > astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~23.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~24~~UsesGraph program~volatile_doctest~24 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~24->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (7) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 7 ) astring = '   -1212112 ' test_passed ( 1 ) = astring % is_number (). eqv .. true . astring = '   -121.2112 ' test_passed ( 2 ) = astring % is_number (). eqv .. true . astring = '   -1212112' test_passed ( 3 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . astring = '-12121.12   ' test_passed ( 4 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . astring = '+2e20' test_passed ( 5 ) = astring % is_number (). eqv .. true . astring = ' -2.4E13 ' test_passed ( 6 ) = astring % is_number (). eqv .. true . astring = ' -2 E13 ' test_passed ( 7 ) = astring % is_number (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~24.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~25~~UsesGraph program~volatile_doctest~25 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~25->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 3 ) astring = ' Hello World' test_passed ( 1 ) = astring % is_upper (). eqv .. false . astring = ' HELLO WORLD' test_passed ( 2 ) = astring % is_upper (). eqv .. true . astring = ' hello world' test_passed ( 3 ) = astring % is_upper (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~25.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~26~~UsesGraph program~volatile_doctest~26 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~26->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( acharacter /= astring ). eqv .. true .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( acharacter /= astring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~26.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~27~~UsesGraph program~volatile_doctest~27 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~27->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (6) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 6 ) astring = '   -1212112 ' test_passed ( 1 ) = astring % is_integer (). eqv .. true . astring = '   -1212112' test_passed ( 2 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . astring = '-1212112   ' test_passed ( 3 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . astring = '+2e20' test_passed ( 4 ) = astring % is_integer (). eqv .. true . astring = ' -2E13 ' test_passed ( 5 ) = astring % is_integer (). eqv .. true . astring = ' -2 E13 ' test_passed ( 6 ) = astring % is_integer (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~27.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~28~~UsesGraph program~volatile_doctest~28 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~28->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables string1 test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % index ( substring = 'llo' ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = 'llo' , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~28.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~29~~UsesGraph program~volatile_doctest~29 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~29->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring tmpname test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: tmpname logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: tmpname logical :: test_passed ( 5 ) tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 1 )) test_passed ( 1 ) = . not . test_passed ( 1 ) tmpname = astring % tempname ( is_file = . false .) inquire ( file = tmpname , exist = test_passed ( 2 )) test_passed ( 2 ) = . not . test_passed ( 2 ) tmpname = astring % tempname ( path = './' ) inquire ( file = tmpname , exist = test_passed ( 3 )) test_passed ( 3 ) = . not . test_passed ( 3 ) astring = 'me-' tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 4 )) test_passed ( 4 ) = . not . test_passed ( 4 ) tmpname = astring % tempname ( prefix = 'you-' ) inquire ( file = tmpname , exist = test_passed ( 5 )) test_passed ( 5 ) = . not . test_passed ( 5 ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~29.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~30~~UsesGraph program~volatile_doctest~30 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~30->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring strings line iostat iomsg scratch l test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (9) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 9 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) call astring % read_file ( file = 'read_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat ) test_passed ( 9 ) = ( iostat /= 0 ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~30.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~31~~UsesGraph program~volatile_doctest~31 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~31->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (6) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 6 ) astring = '   -1212112.d0 ' test_passed ( 1 ) = astring % is_real (). eqv .. true . astring = '   -1212112.d0' test_passed ( 2 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . astring = '-1212112.d0   ' test_passed ( 3 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . astring = '+2.e20' test_passed ( 4 ) = astring % is_real (). eqv .. true . astring = ' -2.01E13 ' test_passed ( 5 ) = astring % is_real (). eqv .. true . astring = ' -2.01 E13 ' test_passed ( 6 ) = astring % is_real (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~31.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~32~~UsesGraph program~volatile_doctest~32 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~32->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring anotherstring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 3 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring <= anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring <= anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'ONE' test_passed ( 3 ) = (( astring <= anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~32.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~33~~UsesGraph program~volatile_doctest~33 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~33->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring anotherstring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 1 ) astring = 'Hello ' anotherstring = 'Bye bye' test_passed ( 1 ) = astring // anotherstring == 'Hello Bye bye' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~33.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~34~~UsesGraph program~volatile_doctest~34 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~34->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring < acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring < acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~34.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~35~~UsesGraph program~volatile_doctest~35 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~35->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' test_passed ( 1 ) = acharacter // astring == 'World!Hello ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~35.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~36~~UsesGraph program~volatile_doctest~36 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~36->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'caMeL caSe var' print '(L1)' , astring % camelcase () // '' == 'CamelCaseVar' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~36.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~37~~UsesGraph program~volatile_doctest~37 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~37->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables string1 test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (4) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 4 ) string1 = '/bar/foo.tar.bz2' test_passed ( 1 ) = string1 % basedir () // '' == '/bar' string1 = './bar/foo.tar.bz2' test_passed ( 2 ) = string1 % basedir () // '' == './bar' string1 = 'bar/foo.tar.bz2' test_passed ( 3 ) = string1 % basedir () // '' == 'bar' string1 = '\\bar\\foo.tar.bz2' test_passed ( 4 ) = string1 % basedir ( sep = '\\')//''==' \\ bar ' print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~37.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~38~~UsesGraph program~volatile_doctest~38 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~38->module~stringifor_string_t penf penf program~volatile_doctest~38->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R8P test_passed ( 1 ) = astring % to_number ( kind = 1._R8P ) == 3.021e6_R8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~38.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~39~~UsesGraph program~volatile_doctest~39 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~39->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter < astring ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter < astring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~39.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~40~~UsesGraph program~volatile_doctest~40 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~40->module~stringifor_string_t penf penf program~volatile_doctest~40->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring integer_ test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring integer(kind=I1P) :: integer_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I1P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I1P ) test_passed ( 1 ) = integer_ == 127_I1P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~40.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~41~~UsesGraph program~volatile_doctest~41 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~41->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring anotherstring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 1 ) astring = 'hello' anotherstring = astring test_passed ( 1 ) = astring % chars () == anotherstring % chars () print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~41.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~42~~UsesGraph program~volatile_doctest~42 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~42->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = '+++ab-++cre-++cre-ab+++++' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~42.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~43~~UsesGraph program~volatile_doctest~43 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~43->module~stringifor_string_t penf penf program~volatile_doctest~43->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring integer_ test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring integer(kind=I2P) :: integer_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I2P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I2P ) test_passed ( 1 ) = integer_ == 127_I2P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~43.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~44~~UsesGraph program~volatile_doctest~44 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~44->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len () == len ( 'Hello World!   ' ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~44.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~45~~UsesGraph program~volatile_doctest~45 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~45->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 5 ) astring = 'this is string example wow!!!' acharacter = '... ' test_passed ( 1 ) = astring % insert ( substring = acharacter , pos = 1 ) // '' == '... this is string example wow!!!' test_passed ( 2 ) = astring % insert ( substring = acharacter , pos = 23 ) // '' == 'this is string example...  wow!!!' test_passed ( 3 ) = astring % insert ( substring = acharacter , pos = 29 ) // '' == 'this is string example wow!!!... ' test_passed ( 4 ) = astring % insert ( substring = acharacter , pos =- 1 ) // '' == '... this is string example wow!!!' test_passed ( 5 ) = astring % insert ( substring = acharacter , pos = 100 ) // '' == 'this is string example wow!!!... ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~45.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~46~~UsesGraph program~volatile_doctest~46 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~46->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , astring % adjustl () // '' == 'Hello World!   ' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~46.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~47~~UsesGraph program~volatile_doctest~47 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~47->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'SG93IGFyZSB5b3U/' print '(L1)' , astring % decode ( codec = 'base64' ) // '' == 'How are you?' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~47.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~48~~UsesGraph program~volatile_doctest~48 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~48->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (4) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'this is string example....wow!!!' test_passed ( 1 ) = astring % fill ( width = 40 ) // '' == '00000000this is string example....wow!!!' test_passed ( 2 ) = astring % fill ( width = 50 ) // '' == '000000000000000000this is string example....wow!!!' test_passed ( 3 ) = astring % fill ( width = 50 , right = . true .) // '' == 'this is string example....wow!!!000000000000000000' test_passed ( 4 ) = astring % fill ( width = 40 , filling_char = '*' ) // '' == '********this is string example....wow!!!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~48.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~49~~UsesGraph program~volatile_doctest~49 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~49->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Source Code volatile_doctest Source Code program volatile_doctest use stringifor_string_t print \"(L1)\" , string ( 'Hello World' ) // '' == 'Hello World' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~49.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~50~~UsesGraph program~volatile_doctest~50 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~50->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring <= acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring <= acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( astring <= acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~50.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~51~~UsesGraph program~volatile_doctest~51 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~51->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring alist_chr Nf files file_unit f ff test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: alist_chr (:) integer, parameter :: Nf = 5 character(len=14) :: files (1:Nf) integer :: file_unit integer :: f integer :: ff logical :: test_passed Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_chr ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr print '(L1)' , test_passed endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~51.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~52~~UsesGraph program~volatile_doctest~52 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~52->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring anotherstring acharacter istart iend test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring character(len=:), allocatable :: acharacter integer :: istart integer :: iend logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring character ( len = :), allocatable :: acharacter integer :: istart integer :: iend logical :: test_passed ( 5 ) astring = '<test> <first> hello </first> <first> not the first </first> </test>' anotherstring = astring % search ( tag_start = '<first>' , tag_end = '</first>' ) test_passed ( 1 ) = anotherstring // '' == '<first> hello </first>' astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' anotherstring = astring % search ( tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 2 ) = anotherstring // '' == '<a> <a> <a> the nested a </a> </a> </a>' call astring % free anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_string = anotherstring , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 3 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' call astring % free acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 4 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<sec>' , tag_end = '</sec>' , istart = istart , iend = iend ) test_passed ( 5 ) = astring // '' == acharacter ( 31 : 67 ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~52.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~53~~UsesGraph program~volatile_doctest~53 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~53->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~volatile_doctest~53~~CallsGraph program~volatile_doctest~53 volatile_doctest interface~glob glob program~volatile_doctest~53->interface~glob proc~glob_character glob_character interface~glob->proc~glob_character proc~glob_string glob_string interface~glob->proc~glob_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables astring alist_chr alist_str Nf files file_unit f ff test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: alist_chr (:) type( string ), allocatable :: alist_str (:) integer, parameter :: Nf = 5 character(len=14) :: files (1:Nf) integer :: file_unit integer :: f integer :: ff logical :: test_passed Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call glob ( self = astring , pattern = 'foo-*' , list = alist_chr ) call glob ( self = astring , pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr if ( test_passed ) then test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str endif print '(L1)' , test_passed endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~53.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~54~~UsesGraph program~volatile_doctest~54 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~54->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'hello' test_passed ( 1 ) = astring % chars () == 'hello' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~54.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~55~~UsesGraph program~volatile_doctest~55 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~55->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( astring /= acharacter ). eqv .. true .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( astring /= acharacter ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~55.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~56~~UsesGraph program~volatile_doctest~56 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~56->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = '  Hello World!   ' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~56.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~57~~UsesGraph program~volatile_doctest~57 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~57->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables string1 test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'ell' test_passed ( 1 ) = verify ( s = 'Hello World Hello!' , set = string1 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = verify ( s = 'Hello World Hello!' , set = string1 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~57.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~58~~UsesGraph program~volatile_doctest~58 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~58->module~stringifor_string_t penf penf program~volatile_doctest~58->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring integer_ test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring integer(kind=I8P) :: integer_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I8P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I8P ) test_passed ( 1 ) = integer_ == 127_I8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~58.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~59~~UsesGraph program~volatile_doctest~59 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~59->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring > acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring > acharacter ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~59.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~60~~UsesGraph program~volatile_doctest~60 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~60->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables string1 test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = index ( s = 'Hello World Hello!' , substring = string1 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = index ( s = 'Hello World Hello!' , substring = string1 , back = . true .) == index ( string = 'Hello World Hello!' , & substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~60.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~61~~UsesGraph program~volatile_doctest~61 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~61->module~stringifor_string_t penf penf program~volatile_doctest~61->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring real_ test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring real(kind=R4P) :: real_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring real ( R4P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R4P ) test_passed ( 1 ) = real_ == 3.4e9_R4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~61.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~62~~UsesGraph program~volatile_doctest~62 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~62->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter <= astring ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter <= astring ). eqv .. false .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( acharacter <= astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~62.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~63~~UsesGraph program~volatile_doctest~63 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~63->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 3 ) astring = ' Hello World' test_passed ( 1 ) = astring % is_lower (). eqv .. false . astring = ' HELLO WORLD' test_passed ( 2 ) = astring % is_lower (). eqv .. false . astring = ' hello world' test_passed ( 3 ) = astring % is_lower (). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~63.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~64~~UsesGraph program~volatile_doctest~64 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~64->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'How are you?' print '(L1)' , astring % encode ( codec = 'base64' ) // '' == 'SG93IGFyZSB5b3U/' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~64.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~65~~UsesGraph program~volatile_doctest~65 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~65->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % capitalize () // '' == 'Say all hello world!' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~65.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~66~~UsesGraph program~volatile_doctest~66 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~66->module~stringifor_string_t penf penf program~volatile_doctest~66->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I2P test_passed ( 1 ) = astring % to_number ( kind = 1_I2P ) == 127_I2P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~66.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~67~~UsesGraph program~volatile_doctest~67 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~67->module~stringifor_string_t penf penf program~volatile_doctest~67->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I1P test_passed ( 1 ) = astring % to_number ( kind = 1_I1P ) == 127_I1P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~67.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~68~~UsesGraph program~volatile_doctest~68 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~68->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % chars () == 'say all Hello WorLD!' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~68.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~69~~UsesGraph program~volatile_doctest~69 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~69->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables string1 test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % verify ( set = 'llo' ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = 'llo' , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~69.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~70~~UsesGraph program~volatile_doctest~70 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~70->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring anotherstring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = '  one ' anotherstring = 'two' test_passed ( 1 ) = (( astring == anotherstring ). eqv .. false .) astring = 'the same ' anotherstring = 'the same ' test_passed ( 2 ) = (( astring == anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~70.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~71~~UsesGraph program~volatile_doctest~71 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~71->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = '&#94;\\\\s \\\\d+\\\\s*' test_passed ( 1 ) = ( astring % unescape ( to_unescape = '\\')//''==' &#94;\\ s \\ d + \\ s * ') test_passed(2) = (astring%unescape(to_unescape=' s ')//''==' &#94;\\ s \\\\ d + \\ s * ') print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~71.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~72~~UsesGraph program~volatile_doctest~72 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~72->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~72.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~73~~UsesGraph program~volatile_doctest~73 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~73->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables string1 test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: string1 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % scan ( set = 'llo' ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = 'llo' , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~73.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~74~~UsesGraph program~volatile_doctest~74 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~74->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'y' print \"(L1)\" , astring % repeat ( 'x' , 5 ) // '' == 'xxxxx' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~74.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~75~~UsesGraph program~volatile_doctest~75 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~75->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' test_passed ( 1 ) = astring // acharacter == 'Hello World!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~75.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~76~~UsesGraph program~volatile_doctest~76 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~76->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( astring == acharacter ). eqv .. false .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( astring == acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~76.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~77~~UsesGraph program~volatile_doctest~77 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~77->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % adjustr () // '' == '   Hello World!' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~77.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~78~~UsesGraph program~volatile_doctest~78 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~78->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'x' print \"(L1)\" , astring % repeat ( 5 ) // '' == 'xxxxx' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~78.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~79~~UsesGraph program~volatile_doctest~79 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~79->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring characters test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=5) :: characters (3) logical :: test_passed (6) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( 5 ) :: characters ( 3 ) logical :: test_passed ( 6 ) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 1 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) test_passed ( 2 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 3 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 4 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 5 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' astring = '_' test_passed ( 6 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // '_' // characters ( 2 ) // '_' // characters ( 3 )) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~79.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~80~~UsesGraph program~volatile_doctest~80 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~80->module~stringifor_string_t penf penf program~volatile_doctest~80->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring integer_ test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring integer(kind=I4P) :: integer_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I4P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I4P ) test_passed ( 1 ) = integer_ == 127_I4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~80.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~81~~UsesGraph program~volatile_doctest~81 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~81->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring alist_str Nf files file_unit f ff test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: alist_str (:) integer, parameter :: Nf = 5 character(len=14) :: files (1:Nf) integer :: file_unit integer :: f integer :: ff logical :: test_passed Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str print '(L1)' , test_passed endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~81.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~82~~UsesGraph program~volatile_doctest~82 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~82->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'the Quick Brown fox Jumps over the Lazy Dog.' print \"(A)\" , astring % slice ( 11 , 25 ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~82.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~83~~UsesGraph program~volatile_doctest~83 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~83->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~83.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~84~~UsesGraph program~volatile_doctest~84 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~84->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % startcase () // '' == 'The Quick Brown Fox Jumps Over The Lazy Dog.' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~84.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~85~~UsesGraph program~volatile_doctest~85 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~85->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = '/bar/foo.tar.bz2' print '(L1)' , astring % extension () // '' == '.bz2' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~85.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~86~~UsesGraph program~volatile_doctest~86 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~86->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring character(len=:), allocatable :: acharacter logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring >= acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring >= acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( astring >= acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~86.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~87~~UsesGraph program~volatile_doctest~87 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~87->module~stringifor_string_t penf penf program~volatile_doctest~87->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R4P test_passed ( 1 ) = astring % to_number ( kind = 1._R4P ) == 3.021e6_R4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~87.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~88~~UsesGraph program~volatile_doctest~88 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~88->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring anotherstring yetanotherstring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring type( string ) :: yetanotherstring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring type ( string ) :: yetanotherstring logical :: test_passed ( 1 ) astring = 'Hello ' anotherstring = 'Bye bye' yetanotherstring = astring . cat . anotherstring test_passed ( 1 ) = yetanotherstring % chars () == 'Hello Bye bye' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~88.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~89~~UsesGraph program~volatile_doctest~89 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~89->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring yetanotherstring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: yetanotherstring character(len=:), allocatable :: acharacter logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: yetanotherstring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' yetanotherstring = astring . cat . acharacter test_passed ( 1 ) = yetanotherstring % chars () == 'Hello World!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~89.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~90~~UsesGraph program~volatile_doctest~90 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~90->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'this is string example....wow!!!' call astring % free print '(L1)' , astring % is_allocated (). eqv .. false . endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~90.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~91~~UsesGraph program~volatile_doctest~91 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~91->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring strings test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) logical :: test_passed (11) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) logical :: test_passed ( 11 ) astring = '+ab-++cre-++cre-ab+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'ab-++cre-++cre-ab+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'ab-++cre-++cre-ab' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'Hello ' // new_line ( 'a' ) // 'World!' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) astring = 'Hello World!' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) astring = '+ab-' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 6 ) = ( strings ( 1 ) // '' == 'ab-' ) astring = '+ab-' call astring % split ( tokens = strings , sep = '-' ) test_passed ( 7 ) = ( strings ( 1 ) // '' == '+ab' ) astring = '+ab-+cd-' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 8 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = 'ab-+cd-+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 9 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = '+ab-+cd-+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 10 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = '1-2-3-4-5-6-7-8' call astring % split ( tokens = strings , sep = '-' , max_tokens = 3 ) test_passed ( 11 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4-5-6-7-8' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~91.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~92~~UsesGraph program~volatile_doctest~92 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~92->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (4) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 4 ) astring = '   Hello World  !    ' test_passed ( 1 ) = astring % count ( substring = ' ' ) == 10 astring = 'Hello World  !    ' test_passed ( 2 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 6 astring = '    Hello World  !' test_passed ( 3 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 6 astring = '   Hello World  !    ' test_passed ( 4 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 8 print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~92.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~93~~UsesGraph program~volatile_doctest~93 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~93->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len_trim () == len_trim ( 'Hello World!   ' ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~93.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~94~~UsesGraph program~volatile_doctest~94 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~94->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) test_passed ( 1 ) = astring % is_allocated (). eqv .. false . astring = 'hello' test_passed ( 2 ) = astring % is_allocated (). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~94.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~95~~UsesGraph program~volatile_doctest~95 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~95->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring yetanotherstring acharacter test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: yetanotherstring character(len=:), allocatable :: acharacter logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: yetanotherstring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' yetanotherstring = acharacter . cat . astring test_passed ( 1 ) = yetanotherstring % chars () == 'World!Hello ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~95.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~96~~UsesGraph program~volatile_doctest~96 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~96->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring line iostat iomsg scratch l test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (6) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 6 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then exit else test_passed ( l ) = ( astring == line ( l )) endif enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg , form = 'UnfORMatteD' ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then exit else test_passed ( l + 3 ) = ( astring == line ( l )) endif enddo close ( scratch ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~96.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~97~~UsesGraph program~volatile_doctest~97 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~97->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % lower () // '' == 'hello world!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~97.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~98~~UsesGraph program~volatile_doctest~98 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~98->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = '&#94;\\s \\d+\\s*' test_passed ( 1 ) = astring % escape ( to_escape = '\\')//''==' &#94;\\\\ s \\\\ d + \\\\ s * ' test_passed(2) = astring%escape(to_escape=' \\ ', esc=' | ')//''==' &#94;|\\ s |\\ d + |\\ s * ' print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~98.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~99~~UsesGraph program~volatile_doctest~99 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~99->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables string1 string2 test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: string1 type( string ) :: string2 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % scan ( set = string2 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = string2 , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~99.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~100~~UsesGraph program~volatile_doctest~100 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~100->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , adjustr ( astring ) == '   Hello World!' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~100.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~101~~UsesGraph program~volatile_doctest~101 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~101->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring anotherstring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (3) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 3 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring >= anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring >= anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'ONE' test_passed ( 3 ) = (( astring >= anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~101.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~102~~UsesGraph program~volatile_doctest~102 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~102->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % colorize ( color_fg = 'red' ) == '\u001b[31msay all Hello WorLD!\u001b[0m' endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~102.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~103~~UsesGraph program~volatile_doctest~103 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~103->module~stringifor_string_t penf penf program~volatile_doctest~103->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I4P test_passed ( 1 ) = astring % to_number ( kind = 1_I4P ) == 127_I4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~103.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~104~~UsesGraph program~volatile_doctest~104 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~104->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring anotherstring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring < anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring < anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~104.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~105~~UsesGraph program~volatile_doctest~105 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~105->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables string1 string2 test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: string1 type( string ) :: string2 logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % verify ( set = string2 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = string2 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~105.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~106~~UsesGraph program~volatile_doctest~106 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~106->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring anotherstring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (2) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring > anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring > anotherstring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~106.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~107~~UsesGraph program~volatile_doctest~107 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~107->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Source Code volatile_doctest Source Code program volatile_doctest use stringifor_string_t print \"(L1)\" , count ( 'hello' , substring = 'll' ) == 1 endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~107.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t penf program~~volatile_doctest~108~~UsesGraph program~volatile_doctest~108 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~108->module~stringifor_string_t penf penf program~volatile_doctest~108->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring real_ test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring real(kind=R8P) :: real_ logical :: test_passed (1) Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring real ( R8P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R8P ) test_passed ( 1 ) = real_ == 3.4e9_R8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~108.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor_string_t program~~volatile_doctest~109~~UsesGraph program~volatile_doctest~109 volatile_doctest module~stringifor_string_t stringifor_string_t program~volatile_doctest~109->module~stringifor_string_t iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 penf penf module~stringifor_string_t->penf face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables astring anotherstring test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring logical :: test_passed (5) Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 5 ) astring = 'this is string example wow!!!' anotherstring = '... ' test_passed ( 1 ) = astring % insert ( substring = anotherstring , pos = 1 ) // '' == '... this is string example wow!!!' test_passed ( 2 ) = astring % insert ( substring = anotherstring , pos = 23 ) // '' == 'this is string example...  wow!!!' test_passed ( 3 ) = astring % insert ( substring = anotherstring , pos = 29 ) // '' == 'this is string example wow!!!... ' test_passed ( 4 ) = astring % insert ( substring = anotherstring , pos =- 1 ) // '' == '... this is string example wow!!!' test_passed ( 5 ) = astring % insert ( substring = anotherstring , pos = 100 ) // '' == 'this is string example wow!!!... ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~109.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor program~~volatile_doctest~110~~UsesGraph program~volatile_doctest~110 volatile_doctest module~stringifor stringifor program~volatile_doctest~110->module~stringifor module~stringifor_string_t stringifor_string_t module~stringifor->module~stringifor_string_t penf penf module~stringifor->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~volatile_doctest~110~~CallsGraph program~volatile_doctest~110 volatile_doctest proc~write_file write_file program~volatile_doctest~110->proc~write_file proc~write_lines write_lines proc~write_file->proc~write_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables astring anotherstring strings line iostat iomsg scratch l test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ) :: anotherstring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (8) Source Code program volatile_doctest use stringifor type ( string ) :: astring type ( string ) :: anotherstring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) call write_file ( file = 'write_file_test.tmp' , lines = line , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo call write_file ( file = 'write_file_test.tmp' , lines = line , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( scratch , status = 'DELETE' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~110.html"},{"title":"stringifor_test_parse_large_csv – StringiFor","text":"Uses stringifor program~~stringifor_test_parse_large_csv~~UsesGraph program~stringifor_test_parse_large_csv stringifor_test_parse_large_csv module~stringifor stringifor program~stringifor_test_parse_large_csv->module~stringifor module~stringifor_string_t stringifor_string_t module~stringifor->module~stringifor_string_t penf penf module~stringifor->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. StringiFor csv_naive_parser test. Contents Variables csv rows columns cells rows_number columns_number c r test_passed Source Code stringifor_test_parse_large_csv Variables Type Attributes Name Initial type( string ) :: csv The CSV file as a single stream. type( string ), allocatable :: rows (:) The CSV table rows. type( string ), allocatable :: columns (:) The CSV table columns. type( string ), allocatable :: cells (:,:) The CSV table cells. integer :: rows_number The CSV file rows number. integer :: columns_number The CSV file columns number. integer :: c Counter. integer :: r Counter. logical :: test_passed (1) List of passed tests. Source Code program stringifor_test_parse_large_csv !< StringiFor `csv_naive_parser` test. use stringifor implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: c , r !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . call csv % read_file ( file = 'src/tests/stringifor/stringifor_test_parse_large_csv.csv' , is_fast = . true .) call csv % split_chunked ( tokens = rows , sep = new_line ( 'a' ), chunks = 10 ) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' do c = 1 , columns_number columns ( c ) = '----' ! re-use columns for printing separators enddo print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' test_passed = . true . print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram stringifor_test_parse_large_csv","tags":"","loc":"program/stringifor_test_parse_large_csv.html"},{"title":"volatile_doctest – StringiFor","text":"Uses stringifor program~~volatile_doctest~111~~UsesGraph program~volatile_doctest~111 volatile_doctest module~stringifor stringifor program~volatile_doctest~111->module~stringifor module~stringifor_string_t stringifor_string_t module~stringifor->module~stringifor_string_t penf penf module~stringifor->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~volatile_doctest~111~~CallsGraph program~volatile_doctest~111 volatile_doctest proc~read_file read_file program~volatile_doctest~111->proc~read_file proc~read_lines read_lines proc~read_file->proc~read_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables astring strings line iostat iomsg scratch l test_passed Source Code volatile_doctest Variables Type Attributes Name Initial type( string ) :: astring type( string ), allocatable :: strings (:) type( string ) :: line (3) integer :: iostat character(len=99) :: iomsg integer :: scratch integer :: l logical :: test_passed (8) Source Code program volatile_doctest use stringifor type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) call read_file ( file = 'read_file_test.tmp' , lines = strings , iostat = iostat , iomsg = iomsg ) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) call read_file ( file = 'read_file_test.tmp' , lines = strings , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"program/volatile_doctest~111.html"},{"title":"stringifor_test_csv_naive_parser – StringiFor","text":"Uses stringifor program~~stringifor_test_csv_naive_parser~~UsesGraph program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser module~stringifor stringifor program~stringifor_test_csv_naive_parser->module~stringifor module~stringifor_string_t stringifor_string_t module~stringifor->module~stringifor_string_t penf penf module~stringifor->penf module~stringifor_string_t->penf iso_fortran_env iso_fortran_env module~stringifor_string_t->iso_fortran_env befor64 befor64 module~stringifor_string_t->befor64 face face module~stringifor_string_t->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. StringiFor csv naive parser test. This is an example of the usefulness of StringiFor. Calls program~~stringifor_test_csv_naive_parser~~CallsGraph program~stringifor_test_csv_naive_parser stringifor_test_csv_naive_parser proc~write_file write_file program~stringifor_test_csv_naive_parser->proc~write_file proc~write_lines write_lines proc~write_file->proc~write_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables csv rows columns cells lines most_expensive highest_cost rows_number columns_number c r test_passed Source Code stringifor_test_csv_naive_parser Variables Type Attributes Name Initial type( string ) :: csv The CSV file as a single stream. type( string ), allocatable :: rows (:) The CSV table rows. type( string ), allocatable :: columns (:) The CSV table columns. type( string ), allocatable :: cells (:,:) The CSV table cells. type( string ) :: lines (4) The CSV file lines. type( string ) :: most_expensive The most expensive car. real(kind=R8P) :: highest_cost The highest cost. integer :: rows_number The CSV file rows number. integer :: columns_number The CSV file columns number. integer :: c Counter. integer :: r Counter. logical :: test_passed (1) List of passed tests. Source Code program stringifor_test_csv_naive_parser !< StringiFor *csv naive parser* test. !< !< This is an example of the usefulness of StringiFor. use stringifor implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. type ( string ) :: lines ( 4 ) !< The CSV file lines. type ( string ) :: most_expensive !< The most expensive car. real ( R8P ) :: highest_cost !< The highest cost. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: c , r !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . ! a cars database lines ( 1 ) = 'Year,Make,Model,Description,Price' lines ( 2 ) = '1997,Ford,E350,ac abs moon,3000.00' lines ( 3 ) = '1999,Chevy,Venture \"Extended Edition\", ,4900.00' lines ( 4 ) = '1999,Chevy,Venture \"Extended Edition Very Large\", ,5000.00' ! preparing a CSV file test call write_file ( file = 'file_test_temp.csv' , lines = lines ) ! parsing the just created CSV file call csv % read_file ( file = 'file_test_temp.csv' ) ! read the CSV file as a single stream call csv % split ( tokens = rows , sep = new_line ( 'a' )) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! eliminating the file open ( newunit = r , file = 'file_test_temp.csv' ) ; close ( unit = r , status = 'DELETE' ) ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' do c = 1 , columns_number columns ( c ) = '----' ! re-use columns for printing separators enddo print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' ! find the most expensive car print \"(A)\" , 'Searching for the most expensive car' most_expensive = 'unknown' highest_cost = - 1._R8P do r = 2 , rows_number if ( cells ( 5 , r )% to_number ( kind = 1._R8P ) >= highest_cost ) then highest_cost = cells ( 5 , r )% to_number ( kind = 1._R8P ) most_expensive = csv % join ( array = [ cells ( 2 , r ), cells ( 3 , r )], sep = ' ' ) endif enddo test_passed ( 1 ) = most_expensive // '' == 'Chevy Venture \"Extended Edition Very Large\"' print \"(A,L1)\" , 'The most expensive car is : ' // most_expensive // ', is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram stringifor_test_csv_naive_parser","tags":"","loc":"program/stringifor_test_csv_naive_parser.html"},{"title":"stringifor_string_t-doctest-94.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-94.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-94.f90 stringifor_string_t-doctest-94.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-94.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-94.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( acharacter == astring ). eqv .. false .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( acharacter == astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-94.f90.html"},{"title":"stringifor_string_t-doctest-24.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-24.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-24.f90 stringifor_string_t-doctest-24.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-24.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-24.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 5 ) astring = 'bar/foo.tar.bz2' test_passed ( 1 ) = astring % basename () // '' == 'foo.tar.bz2' test_passed ( 2 ) = astring % basename ( extension = '.tar.bz2' ) // '' == 'foo' test_passed ( 3 ) = astring % basename ( strip_last_extension = . true .) // '' == 'foo.tar' astring = '\\bar\\foo.tar.bz2' test_passed ( 4 ) = astring % basename ( sep = '\\')//''==' foo . tar . bz2 ' astring = ' bar ' test_passed(5) = astring%basename(strip_last_extension=.true.)//''==' bar ' print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-24.f90.html"},{"title":"stringifor_string_t-doctest-106.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-106.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-106.f90 stringifor_string_t-doctest-106.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-106.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-106.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter >= astring ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter >= astring ). eqv .. true .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( acharacter >= astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-106.f90.html"},{"title":"stringifor_string_t-doctest-52.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-52.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-52.f90 stringifor_string_t-doctest-52.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-52.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-52.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) logical :: test_passed ( 1 ) astring = '-1-2-3-4-5-6-7-8-' call astring % split_chunked ( tokens = strings , sep = '-' , chunks = 3 ) test_passed ( 1 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4' . and . & strings ( 5 ) // '' == '5' . and . strings ( 6 ) // '' == '6' . and . strings ( 7 ) // '' == '7' . and . strings ( 8 ) // '' == '8' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-52.f90.html"},{"title":"stringifor_string_t-doctest-50.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-50.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-50.f90 stringifor_string_t-doctest-50.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-50.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-50.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % snakecase () // '' == 'the_quick_brown_fox_jumps_over_the_lazy_dog.' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-50.f90.html"},{"title":"stringifor_string_t-doctest-39.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-39.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-39.f90 stringifor_string_t-doctest-39.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-39.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-39.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: strings ( 3 ) logical :: test_passed ( 5 ) strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 1 ) = ( astring % join ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) test_passed ( 2 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' test_passed ( 3 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free test_passed ( 4 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' test_passed ( 5 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-39.f90.html"},{"title":"stringifor_string_t-doctest-42.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-42.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-42.f90 stringifor_string_t-doctest-42.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-42.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-42.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: strings ( 3 ) logical :: test_passed ( 3 ) astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-42.f90.html"},{"title":"stringifor_string_t-doctest-47.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-47.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-47.f90 stringifor_string_t-doctest-47.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-47.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-47.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = 'abcdefghilmnopqrstuvz' test_passed ( 1 ) = ( astring % reverse () // '' == 'zvutsrqponmlihgfedcba' ) astring = '0123456789' test_passed ( 2 ) = ( astring % reverse () // '' == '9876543210' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-47.f90.html"},{"title":"stringifor_string_t-doctest-45.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-45.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-45.f90 stringifor_string_t-doctest-45.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-45.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-45.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) call astring % read_lines ( unit = scratch , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo close ( scratch ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-45.f90.html"},{"title":"stringifor_string_t-doctest-54.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-54.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-54.f90 stringifor_string_t-doctest-54.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-54.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-54.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = '  Hello World!   ' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-54.f90.html"},{"title":"stringifor_string_t-doctest-7.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-7.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-7.f90 stringifor_string_t-doctest-7.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-7.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-7.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = scan ( s = 'Hello World Hello!' , set = string1 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = scan ( s = 'Hello World Hello!' , set = string1 , back = . true .) == scan ( string = 'Hello World Hello!' , & set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-7.f90.html"},{"title":"stringifor_string_t-doctest-63.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-63.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-63.f90 stringifor_string_t-doctest-63.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-63.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-63.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring real ( R16P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R16P ) test_passed ( 1 ) = real_ == 3.4e9_R16P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-63.f90.html"},{"title":"stringifor_string_t-doctest-76.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-76.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-76.f90 stringifor_string_t-doctest-76.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-76.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-76.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-76.f90.html"},{"title":"stringifor_string_t-doctest-82.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-82.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-82.f90 stringifor_string_t-doctest-82.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-82.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-82.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I8P test_passed ( 1 ) = astring % to_number ( kind = 1_I8P ) == 127_I8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-82.f90.html"},{"title":"stringifor_string_t-doctest-3.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-3.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-3.f90 stringifor_string_t-doctest-3.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-3.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-3.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , adjustl ( astring ) == 'Hello World!   ' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-3.f90.html"},{"title":"stringifor_string_t-doctest-85.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-85.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-85.f90 stringifor_string_t-doctest-85.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-85.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-85.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R8P test_passed ( 1 ) = astring % to_number ( kind = 1._R8P ) == 3.021e6_R8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-85.f90.html"},{"title":"stringifor_string_t-doctest-95.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-95.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-95.f90 stringifor_string_t-doctest-95.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-95.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-95.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = '  one ' anotherstring = 'two' test_passed ( 1 ) = (( astring /= anotherstring ). eqv .. true .) astring = 'the same ' anotherstring = 'the same ' test_passed ( 2 ) = (( astring /= anotherstring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-95.f90.html"},{"title":"stringifor_string_t-doctest-12.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-12.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-12.f90 stringifor_string_t-doctest-12.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-12.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-12.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % index ( substring = string2 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = string2 , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-12.f90.html"},{"title":"stringifor_string_t-doctest-20.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-20.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-20.f90 stringifor_string_t-doctest-20.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-20.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-20.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % trim () == trim ( 'Hello World!   ' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-20.f90.html"},{"title":"stringifor_string_t-doctest-46.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-46.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-46.f90 stringifor_string_t-doctest-46.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-46.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-46.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 3 ) astring = 'When YOU are sad YOU should think to me :-)' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) astring = repeat ( new_line ( 'a' ) // 'abcd' , 20 ) astring = astring % replace ( old = new_line ( 'a' ), new = '|cr|' ) astring = astring % replace ( old = '|cr|' , new = new_line ( 'a' ) // '    ' ) test_passed ( 3 ) = ( astring // '' == repeat ( new_line ( 'a' ) // '    ' // 'abcd' , 20 )) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-46.f90.html"},{"title":"stringifor_string_t-doctest-67.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-67.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-67.f90 stringifor_string_t-doctest-67.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-67.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-67.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) call anotherstring % write_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo call anotherstring % write_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( unit = scratch , status = 'delete' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-67.f90.html"},{"title":"stringifor_string_t-doctest-68.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-68.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-68.f90 stringifor_string_t-doctest-68.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-68.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-68.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 5 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . test_passed ( 2 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . test_passed ( 3 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . test_passed ( 4 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . test_passed ( 5 ) = astring % end_with ( suffix = '!' ). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-68.f90.html"},{"title":"stringifor_string_t-doctest-109.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-109.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-109.f90 stringifor_string_t-doctest-109.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-109.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-109.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter > astring ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter > astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-109.f90.html"},{"title":"stringifor_string_t-doctest-73.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-73.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-73.f90 stringifor_string_t-doctest-73.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-73.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-73.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 7 ) astring = '   -1212112 ' test_passed ( 1 ) = astring % is_number (). eqv .. true . astring = '   -121.2112 ' test_passed ( 2 ) = astring % is_number (). eqv .. true . astring = '   -1212112' test_passed ( 3 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . astring = '-12121.12   ' test_passed ( 4 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . astring = '+2e20' test_passed ( 5 ) = astring % is_number (). eqv .. true . astring = ' -2.4E13 ' test_passed ( 6 ) = astring % is_number (). eqv .. true . astring = ' -2 E13 ' test_passed ( 7 ) = astring % is_number (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-73.f90.html"},{"title":"stringifor_string_t-doctest-75.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-75.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-75.f90 stringifor_string_t-doctest-75.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-75.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-75.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 3 ) astring = ' Hello World' test_passed ( 1 ) = astring % is_upper (). eqv .. false . astring = ' HELLO WORLD' test_passed ( 2 ) = astring % is_upper (). eqv .. true . astring = ' hello world' test_passed ( 3 ) = astring % is_upper (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-75.f90.html"},{"title":"stringifor_string_t-doctest-97.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-97.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-97.f90 stringifor_string_t-doctest-97.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-97.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-97.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( acharacter /= astring ). eqv .. true .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( acharacter /= astring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-97.f90.html"},{"title":"stringifor_string_t-doctest-71.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-71.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-71.f90 stringifor_string_t-doctest-71.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-71.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-71.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 6 ) astring = '   -1212112 ' test_passed ( 1 ) = astring % is_integer (). eqv .. true . astring = '   -1212112' test_passed ( 2 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . astring = '-1212112   ' test_passed ( 3 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . astring = '+2e20' test_passed ( 4 ) = astring % is_integer (). eqv .. true . astring = ' -2E13 ' test_passed ( 5 ) = astring % is_integer (). eqv .. true . astring = ' -2 E13 ' test_passed ( 6 ) = astring % is_integer (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-71.f90.html"},{"title":"stringifor_string_t-doctest-13.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-13.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-13.f90 stringifor_string_t-doctest-13.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-13.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-13.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % index ( substring = 'llo' ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = string1 % index ( substring = 'llo' , back = . true .) == index ( string = 'Hello World Hello!' , substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-13.f90.html"},{"title":"stringifor_string_t-doctest-56.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-56.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-56.f90 stringifor_string_t-doctest-56.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-56.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-56.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: tmpname logical :: test_passed ( 5 ) tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 1 )) test_passed ( 1 ) = . not . test_passed ( 1 ) tmpname = astring % tempname ( is_file = . false .) inquire ( file = tmpname , exist = test_passed ( 2 )) test_passed ( 2 ) = . not . test_passed ( 2 ) tmpname = astring % tempname ( path = './' ) inquire ( file = tmpname , exist = test_passed ( 3 )) test_passed ( 3 ) = . not . test_passed ( 3 ) astring = 'me-' tmpname = astring % tempname () inquire ( file = tmpname , exist = test_passed ( 4 )) test_passed ( 4 ) = . not . test_passed ( 4 ) tmpname = astring % tempname ( prefix = 'you-' ) inquire ( file = tmpname , exist = test_passed ( 5 )) test_passed ( 5 ) = . not . test_passed ( 5 ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-56.f90.html"},{"title":"stringifor_string_t-doctest-43.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-43.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-43.f90 stringifor_string_t-doctest-43.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-43.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-43.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 9 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) call astring % read_file ( file = 'read_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat ) test_passed ( 9 ) = ( iostat /= 0 ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-43.f90.html"},{"title":"stringifor_string_t-doctest-74.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-74.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-74.f90 stringifor_string_t-doctest-74.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-74.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-74.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 6 ) astring = '   -1212112.d0 ' test_passed ( 1 ) = astring % is_real (). eqv .. true . astring = '   -1212112.d0' test_passed ( 2 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . astring = '-1212112.d0   ' test_passed ( 3 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . astring = '+2.e20' test_passed ( 4 ) = astring % is_real (). eqv .. true . astring = ' -2.01E13 ' test_passed ( 5 ) = astring % is_real (). eqv .. true . astring = ' -2.01 E13 ' test_passed ( 6 ) = astring % is_real (). eqv .. false . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-74.f90.html"},{"title":"stringifor_string_t-doctest-101.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-101.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-101.f90 stringifor_string_t-doctest-101.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-101.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-101.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 3 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring <= anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring <= anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'ONE' test_passed ( 3 ) = (( astring <= anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-101.f90.html"},{"title":"stringifor_string_t-doctest-86.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-86.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-86.f90 stringifor_string_t-doctest-86.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-86.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-86.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 1 ) astring = 'Hello ' anotherstring = 'Bye bye' test_passed ( 1 ) = astring // anotherstring == 'Hello Bye bye' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-86.f90.html"},{"title":"stringifor_string_t-doctest-99.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-99.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-99.f90 stringifor_string_t-doctest-99.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-99.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-99.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring < acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring < acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-99.f90.html"},{"title":"stringifor_string_t-doctest-88.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-88.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-88.f90 stringifor_string_t-doctest-88.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-88.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-88.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' test_passed ( 1 ) = acharacter // astring == 'World!Hello ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-88.f90.html"},{"title":"stringifor_string_t-doctest-25.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-25.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-25.f90 stringifor_string_t-doctest-25.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-25.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-25.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'caMeL caSe var' print '(L1)' , astring % camelcase () // '' == 'CamelCaseVar' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-25.f90.html"},{"title":"stringifor_string_t-doctest-23.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-23.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-23.f90 stringifor_string_t-doctest-23.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-23.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-23.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 4 ) string1 = '/bar/foo.tar.bz2' test_passed ( 1 ) = string1 % basedir () // '' == '/bar' string1 = './bar/foo.tar.bz2' test_passed ( 2 ) = string1 % basedir () // '' == './bar' string1 = 'bar/foo.tar.bz2' test_passed ( 3 ) = string1 % basedir () // '' == 'bar' string1 = '\\bar\\foo.tar.bz2' test_passed ( 4 ) = string1 % basedir ( sep = '\\')//''==' \\ bar ' print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-23.f90.html"},{"title":"stringifor_string_t-doctest-84.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-84.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-84.f90 stringifor_string_t-doctest-84.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-84.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-84.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R8P test_passed ( 1 ) = astring % to_number ( kind = 1._R8P ) == 3.021e6_R8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-84.f90.html"},{"title":"stringifor_string_t-doctest-100.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-100.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-100.f90 stringifor_string_t-doctest-100.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-100.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-100.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter < astring ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter < astring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-100.f90.html"},{"title":"stringifor_string_t-doctest-57.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-57.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-57.f90 stringifor_string_t-doctest-57.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-57.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-57.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I1P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I1P ) test_passed ( 1 ) = integer_ == 127_I1P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-57.f90.html"},{"title":"stringifor_string_t-doctest-77.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-77.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-77.f90 stringifor_string_t-doctest-77.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-77.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-77.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 1 ) astring = 'hello' anotherstring = astring test_passed ( 1 ) = astring % chars () == anotherstring % chars () print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-77.f90.html"},{"title":"stringifor_string_t-doctest-65.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-65.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-65.f90 stringifor_string_t-doctest-65.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-65.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-65.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = '+++ab-++cre-++cre-ab+++++' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-65.f90.html"},{"title":"stringifor_string_t-doctest-58.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-58.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-58.f90 stringifor_string_t-doctest-58.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-58.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-58.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I2P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I2P ) test_passed ( 1 ) = integer_ == 127_I2P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-58.f90.html"},{"title":"stringifor_string_t-doctest-14.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-14.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-14.f90 stringifor_string_t-doctest-14.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-14.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-14.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len () == len ( 'Hello World!   ' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-14.f90.html"},{"title":"stringifor_string_t-doctest-37.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-37.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-37.f90 stringifor_string_t-doctest-37.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-37.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-37.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 5 ) astring = 'this is string example wow!!!' acharacter = '... ' test_passed ( 1 ) = astring % insert ( substring = acharacter , pos = 1 ) // '' == '... this is string example wow!!!' test_passed ( 2 ) = astring % insert ( substring = acharacter , pos = 23 ) // '' == 'this is string example...  wow!!!' test_passed ( 3 ) = astring % insert ( substring = acharacter , pos = 29 ) // '' == 'this is string example wow!!!... ' test_passed ( 4 ) = astring % insert ( substring = acharacter , pos =- 1 ) // '' == '... this is string example wow!!!' test_passed ( 5 ) = astring % insert ( substring = acharacter , pos = 100 ) // '' == 'this is string example wow!!!... ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-37.f90.html"},{"title":"stringifor_string_t-doctest-9.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-9.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-9.f90 stringifor_string_t-doctest-9.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-9.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-9.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = '   Hello World!' print \"(L1)\" , astring % adjustl () // '' == 'Hello World!   ' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-9.f90.html"},{"title":"stringifor_string_t-doctest-29.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-29.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-29.f90 stringifor_string_t-doctest-29.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-29.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-29.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'SG93IGFyZSB5b3U/' print '(L1)' , astring % decode ( codec = 'base64' ) // '' == 'How are you?' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-29.f90.html"},{"title":"stringifor_string_t-doctest-33.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-33.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-33.f90 stringifor_string_t-doctest-33.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-33.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-33.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 4 ) astring = 'this is string example....wow!!!' test_passed ( 1 ) = astring % fill ( width = 40 ) // '' == '00000000this is string example....wow!!!' test_passed ( 2 ) = astring % fill ( width = 50 ) // '' == '000000000000000000this is string example....wow!!!' test_passed ( 3 ) = astring % fill ( width = 50 , right = . true .) // '' == 'this is string example....wow!!!000000000000000000' test_passed ( 4 ) = astring % fill ( width = 40 , filling_char = '*' ) // '' == '********this is string example....wow!!!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-33.f90.html"},{"title":"stringifor_string_t-doctest-2.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-2.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-2.f90 stringifor_string_t-doctest-2.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-2.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-2.f90 Source Code program volatile_doctest use stringifor_string_t print \"(L1)\" , string ( 'Hello World' ) // '' == 'Hello World' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-2.f90.html"},{"title":"stringifor_string_t-doctest-102.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-102.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-102.f90 stringifor_string_t-doctest-102.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-102.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-102.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring <= acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring <= acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( astring <= acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-102.f90.html"},{"title":"stringifor_string_t-doctest-35.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-35.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-35.f90 stringifor_string_t-doctest-35.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-35.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-35.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_chr ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr print '(L1)' , test_passed endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-35.f90.html"},{"title":"stringifor_string_t-doctest-48.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-48.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-48.f90 stringifor_string_t-doctest-48.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-48.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-48.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring character ( len = :), allocatable :: acharacter integer :: istart integer :: iend logical :: test_passed ( 5 ) astring = '<test> <first> hello </first> <first> not the first </first> </test>' anotherstring = astring % search ( tag_start = '<first>' , tag_end = '</first>' ) test_passed ( 1 ) = anotherstring // '' == '<first> hello </first>' astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' anotherstring = astring % search ( tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 2 ) = anotherstring // '' == '<a> <a> <a> the nested a </a> </a> </a>' call astring % free anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_string = anotherstring , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 3 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' call astring % free acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 4 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<sec>' , tag_end = '</sec>' , istart = istart , iend = iend ) test_passed ( 5 ) = astring // '' == acharacter ( 31 : 67 ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-48.f90.html"},{"title":"stringifor_string_t-doctest-1.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-1.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-1.f90 stringifor_string_t-doctest-1.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-1.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-1.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: alist_chr (:) type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call glob ( self = astring , pattern = 'foo-*' , list = alist_chr ) call glob ( self = astring , pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_chr : do f = 1 , size ( alist_chr , dim = 1 ) do ff = 1 , Nf test_passed = alist_chr ( f ) == files ( ff ) if ( test_passed ) cycle outer_chr enddo enddo outer_chr if ( test_passed ) then test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str endif print '(L1)' , test_passed endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-1.f90.html"},{"title":"stringifor_string_t-doctest-78.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-78.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-78.f90 stringifor_string_t-doctest-78.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-78.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-78.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'hello' test_passed ( 1 ) = astring % chars () == 'hello' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-78.f90.html"},{"title":"stringifor_string_t-doctest-96.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-96.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-96.f90 stringifor_string_t-doctest-96.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-96.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-96.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( astring /= acharacter ). eqv .. true .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( astring /= acharacter ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-96.f90.html"},{"title":"stringifor_string_t-doctest-55.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-55.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-55.f90 stringifor_string_t-doctest-55.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-55.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-55.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = '  Hello World!   ' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-55.f90.html"},{"title":"stringifor_string_t-doctest-8.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-8.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-8.f90 stringifor_string_t-doctest-8.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-8.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-8.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'ell' test_passed ( 1 ) = verify ( s = 'Hello World Hello!' , set = string1 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = verify ( s = 'Hello World Hello!' , set = string1 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , & back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-8.f90.html"},{"title":"stringifor_string_t-doctest-60.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-60.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-60.f90 stringifor_string_t-doctest-60.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-60.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-60.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I8P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I8P ) test_passed ( 1 ) = integer_ == 127_I8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-60.f90.html"},{"title":"stringifor_string_t-doctest-108.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-108.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-108.f90 stringifor_string_t-doctest-108.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-108.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-108.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring > acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring > acharacter ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-108.f90.html"},{"title":"stringifor_string_t-doctest-6.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-6.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-6.f90 stringifor_string_t-doctest-6.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-6.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-6.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'llo' test_passed ( 1 ) = index ( s = 'Hello World Hello!' , substring = string1 ) == index ( string = 'Hello World Hello!' , substring = 'llo' ) test_passed ( 2 ) = index ( s = 'Hello World Hello!' , substring = string1 , back = . true .) == index ( string = 'Hello World Hello!' , & substring = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-6.f90.html"},{"title":"stringifor_string_t-doctest-61.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-61.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-61.f90 stringifor_string_t-doctest-61.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-61.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-61.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring real ( R4P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R4P ) test_passed ( 1 ) = real_ == 3.4e9_R4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-61.f90.html"},{"title":"stringifor_string_t-doctest-103.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-103.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-103.f90 stringifor_string_t-doctest-103.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-103.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-103.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( acharacter <= astring ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( acharacter <= astring ). eqv .. false .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( acharacter <= astring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-103.f90.html"},{"title":"stringifor_string_t-doctest-72.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-72.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-72.f90 stringifor_string_t-doctest-72.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-72.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-72.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 3 ) astring = ' Hello World' test_passed ( 1 ) = astring % is_lower (). eqv .. false . astring = ' HELLO WORLD' test_passed ( 2 ) = astring % is_lower (). eqv .. false . astring = ' hello world' test_passed ( 3 ) = astring % is_lower (). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-72.f90.html"},{"title":"stringifor_string_t-doctest-30.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-30.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-30.f90 stringifor_string_t-doctest-30.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-30.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-30.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'How are you?' print '(L1)' , astring % encode ( codec = 'base64' ) // '' == 'SG93IGFyZSB5b3U/' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-30.f90.html"},{"title":"stringifor_string_t-doctest-26.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-26.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-26.f90 stringifor_string_t-doctest-26.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-26.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-26.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % capitalize () // '' == 'Say all hello world!' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-26.f90.html"},{"title":"stringifor_string_t-doctest-80.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-80.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-80.f90 stringifor_string_t-doctest-80.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-80.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-80.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I2P test_passed ( 1 ) = astring % to_number ( kind = 1_I2P ) == 127_I2P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-80.f90.html"},{"title":"stringifor_string_t-doctest-79.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-79.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-79.f90 stringifor_string_t-doctest-79.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-79.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-79.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I1P test_passed ( 1 ) = astring % to_number ( kind = 1_I1P ) == 127_I1P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-79.f90.html"},{"title":"stringifor_string_t-doctest-27.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-27.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-27.f90 stringifor_string_t-doctest-27.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-27.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-27.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % chars () == 'say all Hello WorLD!' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-27.f90.html"},{"title":"stringifor_string_t-doctest-22.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-22.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-22.f90 stringifor_string_t-doctest-22.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-22.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-22.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % verify ( set = 'llo' ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = 'llo' , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-22.f90.html"},{"title":"stringifor_string_t-doctest-92.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-92.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-92.f90 stringifor_string_t-doctest-92.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-92.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-92.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = '  one ' anotherstring = 'two' test_passed ( 1 ) = (( astring == anotherstring ). eqv .. false .) astring = 'the same ' anotherstring = 'the same ' test_passed ( 2 ) = (( astring == anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-92.f90.html"},{"title":"stringifor_string_t-doctest-64.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-64.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-64.f90 stringifor_string_t-doctest-64.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-64.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-64.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = '&#94;\\\\s \\\\d+\\\\s*' test_passed ( 1 ) = ( astring % unescape ( to_unescape = '\\')//''==' &#94;\\ s \\ d + \\ s * ') test_passed(2) = (astring%unescape(to_unescape=' s ')//''==' &#94;\\ s \\\\ d + \\ s * ') print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-64.f90.html"},{"title":"stringifor_string_t-doctest-70.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-70.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-70.f90 stringifor_string_t-doctest-70.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-70.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-70.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-70.f90.html"},{"title":"stringifor_string_t-doctest-19.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-19.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-19.f90 stringifor_string_t-doctest-19.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-19.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-19.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' test_passed ( 1 ) = string1 % scan ( set = 'llo' ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = 'llo' , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-19.f90.html"},{"title":"stringifor_string_t-doctest-17.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-17.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-17.f90 stringifor_string_t-doctest-17.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-17.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-17.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'y' print \"(L1)\" , astring % repeat ( 'x' , 5 ) // '' == 'xxxxx' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-17.f90.html"},{"title":"stringifor_string_t-doctest-87.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-87.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-87.f90 stringifor_string_t-doctest-87.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-87.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-87.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' test_passed ( 1 ) = astring // acharacter == 'Hello World!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-87.f90.html"},{"title":"stringifor_string_t-doctest-93.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-93.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-93.f90 stringifor_string_t-doctest-93.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-93.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-93.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 2 ) astring = '  one ' acharacter = 'three' test_passed ( 1 ) = (( astring == acharacter ). eqv .. false .) astring = 'the same ' acharacter = 'the same ' test_passed ( 2 ) = (( astring == acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-93.f90.html"},{"title":"stringifor_string_t-doctest-10.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-10.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-10.f90 stringifor_string_t-doctest-10.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-10.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-10.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % adjustr () // '' == '   Hello World!' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-10.f90.html"},{"title":"stringifor_string_t-doctest-16.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-16.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-16.f90 stringifor_string_t-doctest-16.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-16.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-16.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'x' print \"(L1)\" , astring % repeat ( 5 ) // '' == 'xxxxx' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-16.f90.html"},{"title":"stringifor_string_t-doctest-40.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-40.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-40.f90 stringifor_string_t-doctest-40.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-40.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-40.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( 5 ) :: characters ( 3 ) logical :: test_passed ( 6 ) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 1 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) test_passed ( 2 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' test_passed ( 3 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' test_passed ( 4 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' test_passed ( 5 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' astring = '_' test_passed ( 6 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // '_' // characters ( 2 ) // '_' // characters ( 3 )) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-40.f90.html"},{"title":"stringifor_string_t-doctest-59.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-59.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-59.f90 stringifor_string_t-doctest-59.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-59.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-59.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring integer ( I4P ) :: integer_ logical :: test_passed ( 1 ) astring = '127' integer_ = astring % to_number ( kind = 1_I4P ) test_passed ( 1 ) = integer_ == 127_I4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-59.f90.html"},{"title":"stringifor_string_t-doctest-36.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-36.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-36.f90 stringifor_string_t-doctest-36.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-36.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-36.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: alist_str (:) integer , parameter :: Nf = 5 character ( 14 ) :: files ( 1 : Nf ) integer :: file_unit integer :: f integer :: ff logical :: test_passed do f = 1 , Nf files ( f ) = astring % tempname ( prefix = 'foo-' ) open ( newunit = file_unit , file = files ( f )) write ( file_unit , * ) f close ( unit = file_unit ) enddo call astring % glob ( pattern = 'foo-*' , list = alist_str ) do f = 1 , Nf open ( newunit = file_unit , file = files ( f )) close ( unit = file_unit , status = 'delete' ) enddo test_passed = . false . outer_str : do f = 1 , size ( alist_str , dim = 1 ) do ff = 1 , Nf test_passed = alist_str ( f ) == files ( ff ) if ( test_passed ) cycle outer_str enddo enddo outer_str print '(L1)' , test_passed endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-36.f90.html"},{"title":"stringifor_string_t-doctest-49.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-49.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-49.f90 stringifor_string_t-doctest-49.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-49.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-49.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'the Quick Brown fox Jumps over the Lazy Dog.' print \"(A)\" , astring % slice ( 11 , 25 ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-49.f90.html"},{"title":"stringifor_string_t-doctest-66.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-66.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-66.f90 stringifor_string_t-doctest-66.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-66.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-66.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-66.f90.html"},{"title":"stringifor_string_t-doctest-53.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-53.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-53.f90 stringifor_string_t-doctest-53.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-53.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-53.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % startcase () // '' == 'The Quick Brown Fox Jumps Over The Lazy Dog.' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-53.f90.html"},{"title":"stringifor_string_t-doctest-32.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-32.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-32.f90 stringifor_string_t-doctest-32.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-32.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-32.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = '/bar/foo.tar.bz2' print '(L1)' , astring % extension () // '' == '.bz2' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-32.f90.html"},{"title":"stringifor_string_t-doctest-105.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-105.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-105.f90 stringifor_string_t-doctest-105.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-105.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-105.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring character ( len = :), allocatable :: acharacter logical :: test_passed ( 3 ) astring = 'one' acharacter = 'ONE' test_passed ( 1 ) = (( astring >= acharacter ). eqv .. true .) astring = 'ONE' acharacter = 'one' test_passed ( 2 ) = (( astring >= acharacter ). eqv .. false .) astring = 'ONE' acharacter = 'ONE' test_passed ( 3 ) = (( astring >= acharacter ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-105.f90.html"},{"title":"stringifor_string_t-doctest-83.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-83.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-83.f90 stringifor_string_t-doctest-83.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-83.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-83.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 3.021e6_R4P test_passed ( 1 ) = astring % to_number ( kind = 1._R4P ) == 3.021e6_R4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-83.f90.html"},{"title":"stringifor_string_t-doctest-89.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-89.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-89.f90 stringifor_string_t-doctest-89.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-89.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-89.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring type ( string ) :: yetanotherstring logical :: test_passed ( 1 ) astring = 'Hello ' anotherstring = 'Bye bye' yetanotherstring = astring . cat . anotherstring test_passed ( 1 ) = yetanotherstring % chars () == 'Hello Bye bye' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-89.f90.html"},{"title":"stringifor_string_t-doctest-90.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-90.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-90.f90 stringifor_string_t-doctest-90.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-90.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-90.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: yetanotherstring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' yetanotherstring = astring . cat . acharacter test_passed ( 1 ) = yetanotherstring % chars () == 'Hello World!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-90.f90.html"},{"title":"stringifor_string_t-doctest-34.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-34.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-34.f90 stringifor_string_t-doctest-34.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-34.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-34.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'this is string example....wow!!!' call astring % free print '(L1)' , astring % is_allocated (). eqv .. false . endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-34.f90.html"},{"title":"stringifor_string_t-doctest-51.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-51.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-51.f90 stringifor_string_t-doctest-51.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-51.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-51.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ), allocatable :: strings (:) logical :: test_passed ( 11 ) astring = '+ab-++cre-++cre-ab+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'ab-++cre-++cre-ab+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'ab-++cre-++cre-ab' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) astring = 'Hello ' // new_line ( 'a' ) // 'World!' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) astring = 'Hello World!' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) astring = '+ab-' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 6 ) = ( strings ( 1 ) // '' == 'ab-' ) astring = '+ab-' call astring % split ( tokens = strings , sep = '-' ) test_passed ( 7 ) = ( strings ( 1 ) // '' == '+ab' ) astring = '+ab-+cd-' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 8 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = 'ab-+cd-+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 9 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = '+ab-+cd-+' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 10 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cd-' ) astring = '1-2-3-4-5-6-7-8' call astring % split ( tokens = strings , sep = '-' , max_tokens = 3 ) test_passed ( 11 ) = ( strings ( 1 ) // '' == '1' . and . strings ( 2 ) // '' == '2' . and . strings ( 3 ) // '' == '3' . and . strings ( 4 ) // '' == '4-5-6-7-8' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-51.f90.html"},{"title":"stringifor_string_t-doctest-11.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-11.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-11.f90 stringifor_string_t-doctest-11.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-11.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-11.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 4 ) astring = '   Hello World  !    ' test_passed ( 1 ) = astring % count ( substring = ' ' ) == 10 astring = 'Hello World  !    ' test_passed ( 2 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 6 astring = '    Hello World  !' test_passed ( 3 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 6 astring = '   Hello World  !    ' test_passed ( 4 ) = astring % count ( substring = ' ' , ignore_isolated = . true .) == 8 print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-11.f90.html"},{"title":"stringifor_string_t-doctest-15.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-15.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-15.f90 stringifor_string_t-doctest-15.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-15.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-15.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , astring % len_trim () == len_trim ( 'Hello World!   ' ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-15.f90.html"},{"title":"stringifor_string_t-doctest-69.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-69.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-69.f90 stringifor_string_t-doctest-69.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-69.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-69.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) test_passed ( 1 ) = astring % is_allocated (). eqv .. false . astring = 'hello' test_passed ( 2 ) = astring % is_allocated (). eqv .. true . print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-69.f90.html"},{"title":"stringifor_string_t-doctest-91.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-91.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-91.f90 stringifor_string_t-doctest-91.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-91.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-91.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: yetanotherstring character ( len = :), allocatable :: acharacter logical :: test_passed ( 1 ) astring = 'Hello ' acharacter = 'World!' yetanotherstring = acharacter . cat . astring test_passed ( 1 ) = yetanotherstring % chars () == 'World!Hello ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-91.f90.html"},{"title":"stringifor_string_t-doctest-44.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-44.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-44.f90 stringifor_string_t-doctest-44.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-44.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-44.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 6 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then exit else test_passed ( l ) = ( astring == line ( l )) endif enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg , form = 'UnfORMatteD' ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then exit else test_passed ( l + 3 ) = ( astring == line ( l )) endif enddo close ( scratch ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-44.f90.html"},{"title":"stringifor_string_t-doctest-41.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-41.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-41.f90 stringifor_string_t-doctest-41.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-41.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-41.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 1 ) astring = 'Hello WorLD!' test_passed ( 1 ) = astring % lower () // '' == 'hello world!' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-41.f90.html"},{"title":"stringifor_string_t-doctest-31.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-31.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-31.f90 stringifor_string_t-doctest-31.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-31.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-31.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring logical :: test_passed ( 2 ) astring = '&#94;\\s \\d+\\s*' test_passed ( 1 ) = astring % escape ( to_escape = '\\')//''==' &#94;\\\\ s \\\\ d + \\\\ s * ' test_passed(2) = astring%escape(to_escape=' \\ ', esc=' | ')//''==' &#94;|\\ s |\\ d + |\\ s * ' print ' ( L1 ) ' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-31.f90.html"},{"title":"stringifor_string_t-doctest-18.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-18.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-18.f90 stringifor_string_t-doctest-18.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-18.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-18.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % scan ( set = string2 ) == scan ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % scan ( set = string2 , back = . true .) == scan ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-18.f90.html"},{"title":"stringifor_string_t-doctest-4.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-4.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-4.f90 stringifor_string_t-doctest-4.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-4.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-4.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'Hello World!   ' print \"(L1)\" , adjustr ( astring ) == '   Hello World!' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-4.f90.html"},{"title":"stringifor_string_t-doctest-104.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-104.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-104.f90 stringifor_string_t-doctest-104.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-104.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-104.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 3 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring >= anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring >= anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'ONE' test_passed ( 3 ) = (( astring >= anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-104.f90.html"},{"title":"stringifor_string_t-doctest-28.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-28.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-28.f90 stringifor_string_t-doctest-28.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-28.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-28.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring astring = 'say all Hello WorLD!' print '(L1)' , astring % colorize ( color_fg = 'red' ) == '\u001b[31msay all Hello WorLD!\u001b[0m' endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-28.f90.html"},{"title":"stringifor_string_t-doctest-81.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-81.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-81.f90 stringifor_string_t-doctest-81.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-81.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-81.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring logical :: test_passed ( 1 ) astring = 127_I4P test_passed ( 1 ) = astring % to_number ( kind = 1_I4P ) == 127_I4P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-81.f90.html"},{"title":"stringifor_string_t-doctest-98.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-98.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-98.f90 stringifor_string_t-doctest-98.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-98.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-98.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring < anotherstring ). eqv .. false .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring < anotherstring ). eqv .. true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-98.f90.html"},{"title":"stringifor_string_t-doctest-21.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-21.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-21.f90 stringifor_string_t-doctest-21.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-21.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-21.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: string1 type ( string ) :: string2 logical :: test_passed ( 2 ) string1 = 'Hello World Hello!' string2 = 'llo' test_passed ( 1 ) = string1 % verify ( set = string2 ) == verify ( string = 'Hello World Hello!' , set = 'llo' ) test_passed ( 2 ) = string1 % verify ( set = string2 , back = . true .) == verify ( string = 'Hello World Hello!' , set = 'llo' , back = . true .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-21.f90.html"},{"title":"stringifor_string_t-doctest-107.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-107.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-107.f90 stringifor_string_t-doctest-107.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-107.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-107.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 2 ) astring = 'one' anotherstring = 'ONE' test_passed ( 1 ) = (( astring > anotherstring ). eqv .. true .) astring = 'ONE' anotherstring = 'one' test_passed ( 2 ) = (( astring > anotherstring ). eqv .. false .) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-107.f90.html"},{"title":"stringifor_string_t-doctest-5.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-5.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-5.f90 stringifor_string_t-doctest-5.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-5.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-5.f90 Source Code program volatile_doctest use stringifor_string_t print \"(L1)\" , count ( 'hello' , substring = 'll' ) == 1 endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-5.f90.html"},{"title":"stringifor_string_t-doctest-62.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-62.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-62.f90 stringifor_string_t-doctest-62.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-62.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-62.f90 Source Code program volatile_doctest use stringifor_string_t use penf type ( string ) :: astring real ( R8P ) :: real_ logical :: test_passed ( 1 ) astring = '3.4e9' real_ = astring % to_number ( kind = 1._R8P ) test_passed ( 1 ) = real_ == 3.4e9_R8P print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-62.f90.html"},{"title":"stringifor_string_t-doctest-38.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor_string_t-doctest-38.f90~~EfferentGraph sourcefile~stringifor_string_t-doctest-38.f90 stringifor_string_t-doctest-38.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-38.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor_string_t-doctest-38.f90 Source Code program volatile_doctest use stringifor_string_t type ( string ) :: astring type ( string ) :: anotherstring logical :: test_passed ( 5 ) astring = 'this is string example wow!!!' anotherstring = '... ' test_passed ( 1 ) = astring % insert ( substring = anotherstring , pos = 1 ) // '' == '... this is string example wow!!!' test_passed ( 2 ) = astring % insert ( substring = anotherstring , pos = 23 ) // '' == 'this is string example...  wow!!!' test_passed ( 3 ) = astring % insert ( substring = anotherstring , pos = 29 ) // '' == 'this is string example wow!!!... ' test_passed ( 4 ) = astring % insert ( substring = anotherstring , pos =- 1 ) // '' == '... this is string example wow!!!' test_passed ( 5 ) = astring % insert ( substring = anotherstring , pos = 100 ) // '' == 'this is string example wow!!!... ' print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor_string_t-doctest-38.f90.html"},{"title":"stringifor-doctest-2.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor-doctest-2.f90~~EfferentGraph sourcefile~stringifor-doctest-2.f90 stringifor-doctest-2.f90 sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor-doctest-2.f90->sourcefile~stringifor.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor-doctest-2.f90 Source Code program volatile_doctest use stringifor type ( string ) :: astring type ( string ) :: anotherstring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) call write_file ( file = 'write_file_test.tmp' , lines = line , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo call write_file ( file = 'write_file_test.tmp' , lines = line , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( scratch , status = 'DELETE' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor-doctest-2.f90.html"},{"title":"stringifor_test_parse_large_csv.f90 – StringiFor","text":"StringiFor csv_naive_parser test. This file depends on sourcefile~~stringifor_test_parse_large_csv.f90~~EfferentGraph sourcefile~stringifor_test_parse_large_csv.f90 stringifor_test_parse_large_csv.f90 sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor_test_parse_large_csv.f90->sourcefile~stringifor.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs stringifor_test_parse_large_csv Source Code stringifor_test_parse_large_csv.f90 Source Code !< StringiFor `csv_naive_parser` test. program stringifor_test_parse_large_csv !< StringiFor `csv_naive_parser` test. use stringifor implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: c , r !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . call csv % read_file ( file = 'src/tests/stringifor/stringifor_test_parse_large_csv.csv' , is_fast = . true .) call csv % split_chunked ( tokens = rows , sep = new_line ( 'a' ), chunks = 10 ) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' do c = 1 , columns_number columns ( c ) = '----' ! re-use columns for printing separators enddo print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' test_passed = . true . print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram stringifor_test_parse_large_csv","tags":"","loc":"sourcefile/stringifor_test_parse_large_csv.f90.html"},{"title":"stringifor-doctest-1.f90 – StringiFor","text":"This file depends on sourcefile~~stringifor-doctest-1.f90~~EfferentGraph sourcefile~stringifor-doctest-1.f90 stringifor-doctest-1.f90 sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor-doctest-1.f90->sourcefile~stringifor.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs volatile_doctest Source Code stringifor-doctest-1.f90 Source Code program volatile_doctest use stringifor type ( string ) :: astring type ( string ), allocatable :: strings (:) type ( string ) :: line ( 3 ) integer :: iostat character ( len = 99 ) :: iomsg integer :: scratch integer :: l logical :: test_passed ( 8 ) line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) call read_file ( file = 'read_file_test.tmp' , lines = strings , iostat = iostat , iomsg = iomsg ) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) call read_file ( file = 'read_file_test.tmp' , lines = strings , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) print '(L1)' , all ( test_passed ) endprogram volatile_doctest","tags":"","loc":"sourcefile/stringifor-doctest-1.f90.html"},{"title":"stringifor_test_csv_naive_parser.f90 – StringiFor","text":"StringiFor csv naive parser test. This file depends on sourcefile~~stringifor_test_csv_naive_parser.f90~~EfferentGraph sourcefile~stringifor_test_csv_naive_parser.f90 stringifor_test_csv_naive_parser.f90 sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor_test_csv_naive_parser.f90->sourcefile~stringifor.f90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs stringifor_test_csv_naive_parser Source Code stringifor_test_csv_naive_parser.f90 Source Code !< StringiFor *csv naive parser* test. program stringifor_test_csv_naive_parser !< StringiFor *csv naive parser* test. !< !< This is an example of the usefulness of StringiFor. use stringifor implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. type ( string ) :: lines ( 4 ) !< The CSV file lines. type ( string ) :: most_expensive !< The most expensive car. real ( R8P ) :: highest_cost !< The highest cost. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: c , r !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . ! a cars database lines ( 1 ) = 'Year,Make,Model,Description,Price' lines ( 2 ) = '1997,Ford,E350,ac abs moon,3000.00' lines ( 3 ) = '1999,Chevy,Venture \"Extended Edition\", ,4900.00' lines ( 4 ) = '1999,Chevy,Venture \"Extended Edition Very Large\", ,5000.00' ! preparing a CSV file test call write_file ( file = 'file_test_temp.csv' , lines = lines ) ! parsing the just created CSV file call csv % read_file ( file = 'file_test_temp.csv' ) ! read the CSV file as a single stream call csv % split ( tokens = rows , sep = new_line ( 'a' )) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! eliminating the file open ( newunit = r , file = 'file_test_temp.csv' ) ; close ( unit = r , status = 'DELETE' ) ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' do c = 1 , columns_number columns ( c ) = '----' ! re-use columns for printing separators enddo print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' ! find the most expensive car print \"(A)\" , 'Searching for the most expensive car' most_expensive = 'unknown' highest_cost = - 1._R8P do r = 2 , rows_number if ( cells ( 5 , r )% to_number ( kind = 1._R8P ) >= highest_cost ) then highest_cost = cells ( 5 , r )% to_number ( kind = 1._R8P ) most_expensive = csv % join ( array = [ cells ( 2 , r ), cells ( 3 , r )], sep = ' ' ) endif enddo test_passed ( 1 ) = most_expensive // '' == 'Chevy Venture \"Extended Edition Very Large\"' print \"(A,L1)\" , 'The most expensive car is : ' // most_expensive // ', is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram stringifor_test_csv_naive_parser","tags":"","loc":"sourcefile/stringifor_test_csv_naive_parser.f90.html"},{"title":"stringifor.F90 – StringiFor","text":"StringiFor, Strings Fortran Manipulator with steroids. This file depends on sourcefile~~stringifor.f90~~EfferentGraph sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor.f90->sourcefile~stringifor_string_t.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~stringifor.f90~~AfferentGraph sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor-doctest-2.f90 stringifor-doctest-2.f90 sourcefile~stringifor-doctest-2.f90->sourcefile~stringifor.f90 sourcefile~stringifor_test_csv_naive_parser.f90 stringifor_test_csv_naive_parser.f90 sourcefile~stringifor_test_csv_naive_parser.f90->sourcefile~stringifor.f90 sourcefile~stringifor_test_parse_large_csv.f90 stringifor_test_parse_large_csv.f90 sourcefile~stringifor_test_parse_large_csv.f90->sourcefile~stringifor.f90 sourcefile~stringifor-doctest-1.f90 stringifor-doctest-1.f90 sourcefile~stringifor-doctest-1.f90->sourcefile~stringifor.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules stringifor Source Code stringifor.F90 Source Code !< StringiFor, Strings Fortran Manipulator with steroids. module stringifor !< StringiFor, Strings Fortran Manipulator with steroids. use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P ! use stringifor_string_t, only : adjustl, adjustr, count, index, len, len_trim, repeat, scan, trim, verify, CK, string use stringifor_string_t , only : adjustl , adjustr , count , index , len_trim , repeat , scan , trim , verify , CK , glob , string , strjoin implicit none private save ! expose StingiFor objects public :: CK public :: glob public :: strjoin public :: string ! expose StingiFor overloaded builtins and operators ! public :: adjustl, adjustr, count, index, len, len_trim, repeat, scan, trim, verify public :: adjustl , adjustr , count , index , len_trim , repeat , scan , trim , verify ! expose StingiFor new procedures public :: read_file , read_lines , write_file , write_lines ! expose PENF kinds public :: I1P , I2P , I4P , I8P , R4P , R8P , R16P contains subroutine read_file ( file , lines , form , iostat , iomsg ) !< Read a file as a single string stream. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, file='read_file_test.tmp') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< close(scratch) !< call read_file(file='read_file_test.tmp', lines=strings, iostat=iostat, iomsg=iomsg) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< close(scratch) !< call read_file(file='read_file_test.tmp', lines=strings, form='unformatted', iostat=iostat, iomsg=iomsg) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< close(scratch, status='DELETE') !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call read_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_file subroutine read_lines ( unit , lines , form , iostat , iomsg ) !< Read lines (records) from a connected-formatted unit. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !< @note There is no doctests, this being tested by means of [[read_file]] doctests. integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = 1 ) :: ch !< Character storage. integer :: l !< Counter. form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) select case ( form_ % chars ()) case ( 'FORMATTED' ) l = 0 do read ( unit , * , err = 10 , end = 10 ) l = l + 1 enddo case ( 'UNFORMATTED' ) l = 0 do read ( unit , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) l = l + 1 enddo endselect 10 rewind ( unit ) if ( l > 0 ) then allocate ( lines ( 1 : l )) l = 1 iostat_ = 0 do call lines ( l )% read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if (( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )). or .( l >= size ( lines , dim = 1 ))) then exit endif l = l + 1 enddo endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_lines subroutine write_file ( file , lines , form , iostat , iomsg ) !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string)              :: anotherstring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< anotherstring = anotherstring%join(array=line, sep=new_line('a')) !< call write_file(file='write_file_test.tmp', lines=line, iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< call write_file(file='write_file_test.tmp', lines=line, form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='write_file_test.tmp') !< close(scratch, status='DELETE') !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call write_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_file subroutine write_lines ( unit , lines , form , iostat , iomsg ) !< Write lines (records) to a connected-formatted unit. !< !< @note There is no doctests, this being tested by means of [[write_file]] doctests. integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: l !< Counter. do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endsubroutine write_lines endmodule stringifor","tags":"","loc":"sourcefile/stringifor.f90.html"},{"title":"stringifor_string_t.F90 – StringiFor","text":"StringiFor, definition of string type. Files dependent on this one sourcefile~~stringifor_string_t.f90~~AfferentGraph sourcefile~stringifor_string_t.f90 stringifor_string_t.F90 sourcefile~stringifor_string_t-doctest-75.f90 stringifor_string_t-doctest-75.f90 sourcefile~stringifor_string_t-doctest-75.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-10.f90 stringifor_string_t-doctest-10.f90 sourcefile~stringifor_string_t-doctest-10.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-38.f90 stringifor_string_t-doctest-38.f90 sourcefile~stringifor_string_t-doctest-38.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-50.f90 stringifor_string_t-doctest-50.f90 sourcefile~stringifor_string_t-doctest-50.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-25.f90 stringifor_string_t-doctest-25.f90 sourcefile~stringifor_string_t-doctest-25.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-89.f90 stringifor_string_t-doctest-89.f90 sourcefile~stringifor_string_t-doctest-89.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-3.f90 stringifor_string_t-doctest-3.f90 sourcefile~stringifor_string_t-doctest-3.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-29.f90 stringifor_string_t-doctest-29.f90 sourcefile~stringifor_string_t-doctest-29.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-79.f90 stringifor_string_t-doctest-79.f90 sourcefile~stringifor_string_t-doctest-79.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-18.f90 stringifor_string_t-doctest-18.f90 sourcefile~stringifor_string_t-doctest-18.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-97.f90 stringifor_string_t-doctest-97.f90 sourcefile~stringifor_string_t-doctest-97.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-16.f90 stringifor_string_t-doctest-16.f90 sourcefile~stringifor_string_t-doctest-16.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-52.f90 stringifor_string_t-doctest-52.f90 sourcefile~stringifor_string_t-doctest-52.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-23.f90 stringifor_string_t-doctest-23.f90 sourcefile~stringifor_string_t-doctest-23.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-90.f90 stringifor_string_t-doctest-90.f90 sourcefile~stringifor_string_t-doctest-90.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-85.f90 stringifor_string_t-doctest-85.f90 sourcefile~stringifor_string_t-doctest-85.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-33.f90 stringifor_string_t-doctest-33.f90 sourcefile~stringifor_string_t-doctest-33.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-27.f90 stringifor_string_t-doctest-27.f90 sourcefile~stringifor_string_t-doctest-27.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-4.f90 stringifor_string_t-doctest-4.f90 sourcefile~stringifor_string_t-doctest-4.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-71.f90 stringifor_string_t-doctest-71.f90 sourcefile~stringifor_string_t-doctest-71.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-40.f90 stringifor_string_t-doctest-40.f90 sourcefile~stringifor_string_t-doctest-40.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-39.f90 stringifor_string_t-doctest-39.f90 sourcefile~stringifor_string_t-doctest-39.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-84.f90 stringifor_string_t-doctest-84.f90 sourcefile~stringifor_string_t-doctest-84.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-60.f90 stringifor_string_t-doctest-60.f90 sourcefile~stringifor_string_t-doctest-60.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-34.f90 stringifor_string_t-doctest-34.f90 sourcefile~stringifor_string_t-doctest-34.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-95.f90 stringifor_string_t-doctest-95.f90 sourcefile~stringifor_string_t-doctest-95.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-2.f90 stringifor_string_t-doctest-2.f90 sourcefile~stringifor_string_t-doctest-2.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-22.f90 stringifor_string_t-doctest-22.f90 sourcefile~stringifor_string_t-doctest-22.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-104.f90 stringifor_string_t-doctest-104.f90 sourcefile~stringifor_string_t-doctest-104.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-13.f90 stringifor_string_t-doctest-13.f90 sourcefile~stringifor_string_t-doctest-13.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-59.f90 stringifor_string_t-doctest-59.f90 sourcefile~stringifor_string_t-doctest-59.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-42.f90 stringifor_string_t-doctest-42.f90 sourcefile~stringifor_string_t-doctest-42.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-100.f90 stringifor_string_t-doctest-100.f90 sourcefile~stringifor_string_t-doctest-100.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-108.f90 stringifor_string_t-doctest-108.f90 sourcefile~stringifor_string_t-doctest-108.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-51.f90 stringifor_string_t-doctest-51.f90 sourcefile~stringifor_string_t-doctest-51.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-12.f90 stringifor_string_t-doctest-12.f90 sourcefile~stringifor_string_t-doctest-12.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-102.f90 stringifor_string_t-doctest-102.f90 sourcefile~stringifor_string_t-doctest-102.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-92.f90 stringifor_string_t-doctest-92.f90 sourcefile~stringifor_string_t-doctest-92.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-28.f90 stringifor_string_t-doctest-28.f90 sourcefile~stringifor_string_t-doctest-28.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-56.f90 stringifor_string_t-doctest-56.f90 sourcefile~stringifor_string_t-doctest-56.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-36.f90 stringifor_string_t-doctest-36.f90 sourcefile~stringifor_string_t-doctest-36.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor.f90 stringifor.F90 sourcefile~stringifor.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-47.f90 stringifor_string_t-doctest-47.f90 sourcefile~stringifor_string_t-doctest-47.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-57.f90 stringifor_string_t-doctest-57.f90 sourcefile~stringifor_string_t-doctest-57.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-6.f90 stringifor_string_t-doctest-6.f90 sourcefile~stringifor_string_t-doctest-6.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-11.f90 stringifor_string_t-doctest-11.f90 sourcefile~stringifor_string_t-doctest-11.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-20.f90 stringifor_string_t-doctest-20.f90 sourcefile~stringifor_string_t-doctest-20.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-35.f90 stringifor_string_t-doctest-35.f90 sourcefile~stringifor_string_t-doctest-35.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-64.f90 stringifor_string_t-doctest-64.f90 sourcefile~stringifor_string_t-doctest-64.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-81.f90 stringifor_string_t-doctest-81.f90 sourcefile~stringifor_string_t-doctest-81.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-43.f90 stringifor_string_t-doctest-43.f90 sourcefile~stringifor_string_t-doctest-43.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-49.f90 stringifor_string_t-doctest-49.f90 sourcefile~stringifor_string_t-doctest-49.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-45.f90 stringifor_string_t-doctest-45.f90 sourcefile~stringifor_string_t-doctest-45.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-77.f90 stringifor_string_t-doctest-77.f90 sourcefile~stringifor_string_t-doctest-77.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-61.f90 stringifor_string_t-doctest-61.f90 sourcefile~stringifor_string_t-doctest-61.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-15.f90 stringifor_string_t-doctest-15.f90 sourcefile~stringifor_string_t-doctest-15.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-46.f90 stringifor_string_t-doctest-46.f90 sourcefile~stringifor_string_t-doctest-46.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-48.f90 stringifor_string_t-doctest-48.f90 sourcefile~stringifor_string_t-doctest-48.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-70.f90 stringifor_string_t-doctest-70.f90 sourcefile~stringifor_string_t-doctest-70.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-98.f90 stringifor_string_t-doctest-98.f90 sourcefile~stringifor_string_t-doctest-98.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-94.f90 stringifor_string_t-doctest-94.f90 sourcefile~stringifor_string_t-doctest-94.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-74.f90 stringifor_string_t-doctest-74.f90 sourcefile~stringifor_string_t-doctest-74.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-66.f90 stringifor_string_t-doctest-66.f90 sourcefile~stringifor_string_t-doctest-66.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-69.f90 stringifor_string_t-doctest-69.f90 sourcefile~stringifor_string_t-doctest-69.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-54.f90 stringifor_string_t-doctest-54.f90 sourcefile~stringifor_string_t-doctest-54.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-65.f90 stringifor_string_t-doctest-65.f90 sourcefile~stringifor_string_t-doctest-65.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-103.f90 stringifor_string_t-doctest-103.f90 sourcefile~stringifor_string_t-doctest-103.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-67.f90 stringifor_string_t-doctest-67.f90 sourcefile~stringifor_string_t-doctest-67.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-1.f90 stringifor_string_t-doctest-1.f90 sourcefile~stringifor_string_t-doctest-1.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-19.f90 stringifor_string_t-doctest-19.f90 sourcefile~stringifor_string_t-doctest-19.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-21.f90 stringifor_string_t-doctest-21.f90 sourcefile~stringifor_string_t-doctest-21.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-53.f90 stringifor_string_t-doctest-53.f90 sourcefile~stringifor_string_t-doctest-53.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-101.f90 stringifor_string_t-doctest-101.f90 sourcefile~stringifor_string_t-doctest-101.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-8.f90 stringifor_string_t-doctest-8.f90 sourcefile~stringifor_string_t-doctest-8.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-7.f90 stringifor_string_t-doctest-7.f90 sourcefile~stringifor_string_t-doctest-7.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-58.f90 stringifor_string_t-doctest-58.f90 sourcefile~stringifor_string_t-doctest-58.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-72.f90 stringifor_string_t-doctest-72.f90 sourcefile~stringifor_string_t-doctest-72.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-91.f90 stringifor_string_t-doctest-91.f90 sourcefile~stringifor_string_t-doctest-91.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-68.f90 stringifor_string_t-doctest-68.f90 sourcefile~stringifor_string_t-doctest-68.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-78.f90 stringifor_string_t-doctest-78.f90 sourcefile~stringifor_string_t-doctest-78.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-17.f90 stringifor_string_t-doctest-17.f90 sourcefile~stringifor_string_t-doctest-17.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-107.f90 stringifor_string_t-doctest-107.f90 sourcefile~stringifor_string_t-doctest-107.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-24.f90 stringifor_string_t-doctest-24.f90 sourcefile~stringifor_string_t-doctest-24.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-86.f90 stringifor_string_t-doctest-86.f90 sourcefile~stringifor_string_t-doctest-86.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-32.f90 stringifor_string_t-doctest-32.f90 sourcefile~stringifor_string_t-doctest-32.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-63.f90 stringifor_string_t-doctest-63.f90 sourcefile~stringifor_string_t-doctest-63.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-14.f90 stringifor_string_t-doctest-14.f90 sourcefile~stringifor_string_t-doctest-14.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-30.f90 stringifor_string_t-doctest-30.f90 sourcefile~stringifor_string_t-doctest-30.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-44.f90 stringifor_string_t-doctest-44.f90 sourcefile~stringifor_string_t-doctest-44.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-109.f90 stringifor_string_t-doctest-109.f90 sourcefile~stringifor_string_t-doctest-109.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-96.f90 stringifor_string_t-doctest-96.f90 sourcefile~stringifor_string_t-doctest-96.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-87.f90 stringifor_string_t-doctest-87.f90 sourcefile~stringifor_string_t-doctest-87.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-5.f90 stringifor_string_t-doctest-5.f90 sourcefile~stringifor_string_t-doctest-5.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-106.f90 stringifor_string_t-doctest-106.f90 sourcefile~stringifor_string_t-doctest-106.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-99.f90 stringifor_string_t-doctest-99.f90 sourcefile~stringifor_string_t-doctest-99.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-105.f90 stringifor_string_t-doctest-105.f90 sourcefile~stringifor_string_t-doctest-105.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-76.f90 stringifor_string_t-doctest-76.f90 sourcefile~stringifor_string_t-doctest-76.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-37.f90 stringifor_string_t-doctest-37.f90 sourcefile~stringifor_string_t-doctest-37.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-26.f90 stringifor_string_t-doctest-26.f90 sourcefile~stringifor_string_t-doctest-26.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-41.f90 stringifor_string_t-doctest-41.f90 sourcefile~stringifor_string_t-doctest-41.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-93.f90 stringifor_string_t-doctest-93.f90 sourcefile~stringifor_string_t-doctest-93.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-73.f90 stringifor_string_t-doctest-73.f90 sourcefile~stringifor_string_t-doctest-73.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-55.f90 stringifor_string_t-doctest-55.f90 sourcefile~stringifor_string_t-doctest-55.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-62.f90 stringifor_string_t-doctest-62.f90 sourcefile~stringifor_string_t-doctest-62.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-88.f90 stringifor_string_t-doctest-88.f90 sourcefile~stringifor_string_t-doctest-88.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-83.f90 stringifor_string_t-doctest-83.f90 sourcefile~stringifor_string_t-doctest-83.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-82.f90 stringifor_string_t-doctest-82.f90 sourcefile~stringifor_string_t-doctest-82.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-9.f90 stringifor_string_t-doctest-9.f90 sourcefile~stringifor_string_t-doctest-9.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-80.f90 stringifor_string_t-doctest-80.f90 sourcefile~stringifor_string_t-doctest-80.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor_string_t-doctest-31.f90 stringifor_string_t-doctest-31.f90 sourcefile~stringifor_string_t-doctest-31.f90->sourcefile~stringifor_string_t.f90 sourcefile~stringifor-doctest-2.f90 stringifor-doctest-2.f90 sourcefile~stringifor-doctest-2.f90->sourcefile~stringifor.f90 sourcefile~stringifor_test_csv_naive_parser.f90 stringifor_test_csv_naive_parser.f90 sourcefile~stringifor_test_csv_naive_parser.f90->sourcefile~stringifor.f90 sourcefile~stringifor_test_parse_large_csv.f90 stringifor_test_parse_large_csv.f90 sourcefile~stringifor_test_parse_large_csv.f90->sourcefile~stringifor.f90 sourcefile~stringifor-doctest-1.f90 stringifor-doctest-1.f90 sourcefile~stringifor-doctest-1.f90->sourcefile~stringifor.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules stringifor_string_t Source Code stringifor_string_t.F90 Source Code !< StringiFor, definition of `string` type. module stringifor_string_t !< StringiFor, definition of `string` type. use , intrinsic :: iso_fortran_env , only : iostat_eor use befor64 , only : b64_decode , b64_encode use face , only : colorize use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P , str implicit none private save ! expose StingiFor overloaded builtins and operators ! public :: adjustl, adjustr, count, index, len, len_trim, repeat, scan, trim, verify public :: adjustl , adjustr , count , index , len_trim , repeat , scan , trim , verify ! expose StingiFor objects public :: CK public :: glob public :: strjoin public :: string integer , parameter :: CK = selected_char_kind ( 'DEFAULT' ) !< Default character kind. type :: string !< OOP designed string class. character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods ! builtins replacements procedure , pass ( self ) :: adjustl => sadjustl !< Adjustl replacement. procedure , pass ( self ) :: adjustr => sadjustr !< Adjustr replacement. procedure , pass ( self ) :: count => scount !< Count replacement. generic :: index => sindex_string_string , & sindex_string_character !< Index replacement. procedure , pass ( self ) :: len => slen !< Len replacement. procedure , pass ( self ) :: len_trim => slen_trim !< Len_trim replacement. generic :: repeat => srepeat_string_string , & srepeat_character_string !< Repeat replacement. generic :: scan => sscan_string_string , & sscan_string_character !< Scan replacement. procedure , pass ( self ) :: trim => strim !< Trim replacement. generic :: verify => sverify_string_string , & sverify_string_character !< Verify replacement. ! auxiliary methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. generic :: colorize => & colorize_str !< Colorize and stylize strings. procedure , pass ( self ) :: decode !< Decode string. procedure , pass ( self ) :: encode !< Encode string. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: glob => & glob_character , & glob_string !< Glob search, finds all the pathnames matching a given pattern. generic :: insert => & insert_string , & insert_character !< Insert substring into string at a specified position. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. generic :: strjoin => & strjoin_strings , & strjoin_characters , & strjoin_strings_array , & strjoin_characters_array !< Return a string that is a join of an array of strings or characters; !< Return join 1D string array of an 2D array of strings or characters in columns or rows. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: read_file !< Read a file a single string stream. procedure , pass ( self ) :: read_line !< Read line (record) from a connected unit. procedure , pass ( self ) :: read_lines !< Read (all) lines (records) from a connected unit as a single ascii stream. procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: slice !< Return the raw characters data sliced. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: split_chunked !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. procedure , pass ( self ) :: tempname !< Return a safe temporary name suitable for temporary file or directories. generic :: to_number => & to_integer_I1P ,& #ifndef _NVF to_integer_I2P ,& #endif to_integer_I4P ,& to_integer_I8P ,& #if defined _R16P to_real_R16P , & #endif to_real_R8P , & to_real_R4P !< Cast string to number. procedure , pass ( self ) :: unescape !< Unescape double backslashes (or custom escaped character). procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: write_file !< Write a single string stream into file. procedure , pass ( self ) :: write_line !< Write line (record) to a connected unit. procedure , pass ( self ) :: write_lines !< Write lines (records) to a connected unit. ! inquire methods procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & #if defined _R16P string_assign_real_R16P , & #endif string_assign_real_R8P , & string_assign_real_R4P !< Assignment operator overloading. generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. generic :: operator ( == ) => string_eq_string , & string_eq_character , & character_eq_string !< Equal operator overloading. generic :: operator ( /= ) => string_ne_string , & string_ne_character , & character_ne_string !< Not equal operator overloading. generic :: operator ( < ) => string_lt_string , & string_lt_character , & character_lt_string !< Lower than operator overloading. generic :: operator ( <= ) => string_le_string , & string_le_character , & character_le_string !< Lower equal than operator overloading. generic :: operator ( >= ) => string_ge_string , & string_ge_character , & character_ge_string !< Greater equal than operator overloading. generic :: operator ( > ) => string_gt_string , & string_gt_character , & character_gt_string !< Greater than operator overloading. ! IO generic :: read ( formatted ) => read_formatted !< Formatted input. generic :: write ( formatted ) => write_formatted !< Formatted output. generic :: read ( unformatted ) => read_unformatted !< Unformatted input. generic :: write ( unformatted ) => write_unformatted !< Unformatted output. ! private methods ! builtins replacements procedure , private , pass ( self ) :: sindex_string_string !< Index replacement. procedure , private , pass ( self ) :: sindex_string_character !< Index replacement. procedure , private , pass ( self ) :: srepeat_string_string !< Repeat replacement. procedure , private , nopass :: srepeat_character_string !< Repeat replacement. procedure , private , pass ( self ) :: sscan_string_string !< Scan replacement. procedure , private , pass ( self ) :: sscan_string_character !< Scan replacement. procedure , private , pass ( self ) :: sverify_string_string !< Verify replacement. procedure , private , pass ( self ) :: sverify_string_character !< Verify replacement. ! auxiliary methods procedure , private , pass ( self ) :: colorize_str !< Colorize and stylize strings. procedure , private , pass ( self ) :: glob_character !< Glob search (character output). procedure , private , pass ( self ) :: glob_string !< Glob search (string output). procedure , private , pass ( self ) :: insert_string !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: insert_character !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , nopass :: strjoin_strings !< Return join string of an array of strings. procedure , private , nopass :: strjoin_characters !< Return join string of an array of strings. procedure , private , nopass :: strjoin_strings_array !< Return join 1D string array of an 2D array of strings in columns or rows. procedure , private , nopass :: strjoin_characters_array !< Return join 1D string array of an 2D array of characters in columns or rows. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. #ifndef _NVF procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. #endif procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. ! assignments procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. ! concatenation operators procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). ! logical operators procedure , private , pass ( lhs ) :: string_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: string_eq_character !< Equal to character logical operator. procedure , private , pass ( rhs ) :: character_eq_string !< Equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ne_string !< Not equal to string logical operator. procedure , private , pass ( lhs ) :: string_ne_character !< Not equal to character logical operator. procedure , private , pass ( rhs ) :: character_ne_string !< Not equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_lt_string !< Lower than to string logical operator. procedure , private , pass ( lhs ) :: string_lt_character !< Lower than to character logical operator. procedure , private , pass ( rhs ) :: character_lt_string !< Lower than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_le_string !< Lower equal than to string logical operator. procedure , private , pass ( lhs ) :: string_le_character !< Lower equal than to character logical operator. procedure , private , pass ( rhs ) :: character_le_string !< Lower equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ge_string !< Greater equal than to string logical operator. procedure , private , pass ( lhs ) :: string_ge_character !< Greater equal than to character logical operator. procedure , private , pass ( rhs ) :: character_ge_string !< Greater equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_gt_string !< Greater than to string logical operator. procedure , private , pass ( lhs ) :: string_gt_character !< Greater than to character logical operator. procedure , private , pass ( rhs ) :: character_gt_string !< Greater than to character (inverted) logical operator. ! IO procedure , private , pass ( dtv ) :: read_formatted !< Formatted input. procedure , private , pass ( dtv ) :: read_delimited !< Read a delimited input. procedure , private , pass ( dtv ) :: read_undelimited !< Read an undelimited input. procedure , private , pass ( dtv ) :: read_undelimited_listdirected !< Read an undelimited list directed input. procedure , private , pass ( dtv ) :: write_formatted !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted !< Unformatted output. ! miscellanea procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string ! internal parameters character ( kind = CK , len = 26 ), parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( kind = CK , len = 26 ), parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. character ( kind = CK , len = 1 ), parameter :: SPACE = ' ' !< Space character. character ( kind = CK , len = 1 ), parameter :: TAB = achar ( 9 ) !< Tab character. character ( kind = CK , len = 1 ), parameter :: UIX_DIR_SEP = char ( 47 ) !< Unix/Linux directories separator (/). character ( kind = CK , len = 1 ), parameter :: BACKSLASH = char ( 92 ) !< Backslash character. interface glob !< Overloading glob procedure. !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: alist_chr(:) !< type(string),     allocatable :: alist_str(:) !< integer, parameter            :: Nf=5 !< character(14)                 :: files(1:Nf) !< integer                       :: file_unit !< integer                       :: f !< integer                       :: ff !< logical                       :: test_passed !< do f=1, Nf !<    files(f) = astring%tempname(prefix='foo-') !<    open(newunit=file_unit, file=files(f)) !<    write(file_unit, *)f !<    close(unit=file_unit) !< enddo !< call glob(self=astring, pattern='foo-*', list=alist_chr) !< call glob(self=astring, pattern='foo-*', list=alist_str) !< do f=1, Nf !<    open(newunit=file_unit, file=files(f)) !<    close(unit=file_unit, status='delete') !< enddo !< test_passed = .false. !< outer_chr: do f=1, size(alist_chr, dim=1) !<    do ff=1, Nf !<       test_passed = alist_chr(f) == files(ff) !<       if (test_passed) cycle outer_chr !<    enddo !< enddo outer_chr !< if (test_passed) then !<    test_passed = .false. !<    outer_str: do f=1, size(alist_str, dim=1) !<       do ff=1, Nf !<          test_passed = alist_str(f) == files(ff) !<          if (test_passed) cycle outer_str !<       enddo !<    enddo outer_str !< endif !< print '(L1)', test_passed !<``` !=> T <<< module procedure glob_character , glob_string endinterface glob interface strjoin module procedure strjoin_strings , strjoin_characters , strjoin_strings_array , strjoin_characters_array endinterface strjoin ! builtin overloading interface adjustl !< Builtin adjustl overloading. module procedure sadjustl_character endinterface adjustl interface adjustr !< Builtin adjustr overloading. module procedure sadjustr_character endinterface adjustr interface count !< Builtin count overloading. module procedure count_substring endinterface interface index !< Builtin index overloading. module procedure sindex_string_string , sindex_string_character , sindex_character_string endinterface index !interface len !  !< Builtin len overloading. !  module procedure slen !endinterface len interface len_trim !< Builtin len_trim overloading. module procedure slen_trim endinterface len_trim interface repeat !< Builtin repeat overloading. module procedure srepeat_string_string endinterface repeat interface scan !< Builtin scan overloading. module procedure sscan_string_string , sscan_string_character , sscan_character_string endinterface scan interface trim !< Builtin trim overloading. module procedure strim endinterface trim interface verify !< Builtin verify overloading. module procedure sverify_string_string , sverify_string_character , sverify_character_string endinterface verify contains ! public non TBP ! creator pure function string_ ( c ) !< Return a string given a character input. !< !<```fortran !< print \"(L1)\", string('Hello World')//''=='Hello World' !<``` !=> T <<< character ( * ), intent ( in ) :: c !< Character. type ( string ) :: string_ !< String. string_ % raw = c endfunction string_ ! builtins replacements pure function sadjustl_character ( s ) result ( adjusted ) !< Left adjust a string by removing leading spaces (character output). !< !<```fortran !< type(string) :: astring !< astring = '   Hello World!' !< print \"(L1)\", adjustl(astring)=='Hello World!   ' !<``` !=> T <<< class ( string ), intent ( in ) :: s !< String. character ( kind = CK , len = :), allocatable :: adjusted !< Adjusted string. if ( allocated ( s % raw )) adjusted = adjustl ( s % raw ) endfunction sadjustl_character pure function sadjustr_character ( s ) result ( adjusted ) !< Right adjust a string by removing leading spaces (character output). !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", adjustr(astring)=='   Hello World!' !<``` !=> T <<< class ( string ), intent ( in ) :: s !< String. character ( kind = CK , len = :), allocatable :: adjusted !< Adjusted string. if ( allocated ( s % raw )) adjusted = adjustr ( s % raw ) endfunction sadjustr_character elemental function count_substring ( s , substring ) result ( No ) !< Count the number of occurences of a substring into a string. !< !<```fortran !< print \"(L1)\", count('hello', substring='ll')==1 !<``` !=> T <<< character ( * ), intent ( in ) :: s !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. No = 0 if ( len ( substring ) > len ( s )) return c1 = 1 do c2 = index ( string = s ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo endfunction count_substring elemental function sindex_character_string ( s , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'llo' !< test_passed(1) = index(s='Hello World Hello!', substring=string1)==index(string='Hello World Hello!', substring='llo') !< test_passed(2) = index(s='Hello World Hello!', substring=string1, back=.true.)==index(string='Hello World Hello!', & !<                                                                                       substring='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: s !< String. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( substring % raw )) then i = index ( string = s , substring = substring % raw , back = back ) else i = 0 endif endfunction sindex_character_string elemental function sscan_character_string ( s , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'llo' !< test_passed(1) = scan(s='Hello World Hello!', set=string1)==scan(string='Hello World Hello!', set='llo') !< test_passed(2) = scan(s='Hello World Hello!', set=string1, back=.true.)==scan(string='Hello World Hello!', & !<                                                                               set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: s !< String. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( set % raw )) then i = scan ( string = s , set = set % raw , back = back ) else i = 0 endif endfunction sscan_character_string elemental function sverify_character_string ( s , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'ell' !< test_passed(1) = verify(s='Hello World Hello!', set=string1)==verify(string='Hello World Hello!', set='llo') !< test_passed(2) = verify(s='Hello World Hello!', set=string1, back=.true.)==verify(string='Hello World Hello!', set='llo', & !<                                                                                   back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: s !< String. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( set % raw )) then i = verify ( string = s , set = set % raw , back = back ) else i = 0 endif endfunction sverify_character_string ! public methods ! builtins replacements elemental function sadjustl ( self ) result ( adjusted ) !< Left adjust a string by removing leading spaces. !< !<```fortran !< type(string) :: astring !< astring = '   Hello World!' !< print \"(L1)\", astring%adjustl()//''=='Hello World!   ' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) endfunction sadjustl elemental function sadjustr ( self ) result ( adjusted ) !< Right adjust a string by removing leading spaces. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%adjustr()//''=='   Hello World!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) endfunction sadjustr elemental function scount ( self , substring , ignore_isolated ) result ( No ) !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = '   Hello World  !    ' !< test_passed(1) = astring%count(substring=' ')==10 !< astring = 'Hello World  !    ' !< test_passed(2) = astring%count(substring=' ', ignore_isolated=.true.)==6 !< astring = '    Hello World  !' !< test_passed(3) = astring%count(substring=' ', ignore_isolated=.true.)==6 !< astring = '   Hello World  !    ' !< test_passed(4) = astring%count(substring=' ', ignore_isolated=.true.)==8 !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated c1 = 1 do c2 = index ( string = self % raw ( c1 :), substring = substring ) if ( c2 == 0 ) return if (. not . ignore_isolated_ ) then No = No + 1 else if (. not .(( c1 == 1. and . c2 == 1 ) . or . ( c1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif endfunction scount elemental function sindex_string_string ( self , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !< !<```fortran !< type(string) :: string1 !< type(string) :: string2 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< string2 = 'llo' !< test_passed(1) = string1%index(substring=string2)==index(string='Hello World Hello!', substring='llo') !< test_passed(2) = string1%index(substring=string2, back=.true.)==index(string='Hello World Hello!', substring='llo', & !<                                                                       back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring % raw , back = back ) else i = 0 endif endfunction sindex_string_string elemental function sindex_string_character ( self , substring , back ) result ( i ) !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< test_passed(1) = string1%index(substring='llo')==index(string='Hello World Hello!', substring='llo') !< test_passed(2) = string1%index(substring='llo', back=.true.)==index(string='Hello World Hello!', substring='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif endfunction sindex_string_character elemental function slen ( self ) result ( l ) !< Return the length of a string. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%len()==len('Hello World!   ') !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif endfunction slen elemental function slen_trim ( self ) result ( l ) !< Return the length of a string, ignoring any trailing blanks. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%len_trim()==len_trim('Hello World!   ') !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif endfunction slen_trim elemental function srepeat_string_string ( self , ncopies ) result ( repeated ) !< Concatenates several copies of an input string. !< !<```fortran !< type(string) :: astring !< astring = 'x' !< print \"(L1)\", astring%repeat(5)//''=='xxxxx' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. #ifdef _NVF character ( 9999 ) :: nvf_bug !< Work around for NVFortran bug. #endif #ifdef _NVF nvf_bug = self % raw repeated % raw = repeat ( string = trim ( nvf_bug ), ncopies = ncopies ) #else repeated % raw = repeat ( string = self % raw , ncopies = ncopies ) #endif endfunction srepeat_string_string elemental function srepeat_character_string ( rstring , ncopies ) result ( repeated ) !< Concatenates several copies of an input string. !< !<```fortran !< type(string) :: astring !< astring = 'y' !< print \"(L1)\", astring%repeat('x', 5)//''=='xxxxx' !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. repeated % raw = repeat ( string = rstring , ncopies = ncopies ) endfunction srepeat_character_string elemental function sscan_string_string ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !< !<```fortran !< type(string) :: string1 !< type(string) :: string2 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< string2 = 'llo' !< test_passed(1) = string1%scan(set=string2)==scan(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%scan(set=string2, back=.true.)==scan(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = scan ( string = self % raw , set = set % raw , back = back ) else i = 0 endif endfunction sscan_string_string elemental function sscan_string_character ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< test_passed(1) = string1%scan(set='llo')==scan(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%scan(set='llo', back=.true.)==scan(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif endfunction sscan_string_character elemental function strim ( self ) result ( trimmed ) !< Remove trailing spaces. !< !<```fortran !< type(string) :: astring !< astring = 'Hello World!   ' !< print \"(L1)\", astring%trim()==trim('Hello World!   ') !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) endfunction strim elemental function sverify_string_string ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !< !<```fortran !< type(string) :: string1 !< type(string) :: string2 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< string2 = 'llo' !< test_passed(1) = string1%verify(set=string2)==verify(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%verify(set=string2, back=.true.)==verify(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = verify ( string = self % raw , set = set % raw , back = back ) else i = 0 endif endfunction sverify_string_string elemental function sverify_string_character ( self , set , back ) result ( i ) !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(2) !< string1 = 'Hello World Hello!' !< test_passed(1) = string1%verify(set='llo')==verify(string='Hello World Hello!', set='llo') !< test_passed(2) = string1%verify(set='llo', back=.true.)==verify(string='Hello World Hello!', set='llo', back=.true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif endfunction sverify_string_character ! auxiliary methods elemental function basedir ( self , sep ) !< Return the base directory name of a string containing a file name. !< !<```fortran !< type(string) :: string1 !< logical      :: test_passed(4) !< string1 = '/bar/foo.tar.bz2' !< test_passed(1) = string1%basedir()//''=='/bar' !< string1 = './bar/foo.tar.bz2' !< test_passed(2) = string1%basedir()//''=='./bar' !< string1 = 'bar/foo.tar.bz2' !< test_passed(3) = string1%basedir()//''=='bar' !< string1 = '\\bar\\foo.tar.bz2' !< test_passed(4) = string1%basedir(sep='\\')//''=='\\bar' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif endfunction basedir elemental function basename ( self , sep , extension , strip_last_extension ) !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(5) !< astring = 'bar/foo.tar.bz2' !< test_passed(1) = astring%basename()//''=='foo.tar.bz2' !< test_passed(2) = astring%basename(extension='.tar.bz2')//''=='foo' !< test_passed(3) = astring%basename(strip_last_extension=.true.)//''=='foo.tar' !< astring = '\\bar\\foo.tar.bz2' !< test_passed(4) = astring%basename(sep='\\')//''=='foo.tar.bz2' !< astring = 'bar' !< test_passed(5) = astring%basename(strip_last_extension=.true.)//''=='bar' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) if ( present ( extension )) then pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then pos = index ( basename % raw , '.' , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) endif endif endif endfunction basename elemental function camelcase ( self , sep ) !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(L1)', astring%camelcase()//''=='CamelCaseVar' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !< Return a string with its first character capitalized and the rest lowercased. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%capitalize()//''=='Say all hello world!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif endfunction capitalize pure function chars ( self ) result ( raw ) !< Return the raw characters data. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%chars()=='say all Hello WorLD!' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif endfunction chars pure function colorize_str ( self , color_fg , color_bg , style ) result ( colorized ) !< Colorize and stylize strings, DEFAULT kind. !< !<```fortran !< type(string) :: astring !< astring = 'say all Hello WorLD!' !< print '(L1)', astring%colorize(color_fg='red')=='\u001b[31msay all Hello WorLD!\u001b[0m' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :), allocatable :: colorized !< Colorized string. colorized = colorize ( string = self % chars (), color_fg = color_fg , color_bg = color_bg , style = style ) endfunction colorize_str elemental function decode ( self , codec ) result ( decoded ) !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(L1)', astring%decode(codec='base64')//''=='How are you?' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif endfunction decode elemental function encode ( self , codec ) result ( encoded ) !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(L1)', astring%encode(codec='base64')//''=='SG93IGFyZSB5b3U/' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif endfunction encode elemental function escape ( self , to_escape , esc ) result ( escaped ) !< Escape backslashes (or custom escape character). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '&#94;\\s \\d+\\s*' !< test_passed(1) = astring%escape(to_escape='\\')//''=='&#94;\\\\s \\\\d+\\\\s*' !< test_passed(2) = astring%escape(to_escape='\\', esc='|')//''=='&#94;|\\s |\\d+|\\s*' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif endfunction escape elemental function extension ( self ) !< Return the extension of a string containing a file name. !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(L1)', astring%extension()//''=='.bz2' !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) if ( pos > 0 ) extension % raw = self % raw ( pos :) endif endfunction extension elemental function fill ( self , width , right , filling_char ) result ( filled ) !< Pad string on the left (or right) with zeros (or other char) to fill width. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = 'this is string example....wow!!!' !< test_passed(1) = astring%fill(width=40)//''=='00000000this is string example....wow!!!' !< test_passed(2) = astring%fill(width=50)//''=='000000000000000000this is string example....wow!!!' !< test_passed(3) = astring%fill(width=50, right=.true.)//''=='this is string example....wow!!!000000000000000000' !< test_passed(4) = astring%fill(width=40, filling_char='*')//''=='********this is string example....wow!!!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif endfunction fill elemental subroutine free ( self ) !< Free dynamic memory. !< !<```fortran !< type(string) :: astring !< astring = 'this is string example....wow!!!' !< call astring%free !< print '(L1)', astring%is_allocated().eqv..false. !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. if ( allocated ( self % raw )) deallocate ( self % raw ) endsubroutine free subroutine glob_character ( self , pattern , list ) !< Glob search (character output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. !< !< @note Method not portable: works only on Unix/GNU Linux OS. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: alist_chr(:) !< integer, parameter            :: Nf=5 !< character(14)                 :: files(1:Nf) !< integer                       :: file_unit !< integer                       :: f !< integer                       :: ff !< logical                       :: test_passed !< do f=1, Nf !<    files(f) = astring%tempname(prefix='foo-') !<    open(newunit=file_unit, file=files(f)) !<    write(file_unit, *)f !<    close(unit=file_unit) !< enddo !< call astring%glob(pattern='foo-*', list=alist_chr) !< do f=1, Nf !<    open(newunit=file_unit, file=files(f)) !<    close(unit=file_unit, status='delete') !< enddo !< test_passed = .false. !< outer_chr: do f=1, size(alist_chr, dim=1) !<    do ff=1, Nf !<       test_passed = alist_chr(f) == files(ff) !<       if (test_passed) cycle outer_chr !<    enddo !< enddo outer_chr !< print '(L1)', test_passed !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: pattern !< Given pattern. character ( len = :), allocatable , intent ( out ) :: list (:) !< List of matching pathnames. type ( string ), allocatable :: list_ (:) !< List of matching pathnames. integer ( I4P ) :: max_len !< Maximum length. integer ( I4P ) :: matches_number !< Matches number. integer ( I4P ) :: m !< Counter. call self % glob ( pattern = pattern , list = list_ ) if ( allocated ( list_ )) then matches_number = size ( list_ , dim = 1 ) max_len = 0 do m = 1 , matches_number max_len = max ( max_len , list_ ( m )% len ()) enddo allocate ( character ( max_len ) :: list ( 1 : matches_number )) do m = 1 , matches_number list ( m ) = list_ ( m )% chars () enddo endif endsubroutine glob_character subroutine glob_string ( self , pattern , list ) !< Glob search (string output), finds all the pathnames matching a given pattern according to the rules used by the Unix shell. !< !< @note Method not portable: works only on Unix/GNU Linux OS. !< !<```fortran !< type(string)                  :: astring !< type(string),     allocatable :: alist_str(:) !< integer, parameter            :: Nf=5 !< character(14)                 :: files(1:Nf) !< integer                       :: file_unit !< integer                       :: f !< integer                       :: ff !< logical                       :: test_passed !< !< do f=1, Nf !<    files(f) = astring%tempname(prefix='foo-') !<    open(newunit=file_unit, file=files(f)) !<    write(file_unit, *)f !<    close(unit=file_unit) !< enddo !< call astring%glob(pattern='foo-*', list=alist_str) !< do f=1, Nf !<    open(newunit=file_unit, file=files(f)) !<    close(unit=file_unit, status='delete') !< enddo !< test_passed = .false. !< outer_str: do f=1, size(alist_str, dim=1) !<    do ff=1, Nf !<       test_passed = alist_str(f) == files(ff) !<       if (test_passed) cycle outer_str !<    enddo !< enddo outer_str !< print '(L1)', test_passed !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: pattern !< Given pattern. type ( string ), allocatable , intent ( out ) :: list (:) !< List of matching pathnames. type ( string ) :: tempfile !< Safe temporary file. character ( len = :), allocatable :: tempname !< Safe temporary name. integer ( I4P ) :: tempunit !< Unit of temporary file. tempname = self % tempname () call execute_command_line ( 'ls -1 ' // trim ( adjustl ( pattern )) // ' > ' // tempname ) call tempfile % read_file ( file = tempname ) call tempfile % split ( sep = new_line ( 'a' ), tokens = list ) open ( newunit = tempunit , file = tempname ) close ( unit = tempunit , status = 'delete' ) endsubroutine glob_string elemental function insert_character ( self , substring , pos ) result ( inserted ) !< Insert substring into string at a specified position. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(5) !< astring = 'this is string example wow!!!' !< acharacter = '... ' !< test_passed(1) = astring%insert(substring=acharacter, pos=1)//''=='... this is string example wow!!!' !< test_passed(2) = astring%insert(substring=acharacter, pos=23)//''=='this is string example...  wow!!!' !< test_passed(3) = astring%insert(substring=acharacter, pos=29)//''=='this is string example wow!!!... ' !< test_passed(4) = astring%insert(substring=acharacter, pos=-1)//''=='... this is string example wow!!!' !< test_passed(5) = astring%insert(substring=acharacter, pos=100)//''=='this is string example wow!!!... ' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. if ( allocated ( self % raw )) then inserted = self safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring // self % raw ( safepos :) endif else inserted % raw = substring endif endfunction insert_character elemental function insert_string ( self , substring , pos ) result ( inserted ) !< Insert substring into string at a specified position. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(5) !< astring = 'this is string example wow!!!' !< anotherstring = '... ' !< test_passed(1) = astring%insert(substring=anotherstring, pos=1)//''=='... this is string example wow!!!' !< test_passed(2) = astring%insert(substring=anotherstring, pos=23)//''=='this is string example...  wow!!!' !< test_passed(3) = astring%insert(substring=anotherstring, pos=29)//''=='this is string example wow!!!... ' !< test_passed(4) = astring%insert(substring=anotherstring, pos=-1)//''=='... this is string example wow!!!' !< test_passed(5) = astring%insert(substring=anotherstring, pos=100)//''=='this is string example wow!!!... ' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. if ( allocated ( self % raw )) then inserted = self if ( allocated ( substring % raw )) then safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring % raw // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring % raw else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring % raw // self % raw ( safepos :) endif endif else if ( allocated ( substring % raw )) inserted % raw = substring % raw endif endfunction insert_string pure function join_strings ( self , array , sep ) result ( join ) !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !< !<```fortran !< type(string) :: astring !< type(string) :: strings(3) !< logical      :: test_passed(5) !< strings(1) = 'one' !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(1) = (astring%join(array=strings)//''==strings(1)//strings(2)//strings(3)) !< test_passed(2) = (astring%join(array=strings, sep='-')//''==strings(1)//'-'//strings(2)//'-'//strings(3)) !< call strings(1)%free !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(3) = (astring%join(array=strings, sep='-')//''==strings(2)//'-'//strings(3)) !< strings(1) = 'one' !< strings(2) = 'two' !< call strings(3)%free !< test_passed(4) = (astring%join(array=strings, sep='-')//''==strings(1)//'-'//strings(2)) !< strings(1) = 'one' !< call strings(2)%free !< strings(3) = 'three' !< test_passed(5) = (astring%join(array=strings, sep='-')//''==strings(1)//'-'//strings(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction join_strings pure function join_characters ( self , array , sep ) result ( join ) !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !< !<```fortran !< type(string) :: astring !< character(5) :: characters(3) !< logical      :: test_passed(6) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(1) = (astring%join(array=characters)//''==characters(1)//characters(2)//characters(3)) !< test_passed(2) = (astring%join(array=characters, sep='-')//''==characters(1)//'-'//characters(2)//'-'//characters(3)) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(3) = (astring%join(array=characters, sep='-')//''==characters(2)//'-'//characters(3)) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(4) = (astring%join(array=characters, sep='-')//''==characters(1)//'-'//characters(2)) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(5) = (astring%join(array=characters, sep='-')//''==characters(1)//'-'//characters(3)) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = 'three' !< astring = '_' !< test_passed(6) = (astring%join(array=characters)//''==characters(1)//'_'//characters(2)//'_'//characters(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction join_characters pure function strjoin_strings ( array , sep ) result ( join ) !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< !<```fortran !< type(string)     :: strings(3) !< logical          :: test_passed(5) !< strings(1) = 'one' !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(1) = (strjoin(array=strings)//''==strings(1)//strings(2)//strings(3)) !< test_passed(2) = (strjoin(array=strings, sep='-')//''==strings(1)//'-'//strings(2)//'-'//strings(3)) !< call strings(1)%free !< strings(2) = 'two' !< strings(3) = 'three' !< test_passed(3) = (strjoin(array=strings, sep='-')//''==strings(2)//'-'//strings(3)) !< strings(1) = 'one' !< strings(2) = 'two' !< call strings(3)%free !< test_passed(4) = (strjoin(array=strings, sep='-')//''==strings(1)//'-'//strings(2)) !< strings(1) = 'one' !< call strings(2)%free !< strings(3) = 'three' !< test_passed(5) = (strjoin(array=strings, sep='-')//''==strings(1)//'-'//strings(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. sep_ = '' if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endfunction strjoin_strings pure function strjoin_characters ( array , sep , is_trim ) result ( join ) !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< The trim function is applied to array items if optional logical is_trim variable isn't set to .false. !< !<```fortran !< character(5) :: characters(3) !< logical      :: test_passed(13) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(1) = (strjoin(array=characters)//''==trim(characters(1))//trim(characters(2))//trim(characters(3))) !< test_passed(2) = (strjoin(array=characters, sep='-')//''==trim(characters(1))//'-'//trim(characters(2))//'-'//trim(characters(3))) !< test_passed(3) = ( strjoin(array=characters, is_trim=.false.)//''==characters(1)//characters(2)//characters(3)) !< test_passed(4) = ( strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(1)//'-'//characters(2)//'-'//characters(3)) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(5) = (strjoin(array=characters)//''==trim(characters(2))//trim(characters(3))) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(6) = (strjoin(array=characters)//''==trim(characters(1))//trim(characters(2))) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(7) = (strjoin(array=characters)//''==trim(characters(1))//trim(characters(3))) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(8) = (strjoin(array=characters, sep='-')//''==trim(characters(2))//'-'//trim(characters(3))) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(9) = (strjoin(array=characters, sep='-')//''==trim(characters(1))//'-'//trim(characters(2))) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(10) = (strjoin(array=characters, sep='-')//''==trim(characters(1))//'-'//trim(characters(3))) !< characters(1) = '' !< characters(2) = 'two' !< characters(3) = 'three' !< test_passed(11) = (strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(2)//'-'//characters(3)) !< characters(1) = 'one' !< characters(2) = 'two' !< characters(3) = '' !< test_passed(12) = (strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(1)//'-'//characters(2)) !< characters(1) = 'one' !< characters(2) = '' !< characters(3) = 'three' !< test_passed(13) = (strjoin(array=characters, sep='-', is_trim=.false.)//''==characters(1)//'-'//characters(3)) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. logical , intent ( in ), optional :: is_trim !< Flag to setup trim character or not type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. logical :: is_trim_ !< Flag to setup trim character or not integer :: a !< Counter. sep_ = '' if ( present ( sep )) sep_ = sep is_trim_ = . true . ; if ( present ( is_trim )) is_trim_ = is_trim join = '' if ( is_trim_ ) then do a = 2 , size ( array , dim = 1 ) if ( trim ( array ( a )) /= '' ) join % raw = join % raw // sep_ // trim ( array ( a )) enddo if ( trim ( array ( 1 )) /= '' ) then join % raw = trim ( array ( 1 )) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif else do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif endif endfunction strjoin_characters pure function strjoin_strings_array ( array , sep , is_col ) result ( join ) !< Return a string that is a join of columns or rows of an array of strings. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). !< !<```fortran !< type(string), allocatable :: strings_arr(:, :) !< logical                   :: test_passed(5) !< !< strings_arr = reshape( source = & !<                        [string('one'), string('two'), string('three'),  & !<                         string('ONE'), string('TWO'), string('THREE')], & !<                        shape = [3, 2] ) !< !< test_passed(1) = all( strjoin(array=strings_arr) == & !<                       reshape([string('onetwothree'), string('ONETWOTHREE')], & !<                       shape = [2]) ) !< !< test_passed(2) = all( strjoin(array=strings_arr, sep='_') == & !<                       reshape([string('one_two_three'), string('ONE_TWO_THREE')], & !<                       shape = [2]) ) !< !<  test_passed(3) = all( strjoin(array=strings_arr, is_col=.false.) == & !<                        reshape([string('oneONE'), string('twoTWO'), string('threeTHREE')], & !<                        shape = [3]) ) !< !<  test_passed(4) = all( strjoin(array=strings_arr, sep='_', is_col=.false.) == & !<                        reshape([string('one_ONE'), string('two_TWO'), string('three_THREE')], & !<                        shape = [3]) ) !< !< call strings_arr(2, 1)%free !< test_passed(5) = all( strjoin(array=strings_arr, sep='_', is_col=.false.) == & !<                  reshape([string('one_ONE'), string('TWO'), string('three_THREE')], & !<                  shape = [3]) ) !< !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: array ( 1 :, 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. logical , intent ( in ), optional :: is_col !< Direction: 'columns' if .true. or 'rows' if .false. type ( string ), allocatable :: join (:) !< The join of array. type ( string ), allocatable :: slice (:) !< The column or row slice of array character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. logical :: is_col_ !< Direction, default value. integer :: a , join_size , slice_size !< Counter, sizes of join vector and of slice of array sep_ = '' ; if ( present ( sep )) sep_ = sep is_col_ = . true . ; if ( present ( is_col )) is_col_ = is_col if ( is_col_ ) then join_size = size ( array , dim = 2 ) slice_size = size ( array , dim = 1 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( slice ( slice_size )) do a = 1 , join_size slice (:) = array (:, a ) join ( a ) = strjoin_strings ( slice , sep_ ) end do else join_size = size ( array , dim = 1 ) slice_size = size ( array , dim = 2 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( slice ( slice_size )) do a = 1 , join_size slice (:) = array ( a , :) join ( a ) = strjoin_strings ( slice , sep_ ) end do endif endfunction strjoin_strings_array pure function strjoin_characters_array ( array , sep , is_trim , is_col ) result ( join ) !< Return a string that is a join of columns or rows of an array of characters. !< !< The join-separator is set equals to a null string '' if custom separator isn't specified. !< The trim function is applied to array items if optional logical is_trim variable isn't set to .false. !< The is_col is setup the direction of join: within default columns (.true.) or rows(.false.). !< !<```fortran !< character(len=10)         :: chars_arr(3, 2) !< logical                   :: test_passed(9) !< chars_arr(:, 1) = ['one       ', 'two       ', 'three     '] !< chars_arr(:, 2) = ['ONE       ', 'TWO       ', 'THREE     '] !< !< test_passed(1) = all( strjoin(array=chars_arr) == & !<                       reshape([string('onetwothree'), string('ONETWOTHREE')], & !<                       shape = [2]) ) !< !< test_passed(2) = all( strjoin(array=chars_arr, is_trim=.false.) ==  & !<                       reshape([string('one       two       three     '),  & !<                                string('ONE       TWO       THREE     ')], & !<                       shape = [2]) ) !< !< test_passed(3) = all( strjoin(array=chars_arr, sep='_') == & !<                       reshape([string('one_two_three'), string('ONE_TWO_THREE')], & !<                       shape = [2]) ) !< !< test_passed(4) = all( strjoin(array=chars_arr, sep='_', is_trim=.false.) ==  & !<                       reshape([string('one       _two       _three     '),  & !<                                string('ONE       _TWO       _THREE     ')], & !<                       shape = [2]) ) !< !< test_passed(5) = all( strjoin(array=chars_arr, is_col=.false.) == & !<                       reshape([string('oneONE'), string('twoTWO'), string('threeTHREE')], & !<                       shape = [3]) ) !< !< test_passed(6) = all( strjoin(array=chars_arr, is_trim=.false., is_col=.false.) ==  & !<                       reshape([string('one       ONE       '),  & !<                                string('two       TWO       '),  & !<                                string('three     THREE     ')], & !<                       shape = [3]) ) !< !< test_passed(7) = all( strjoin(array=chars_arr, sep='_', is_col=.false.) == & !<                       reshape([string('one_ONE'), string('two_TWO'), string('three_THREE')], & !<                       shape = [3]) ) !< !< test_passed(8) = all( strjoin(array=chars_arr, sep='_', is_trim=.false., is_col=.false.) ==  & !<                       reshape([string('one       _ONE       '),  & !<                                string('two       _TWO       '),  & !<                                string('three     _THREE     ')], & !<                       shape = [3]) ) !< !< chars_arr(2,1) = '' !< test_passed(9) = all( strjoin(array=chars_arr, sep='_', is_col=.false.) ==  & !<                       reshape([string('one_ONE'),  & !<                                string('TWO'),  & !<                                string('three_THREE')], & !<                       shape = [3]) ) !< !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :, 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. logical , intent ( in ), optional :: is_trim !< Flag to setup trim character or not logical , intent ( in ), optional :: is_col !< Direction: 'columns' if .true. or 'rows' if .false. type ( string ), allocatable :: join (:) !< The join of array. character ( kind = CK , len = :), allocatable :: slice (:) !< The column or row slice of array character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. logical :: is_trim_ !< Flag to setup trim character or not logical :: is_col_ !< Direction, default value. integer :: a , join_size , slice_size !< Counter, sizes of join vector and of slice of array integer :: item_len !< Length of array item (all items of character array have equal lengths) item_len = len ( array ( 1 , 1 )) !< all items of character array have equal lengths sep_ = '' ; if ( present ( sep )) sep_ = sep is_trim_ = . true . ; if ( present ( is_trim )) is_trim_ = is_trim is_col_ = . true . ; if ( present ( is_col )) is_col_ = is_col if ( is_col_ ) then join_size = size ( array , dim = 2 ) slice_size = size ( array , dim = 1 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( character ( len = item_len ) :: slice ( slice_size )) do a = 1 , join_size slice (:) = array (:, a ) join ( a ) = strjoin_characters ( slice , sep_ , is_trim_ ) end do else join_size = size ( array , dim = 1 ) slice_size = size ( array , dim = 2 ) if (. not . allocated ( join )) allocate ( join ( join_size )) if (. not . allocated ( slice )) allocate ( character ( len = item_len ) :: slice ( slice_size )) do a = 1 , join_size slice (:) = array ( a , :) join ( a ) = strjoin_characters ( slice , sep_ , is_trim_ ) end do endif endfunction strjoin_characters_array elemental function lower ( self ) !< Return a string with all lowercase characters. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%lower()//''=='hello world!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif endfunction lower pure function partition ( self , sep ) result ( partitions ) !< Split string at separator and return the 3 parts (before, the separator and after). !< !<```fortran !< type(string) :: astring !< type(string) :: strings(3) !< logical      :: test_passed(3) !< astring = 'Hello WorLD!' !< strings = astring%partition(sep='lo Wo') !< test_passed(1) = (strings(1)//''=='Hel'.and.strings(2)//''=='lo Wo'.and.strings(3)//''=='rLD!') !< strings = astring%partition(sep='Hello') !< test_passed(2) = (strings(1)//''==''.and.strings(2)//''=='Hello'.and.strings(3)//''==' WorLD!') !< astring = 'Hello WorLD!' !< strings = astring%partition() !< test_passed(3) = (strings(1)//''=='Hello'.and.strings(2)//''==' '.and.strings(3)//''=='WorLD!') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) endif endif endfunction partition subroutine read_file ( self , file , is_fast , form , iostat , iomsg ) !< Read a file as a single string stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !< @note *Fast* file reading allows a very efficient reading of streamed file, but it dumps file as single streamed string. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(9) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, file='read_file_test.tmp') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< close(scratch) !< call astring%read_file(file='read_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< close(scratch) !< call astring%read_file(file='read_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='read_file_test.tmp', form='UNFORMATTED', access='STREAM') !< close(scratch, status='DELETE') !< call astring%read_file(file='read_file_test.tmp', iostat=iostat) !< test_passed(9) = (iostat/=0) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. logical , intent ( in ), optional :: is_fast !< Flag to enable (super) fast file reading. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. logical :: is_fast_ !< Flag to enable (super) fast file reading, local variable. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. integer ( I4P ) :: filesize !< Size of the file for fast reading. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then is_fast_ = . false . ; if ( present ( is_fast )) is_fast_ = is_fast if ( is_fast_ ) then open ( newunit = unit , file = file , access = 'STREAM' , form = 'UNFORMATTED' , iomsg = iomsg_ , iostat = iostat_ ) inquire ( file = file , size = filesize ) if ( allocated ( self % raw )) deallocate ( self % raw ) allocate ( character ( len = filesize ) :: self % raw ) read ( unit = unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw close ( unit ) else form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % read_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif else iostat_ = 1 iomsg_ = 'file not found' endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_file subroutine read_line ( self , unit , form , iostat , iomsg ) !< Read line (record) from a connected unit. !< !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)      :: astring !< type(string)      :: line(3) !< integer           :: iostat !< character(len=99) :: iomsg !< integer           :: scratch !< integer           :: l !< logical           :: test_passed(6) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, status='SCRATCH') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< rewind(scratch) !< l = 0 !< iostat = 0 !< do !<   l = l + 1 !<   call astring%read_line(unit=scratch, iostat=iostat, iomsg=iomsg) !<   if (iostat/=0.and..not.is_iostat_eor(iostat)) then !<     exit !<   else !<     test_passed(l) = (astring==line(l)) !<   endif !< enddo !< close(scratch) !< open(newunit=scratch, status='SCRATCH', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< rewind(scratch) !< l = 0 !< iostat = 0 !< do !<   l = l + 1 !<   call astring%read_line(unit=scratch, iostat=iostat, iomsg=iomsg, form='UnfORMatteD') !<   if (iostat/=0.and..not.is_iostat_eor(iostat)) then !<     exit !<   else !<     test_passed(l+3) = (astring==line(l)) !<   endif !< enddo !< close(scratch) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = :), allocatable :: line !< Line storage. character ( kind = CK , len = 1 ) :: ch !< Character storage. form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg line = '' select case ( form_ % chars ()) case ( 'FORMATTED' ) do read ( unit , \"(A)\" , advance = 'no' , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 , eor = 10 ) ch line = line // ch enddo case ( 'UNFORMATTED' ) do read ( unit , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) then iostat_ = iostat_eor exit endif line = line // ch enddo endselect 10 if ( line /= '' ) self % raw = line if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_line subroutine read_lines ( self , unit , form , iostat , iomsg ) !< Read (all) lines (records) from a connected unit as a single ascii stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. The line is read as an ascii stream read until the eor is reached. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< open(newunit=scratch, status='SCRATCH') !< write(scratch, \"(A)\") line(1)%chars() !< write(scratch, \"(A)\") line(2)%chars() !< write(scratch, \"(A)\") line(3)%chars() !< call astring%read_lines(unit=scratch, iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< close(scratch) !< open(newunit=scratch, status='SCRATCH', form='UNFORMATTED', access='STREAM') !< write(scratch) line(1)%chars()//new_line('a') !< write(scratch) line(2)%chars()//new_line('a') !< write(scratch) line(3)%chars()//new_line('a') !< call astring%read_lines(unit=scratch, form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< close(scratch) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. type ( string ) :: lines !< Lines storage. type ( string ) :: line !< Line storage. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) iostat_ = 0 lines % raw = '' do line % raw = '' call line % read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if ( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )) then exit elseif ( line /= '' ) then lines % raw = lines % raw // line % raw // new_line ( 'a' ) endif enddo if ( lines % raw /= '' ) self % raw = lines % raw if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine read_lines elemental function replace ( self , old , new , count ) result ( replaced ) !< Return a string with all occurrences of substring old replaced by new. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(3) !< astring = 'When YOU are sad YOU should think to me :-)' !< test_passed(1) = (astring%replace(old='YOU', new='THEY')//''=='When THEY are sad THEY should think to me :-)') !< test_passed(2) = (astring%replace(old='YOU', new='THEY', count=1)//''=='When THEY are sad YOU should think to me :-)') !< astring = repeat(new_line('a')//'abcd', 20) !< astring = astring%replace(old=new_line('a'), new='|cr|') !< astring = astring%replace(old='|cr|', new=new_line('a')//'    ') !< test_passed(3) = (astring//''==repeat(new_line('a')//'    '//'abcd', 20)) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif endfunction replace elemental function reverse ( self ) result ( reversed ) !< Return a reversed string. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = 'abcdefghilmnopqrstuvz' !< test_passed(1) = (astring%reverse()//''=='zvutsrqponmlihgfedcba') !< astring = '0123456789' !< test_passed(2) = (astring%reverse()//''=='9876543210') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif endfunction reverse function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. !< !<```fortran !< type(string)                  :: astring !< type(string)                  :: anotherstring !< character(len=:), allocatable :: acharacter !< integer                       :: istart !< integer                       :: iend !< logical                       :: test_passed(5) !< astring = '<test> <first> hello </first> <first> not the first </first> </test>' !< anotherstring = astring%search(tag_start='<first>', tag_end='</first>') !< test_passed(1) = anotherstring//''=='<first> hello </first>' !< astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' !< anotherstring = astring%search(tag_start='<a>', tag_end='</a>') !< test_passed(2) = anotherstring//''=='<a> <a> <a> the nested a </a> </a> </a>' !< call astring%free !< anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' !< astring = astring%search(in_string=anotherstring, tag_start='<a>', tag_end='</a>') !< test_passed(3) = astring//''=='<a> <a> <a> the nested a </a> </a> </a>' !< call astring%free !< acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' !< astring = astring%search(in_character=acharacter, tag_start='<a>', tag_end='</a>') !< test_passed(4) = astring//''=='<a> <a> <a> the nested a </a> </a> </a>' !< acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' !< astring = astring%search(in_character=acharacter, tag_start='<sec>', tag_end='</sec>', istart=istart, iend=iend) !< test_passed(5) = astring//''==acharacter(31:67) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) raw = self % raw endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % count ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ endfunction search pure function slice ( self , istart , iend ) result ( raw ) !< Return the raw characters data sliced. !< !<```fortran !< type(string) :: astring !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< print \"(A)\", astring%slice(11,25) !<``` !=> Brown fox Jumps <<< class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: istart !< Slice start index. integer , intent ( in ) :: iend !< Slice end   index. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. if ( allocated ( self % raw )) then raw = self % raw ( istart : iend ) else raw = '' endif endfunction slice elemental function snakecase ( self , sep ) !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< test_passed(1) = astring%snakecase()//''=='the_quick_brown_fox_jumps_over_the_lazy_dog.' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif endfunction snakecase pure subroutine split ( self , tokens , sep , max_tokens ) !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurrence. !< !< @note If `max_tokens` is passed the returned number of tokens is either `max_tokens` or `max_tokens + 1`. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< logical                   :: test_passed(11) !< astring = '+ab-++cre-++cre-ab+' !< call astring%split(tokens=strings, sep='+') !< test_passed(1) = (strings(1)//''=='ab-'.and.strings(2)//''=='cre-'.and.strings(3)//''=='cre-ab') !< astring = 'ab-++cre-++cre-ab+' !< call astring%split(tokens=strings, sep='+') !< test_passed(2) = (strings(1)//''=='ab-'.and.strings(2)//''=='cre-'.and.strings(3)//''=='cre-ab') !< astring = 'ab-++cre-++cre-ab' !< call astring%split(tokens=strings, sep='+') !< test_passed(3) = (strings(1)//''=='ab-'.and.strings(2)//''=='cre-'.and.strings(3)//''=='cre-ab') !< astring = 'Hello '//new_line('a')//'World!' !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(4) = (strings(1)//''=='Hello '.and.strings(2)//''=='World!') !< astring = 'Hello World!' !< call astring%split(tokens=strings) !< test_passed(5) = (strings(1)//''=='Hello'.and.strings(2)//''=='World!') !< astring = '+ab-' !< call astring%split(tokens=strings, sep='+') !< test_passed(6) = (strings(1)//''=='ab-') !< astring = '+ab-' !< call astring%split(tokens=strings, sep='-') !< test_passed(7) = (strings(1)//''=='+ab') !< astring = '+ab-+cd-' !< call astring%split(tokens=strings, sep='+') !< test_passed(8) = (strings(1)//''=='ab-'.and.strings(2)//''=='cd-') !< astring = 'ab-+cd-+' !< call astring%split(tokens=strings, sep='+') !< test_passed(9) = (strings(1)//''=='ab-'.and.strings(2)//''=='cd-') !< astring = '+ab-+cd-+' !< call astring%split(tokens=strings, sep='+') !< test_passed(10) = (strings(1)//''=='ab-'.and.strings(2)//''=='cd-') !< astring = '1-2-3-4-5-6-7-8' !< call astring%split(tokens=strings, sep='-', max_tokens=3) !< test_passed(11) = (strings(1)//''=='1'.and.strings(2)//''=='2'.and.strings(3)//''=='3'.and.strings(4)//''=='4-5-6-7-8') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. integer , intent ( in ), optional :: max_tokens !< Fix the maximum number of returned tokens. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % count ( sep_ ) if ( No > 0 ) then if ( present ( max_tokens )) then if ( max_tokens < No . and . max_tokens > 0 ) No = max_tokens endif allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No - 1 tokens ( t ) = temp_toks ( 1 , t + 1 ) enddo tokens ( No ) = temp_toks ( 3 , No ) else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif else allocate ( tokens ( 1 )) tokens ( 1 ) = self endif endif endsubroutine split pure subroutine split_chunked ( self , tokens , chunks , sep ) !< Return a list of substring in the string, using sep as the delimiter string, chunked (memory-efficient) algorithm. !< !< @note Multiple subsequent separators are collapsed to one occurrence. !< !< @note The split is performed in chunks of `#chunks` to avoid excessive memory consumption. !< !<```fortran !< type(string)              :: astring !< type(string), allocatable :: strings(:) !< logical                   :: test_passed(1) !< astring = '-1-2-3-4-5-6-7-8-' !< call astring%split_chunked(tokens=strings, sep='-', chunks=3) !< test_passed(1) = (strings(1)//''=='1'.and.strings(2)//''=='2'.and.strings(3)//''=='3'.and.strings(4)//''=='4'.and. & !<                   strings(5)//''=='5'.and.strings(6)//''=='6'.and.strings(7)//''=='7'.and.strings(8)//''=='8') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. integer , intent ( in ) :: chunks !< Number of chunks. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: Nt !< Number of actual tokens. integer :: t !< Counter. logical :: isok if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep Nt = self % count ( sep_ ) if ( self % start_with ( prefix = sep_ )) Nt = Nt - 1 if ( self % end_with ( suffix = sep_ )) Nt = Nt - 1 t = 0 call self % split ( tokens = tokens , sep = sep_ , max_tokens = chunks ) do t = size ( tokens , dim = 1 ) if ( t > Nt ) exit call split_last_token ( tokens = tokens , max_tokens = chunks , isok = isok ) if ( isok ) then else exit endif enddo t = size ( tokens , dim = 1 ) if ( tokens ( t )% count ( sep_ ) > 0 ) then call split_last_token ( tokens = tokens , isok = isok ) endif endif contains pure subroutine split_last_token ( tokens , max_tokens , isok ) !< Split last token. type ( string ), allocatable , intent ( inout ) :: tokens (:) !< Tokens substring. integer , intent ( in ), optional :: max_tokens !< Max tokens returned. type ( string ), allocatable :: tokens_ (:) !< Temporary tokens. type ( string ), allocatable :: tokens_swap (:) !< Swap tokens. integer :: Nt_ !< Number of last created tokens. logical , intent ( out ) :: isok isok = . true . call tokens ( t )% split ( tokens = tokens_ , sep = sep_ , max_tokens = max_tokens ) if ( allocated ( tokens_ )) then Nt_ = size ( tokens_ , dim = 1 ) if ( Nt_ >= 1 ) then allocate ( tokens_swap ( 1 : t - 1 + Nt_ )) tokens_swap ( 1 : t - 1 ) = tokens ( 1 : t - 1 ) tokens_swap ( t :) = tokens_ (:) call move_alloc ( from = tokens_swap , to = tokens ) endif if ( Nt_ == 1 ) then isok = . false . end if deallocate ( tokens_ ) endif endsubroutine split_last_token endsubroutine split_chunked elemental function startcase ( self , sep ) !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< test_passed(1) = astring%startcase()//''=='The Quick Brown Fox Jumps Over The Lazy Dog.' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif endfunction startcase elemental function strip ( self , remove_nulls ) !< Return a copy of the string with the leading and trailing characters removed. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = '  Hello World!   ' !< test_passed(1) = astring%strip()//''=='Hello World!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: remove_nulls !< Remove null characters at the end. type ( string ) :: strip !< The stripped string. integer :: c !< Counter. if ( allocated ( self % raw )) then strip = self % adjustl () strip = strip % trim () if ( present ( remove_nulls )) then if ( remove_nulls ) then c = index ( self % raw , char ( 0 )) if ( c > 0 ) strip % raw = strip % raw ( 1 : c - 1 ) endif endif endif endfunction strip elemental function swapcase ( self ) !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = '  Hello World!   ' !< test_passed(1) = astring%swapcase()//''=='  hELLO wORLD!   ' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif endfunction swapcase function tempname ( self , is_file , prefix , path ) !< Return a safe temporary name suitable for temporary file or directories. !< !<```fortran !< type(string) :: astring !< character(len=:), allocatable :: tmpname !< logical                       :: test_passed(5) !< tmpname = astring%tempname() !< inquire(file=tmpname, exist=test_passed(1)) !< test_passed(1) = .not.test_passed(1) !< tmpname = astring%tempname(is_file=.false.) !< inquire(file=tmpname, exist=test_passed(2)) !< test_passed(2) = .not.test_passed(2) !< tmpname = astring%tempname(path='./') !< inquire(file=tmpname, exist=test_passed(3)) !< test_passed(3) = .not.test_passed(3) !< astring = 'me-' !< tmpname = astring%tempname() !< inquire(file=tmpname, exist=test_passed(4)) !< test_passed(4) = .not.test_passed(4) !< tmpname = astring%tempname(prefix='you-') !< inquire(file=tmpname, exist=test_passed(5)) !< test_passed(5) = .not.test_passed(5) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: is_file !< True if tempname should be used for file (the default). character ( * ), intent ( in ), optional :: prefix !< Name prefix, otherwise self is used (if allocated). character ( * ), intent ( in ), optional :: path !< Path where file/directory should be used, default `./`. character ( len = :), allocatable :: tempname !< Safe (unique) temporary name. logical :: is_file_ !< True if tempname should be used for file (the default). character ( len = :), allocatable :: prefix_ !< Name prefix, otherwise self is used (if allocated). character ( len = :), allocatable :: path_ !< Path where file/directory should be used, default `./`. logical , save :: is_initialized = . false . !< Status of random seed initialization. real ( R4P ) :: random_real !< Random number (real). integer ( I4P ) :: random_integer !< Random number (integer). logical :: is_hold !< Flag to check if a safe tempname has been found. is_file_ = . true . ; if ( present ( is_file )) is_file_ = is_file path_ = '' ; if ( present ( path )) path_ = path prefix_ = '' if ( present ( prefix )) then prefix_ = prefix elseif ( allocated ( self % raw )) then prefix_ = self % raw endif if (. not . is_initialized ) then call random_seed is_initialized = . true . endif tempname = repeat ( ' ' , len ( path_ ) + len ( prefix_ ) + 10 ) ! [path_] + [prefix_] + 6 random chars + [.tmp] do call random_number ( random_real ) random_integer = transfer ( random_real , random_integer ) random_integer = iand ( random_integer , 16777215_I4P ) if ( is_file_ ) then write ( tempname , '(A,Z6.6,A)' ) path_ // prefix_ , random_integer , '.tmp' else write ( tempname , '(A,Z6.6)' ) path_ // prefix_ , random_integer tempname = trim ( tempname ) endif inquire ( file = tempname , exist = is_hold ) if (. not . is_hold ) exit enddo endfunction tempname elemental function to_integer_I1P ( self , kind ) result ( to_number ) !< Cast string to integer (I1P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I1P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I1P) !< test_passed(1) = integer_==127_I1P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I1P #ifndef _NVF elemental function to_integer_I2P ( self , kind ) result ( to_number ) !< Cast string to integer (I2P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I2P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I2P) !< test_passed(1) = integer_==127_I2P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I2P #endif elemental function to_integer_I4P ( self , kind ) result ( to_number ) !< Cast string to integer (I4P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I4P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I4P) !< test_passed(1) = integer_==127_I4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I4P elemental function to_integer_I8P ( self , kind ) result ( to_number ) !< Cast string to integer (I8P). !< !<```fortran !< use penf !< type(string) :: astring !< integer(I8P) :: integer_ !< logical      :: test_passed(1) !< astring = '127' !< integer_ = astring%to_number(kind=1_I8P) !< test_passed(1) = integer_==127_I8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif endfunction to_integer_I8P elemental function to_real_R4P ( self , kind ) result ( to_number ) !< Cast string to real (R4P). !< !<```fortran !< use penf !< type(string) :: astring !< real(R4P)    :: real_ !< logical      :: test_passed(1) !< astring = '3.4e9' !< real_ = astring%to_number(kind=1._R4P) !< test_passed(1) = real_==3.4e9_R4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R4P elemental function to_real_R8P ( self , kind ) result ( to_number ) !< Cast string to real (R8P). !< !<```fortran !< use penf !< type(string) :: astring !< real(R8P)    :: real_ !< logical      :: test_passed(1) !< astring = '3.4e9' !< real_ = astring%to_number(kind=1._R8P) !< test_passed(1) = real_==3.4e9_R8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R8P elemental function to_real_R16P ( self , kind ) result ( to_number ) !< Cast string to real (R16P). !< !<```fortran !< use penf !< type(string) :: astring !< real(R16P)   :: real_ !< logical      :: test_passed(1) !< astring = '3.4e9' !< real_ = astring%to_number(kind=1._R16P) !< test_passed(1) = real_==3.4e9_R16P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif endfunction to_real_R16P elemental function unescape ( self , to_unescape , unesc ) result ( unescaped ) !< Unescape double backslashes (or custom escaped character). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '&#94;\\\\s \\\\d+\\\\s*' !< test_passed(1) = (astring%unescape(to_unescape='\\')//''=='&#94;\\s \\d+\\s*') !< test_passed(2) = (astring%unescape(to_unescape='s')//''=='&#94;\\s \\\\d+\\s*') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_unescape !< Character to be unescaped. character ( kind = CK , len =* ), intent ( in ), optional :: unesc !< Character used to unescape. type ( string ) :: unescaped !< Escaped string. character ( kind = CK , len = :), allocatable :: unesc_ !< Character to unescape, local variable. integer :: c !< Character counter. if ( allocated ( self % raw )) then unesc_ = '' ; if ( present ( unesc )) unesc_ = unesc unescaped % raw = '' c = 1 do if ( c > len ( self % raw )) exit if ( c == len ( self % raw )) then unescaped % raw = unescaped % raw // self % raw ( c : c ) exit else if ( self % raw ( c : c + 1 ) == BACKSLASH // to_unescape ) then unescaped % raw = unescaped % raw // to_unescape c = c + 2 else unescaped % raw = unescaped % raw // self % raw ( c : c ) c = c + 1 endif endif enddo endif endfunction unescape elemental function unique ( self , substring ) result ( uniq ) !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = '+++ab-++cre-++cre-ab+++++' !< test_passed(1) = astring%unique(substring='+')//''=='+ab-+cre-+cre-ab+' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. #ifdef _NVF character ( 9999 ) :: nvf_bug !< Work around for NVFortran bug. #endif if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do #ifdef _NVF nvf_bug = substring_ if (. not . uniq % index ( repeat ( trim ( nvf_bug ), 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( trim ( nvf_bug ), 2 ), new = substring_ ) #else if (. not . uniq % index ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) #endif enddo endif endfunction unique elemental function upper ( self ) !< Return a string with all uppercase characters. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%upper()//''=='HELLO WORLD!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif endfunction upper subroutine write_file ( self , file , form , iostat , iomsg ) !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !< !<```fortran !< type(string)              :: astring !< type(string)              :: anotherstring !< type(string), allocatable :: strings(:) !< type(string)              :: line(3) !< integer                   :: iostat !< character(len=99)         :: iomsg !< integer                   :: scratch !< integer                   :: l !< logical                   :: test_passed(8) !< line(1) = ' Hello World!   ' !< line(2) = 'How are you?  ' !< line(3) = '   All say: \"Fine thanks\"' !< anotherstring = anotherstring%join(array=line, sep=new_line('a')) !< call anotherstring%write_file(file='write_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(1) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+1) = (strings(l)==line(l)) !< enddo !< call anotherstring%write_file(file='write_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%read_file(file='write_file_test.tmp', form='unformatted', iostat=iostat, iomsg=iomsg) !< call astring%split(tokens=strings, sep=new_line('a')) !< test_passed(5) = (size(strings, dim=1)==size(line, dim=1)) !< do l=1, size(strings, dim=1) !<   test_passed(l+5) = (strings(l)==line(l)) !< enddo !< open(newunit=scratch, file='write_file_test.tmp') !< close(unit=scratch, status='delete') !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % write_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_file subroutine write_line ( self , unit , form , iostat , iomsg ) !< Write line (record) to a connected unit. !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !< !< @note There is no doctests, this being tested by means of [[string:write_file]] doctests. class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. iostat_ = 0 iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg if ( allocated ( self % raw )) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) write ( unit , \"(A)\" , iostat = iostat_ , iomsg = iomsg_ ) self % raw case ( 'UNFORMATTED' ) if ( self % end_with ( new_line ( 'a' ))) then write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw else write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw // new_line ( 'a' ) endif endselect endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ endsubroutine write_line subroutine write_lines ( self , unit , form , iostat , iomsg ) !< Write lines (records) to a connected unit. !< !< This method checks if self contains more than one line (records) and writes them as lines (records). !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !< !< @note There is no doctests, this being tested by means of [[string:write_file]] doctests. class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ), allocatable :: lines (:) !< Lines. integer :: l !< Counter. if ( allocated ( self % raw )) then call self % split ( tokens = lines , sep = new_line ( 'a' )) do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endif endsubroutine write_lines ! inquire elemental function end_with ( self , suffix , start , end , ignore_null_eof ) !< Return true if a string ends with a specified suffix. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(5) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%end_with(suffix='LD!').eqv..true. !< test_passed(2) = astring%end_with(suffix='lD!').eqv..false. !< test_passed(3) = astring%end_with(suffix='orLD!', start=5).eqv..true. !< test_passed(4) = astring%end_with(suffix='orLD!', start=8, end=12).eqv..true. !< test_passed(5) = astring%end_with(suffix='!').eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical , intent ( in ), optional :: ignore_null_eof !< Ignore null character at the end of file. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. logical :: ignore_null_eof_ !< Ignore null character at the end of file, local variable. end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end ignore_null_eof_ = . false . ; if ( present ( ignore_null_eof )) ignore_null_eof_ = ignore_null_eof if ( ignore_null_eof_ . and .( self % raw ( end_ : end_ ) == char ( 0 ))) end_ = end_ - 1 if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = self % raw ( end_ - len ( suffix ) + 1 : end_ ) == suffix endif endif endfunction end_with elemental function is_allocated ( self ) !< Return true if the string is allocated. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< test_passed(1) = astring%is_allocated().eqv..false. !< astring = 'hello' !< test_passed(2) = astring%is_allocated().eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. is_allocated = allocated ( self % raw ) endfunction is_allocated elemental function is_digit ( self ) !< Return true if all characters in the string are digits. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(2) !< astring = '   -1212112.3 ' !< test_passed(1) = astring%is_digit().eqv..false. !< astring = '12121123' !< test_passed(2) = astring%is_digit().eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif endfunction is_digit elemental function is_integer ( self , allow_spaces ) !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(6) !< astring = '   -1212112 ' !< test_passed(1) = astring%is_integer().eqv..true. !< astring = '   -1212112' !< test_passed(2) = astring%is_integer(allow_spaces=.false.).eqv..false. !< astring = '-1212112   ' !< test_passed(3) = astring%is_integer(allow_spaces=.false.).eqv..false. !< astring = '+2e20' !< test_passed(4) = astring%is_integer().eqv..true. !< astring = ' -2E13 ' !< test_passed(5) = astring%is_integer().eqv..true. !< astring = ' -2 E13 ' !< test_passed(6) = astring%is_integer().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif endfunction is_integer elemental function is_lower ( self ) !< Return true if all characters in the string are lowercase. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(3) !< astring = ' Hello World' !< test_passed(1) = astring%is_lower().eqv..false. !< astring = ' HELLO WORLD' !< test_passed(2) = astring%is_lower().eqv..false. !< astring = ' hello world' !< test_passed(3) = astring%is_lower().eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif endfunction is_lower elemental function is_number ( self , allow_spaces ) !< Return true if the string contains a number (real or integer). !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(7) !< astring = '   -1212112 ' !< test_passed(1) = astring%is_number().eqv..true. !< astring = '   -121.2112 ' !< test_passed(2) = astring%is_number().eqv..true. !< astring = '   -1212112' !< test_passed(3) = astring%is_number(allow_spaces=.false.).eqv..false. !< astring = '-12121.12   ' !< test_passed(4) = astring%is_number(allow_spaces=.false.).eqv..false. !< astring = '+2e20' !< test_passed(5) = astring%is_number().eqv..true. !< astring = ' -2.4E13 ' !< test_passed(6) = astring%is_number().eqv..true. !< astring = ' -2 E13 ' !< test_passed(7) = astring%is_number().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) endfunction is_number elemental function is_real ( self , allow_spaces ) !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(6) !< astring = '   -1212112.d0 ' !< test_passed(1) = astring%is_real().eqv..true. !< astring = '   -1212112.d0' !< test_passed(2) = astring%is_real(allow_spaces=.false.).eqv..false. !< astring = '-1212112.d0   ' !< test_passed(3) = astring%is_real(allow_spaces=.false.).eqv..false. !< astring = '+2.e20' !< test_passed(4) = astring%is_real().eqv..true. !< astring = ' -2.01E13 ' !< test_passed(5) = astring%is_real().eqv..true. !< astring = ' -2.01 E13 ' !< test_passed(6) = astring%is_real().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif endfunction is_real elemental function is_upper ( self ) !< Return true if all characters in the string are uppercase. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(3) !< astring = ' Hello World' !< test_passed(1) = astring%is_upper().eqv..false. !< astring = ' HELLO WORLD' !< test_passed(2) = astring%is_upper().eqv..true. !< astring = ' hello world' !< test_passed(3) = astring%is_upper().eqv..false. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif endfunction is_upper elemental function start_with ( self , prefix , start , end ) !< Return true if a string starts with a specified prefix. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(4) !< astring = 'Hello WorLD!' !< test_passed(1) = astring%start_with(prefix='Hello').eqv..true. !< test_passed(2) = astring%start_with(prefix='hell').eqv..false. !< test_passed(3) = astring%start_with(prefix='llo Wor', start=3).eqv..true. !< test_passed(4) = astring%start_with(prefix='lo W', start=4, end=7).eqv..true. !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif endfunction start_with ! private methods ! assignments pure subroutine string_assign_string ( lhs , rhs ) !< Assignment operator from string input. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(1) !< astring = 'hello' !< anotherstring = astring !< test_passed(1) = astring%chars()==anotherstring%chars() !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( rhs % raw )) lhs % raw = rhs % raw endsubroutine string_assign_string pure subroutine string_assign_character ( lhs , rhs ) !< Assignment operator from character input. !< !<```fortran !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 'hello' !< test_passed(1) = astring%chars()=='hello' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. lhs % raw = rhs endsubroutine string_assign_character pure subroutine string_assign_integer_I1P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I1P !< test_passed(1) = astring%to_number(kind=1_I1P)==127_I1P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I1P pure subroutine string_assign_integer_I2P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I2P !< test_passed(1) = astring%to_number(kind=1_I2P)==127_I2P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I2P pure subroutine string_assign_integer_I4P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I4P !< test_passed(1) = astring%to_number(kind=1_I4P)==127_I4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I4P pure subroutine string_assign_integer_I8P ( lhs , rhs ) !< Assignment operator from integer input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 127_I8P !< test_passed(1) = astring%to_number(kind=1_I8P)==127_I8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_integer_I8P pure subroutine string_assign_real_R4P ( lhs , rhs ) !< Assignment operator from real input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 3.021e6_R4P !< test_passed(1) = astring%to_number(kind=1._R4P)==3.021e6_R4P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R4P pure subroutine string_assign_real_R8P ( lhs , rhs ) !< Assignment operator from real input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 3.021e6_R8P !< test_passed(1) = astring%to_number(kind=1._R8P)==3.021e6_R8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R8P pure subroutine string_assign_real_R16P ( lhs , rhs ) !< Assignment operator from real input. !< !<```fortran !< use penf !< type(string) :: astring !< logical      :: test_passed(1) !< astring = 3.021e6_R8P !< test_passed(1) = astring%to_number(kind=1._R8P)==3.021e6_R8P !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. lhs % raw = trim ( str ( rhs )) endsubroutine string_assign_real_R16P ! contatenation operators pure function string_concat_string ( lhs , rhs ) result ( concat ) !< Concatenation with string. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(1) !< astring = 'Hello ' !< anotherstring = 'Bye bye' !< test_passed(1) = astring//anotherstring=='Hello Bye bye' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw endfunction string_concat_string pure function string_concat_character ( lhs , rhs ) result ( concat ) !< Concatenation with character. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< test_passed(1) = astring//acharacter=='Hello World!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif endfunction string_concat_character pure function character_concat_string ( lhs , rhs ) result ( concat ) !< Concatenation with character (inverted). !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< test_passed(1) = acharacter//astring=='World!Hello ' !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif endfunction character_concat_string elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !< Concatenation with string. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< type(string) :: yetanotherstring !< logical      :: test_passed(1) !< astring = 'Hello ' !< anotherstring = 'Bye bye' !< yetanotherstring = astring.cat.anotherstring !< test_passed(1) = yetanotherstring%chars()=='Hello Bye bye' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary endfunction string_concat_string_string elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !< Concatenation with character. !< !<```fortran !< type(string)                  :: astring !< type(string)                  :: yetanotherstring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< yetanotherstring = astring.cat.acharacter !< test_passed(1) = yetanotherstring%chars()=='Hello World!' !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif endfunction string_concat_character_string elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !< Concatenation with character (inverted). !< !<```fortran !< type(string)                  :: astring !< type(string)                  :: yetanotherstring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(1) !< astring = 'Hello ' !< acharacter = 'World!' !< yetanotherstring = acharacter.cat.astring !< test_passed(1) = yetanotherstring%chars()=='World!Hello ' !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif endfunction character_concat_string_string ! logical operators elemental function string_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = '  one ' !< anotherstring = 'two' !< test_passed(1) = ((astring==anotherstring).eqv..false.) !< astring = 'the same ' !< anotherstring = 'the same ' !< test_passed(2) = ((astring==anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw == rhs % raw endfunction string_eq_string elemental function string_eq_character ( lhs , rhs ) result ( is_it ) !< Equal to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((astring==acharacter).eqv..false.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((astring==acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw == rhs endfunction string_eq_character elemental function character_eq_string ( lhs , rhs ) result ( is_it ) !< Equal to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((acharacter==astring).eqv..false.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((acharacter==astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = rhs % raw == lhs endfunction character_eq_string elemental function string_ne_string ( lhs , rhs ) result ( is_it ) !< Not equal to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = '  one ' !< anotherstring = 'two' !< test_passed(1) = ((astring/=anotherstring).eqv..true.) !< astring = 'the same ' !< anotherstring = 'the same ' !< test_passed(2) = ((astring/=anotherstring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw /= rhs % raw endfunction string_ne_string elemental function string_ne_character ( lhs , rhs ) result ( is_it ) !< Not equal to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((astring/=acharacter).eqv..true.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((astring/=acharacter).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw /= rhs endfunction string_ne_character elemental function character_ne_string ( lhs , rhs ) result ( is_it ) !< Not equal to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = '  one ' !< acharacter = 'three' !< test_passed(1) = ((acharacter/=astring).eqv..true.) !< astring = 'the same ' !< acharacter = 'the same ' !< test_passed(2) = ((acharacter/=astring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = rhs % raw /= lhs endfunction character_ne_string elemental function string_lt_string ( lhs , rhs ) result ( is_it ) !< Lower than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring<anotherstring).eqv..false.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring<anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw < rhs % raw endfunction string_lt_string elemental function string_lt_character ( lhs , rhs ) result ( is_it ) !< Lower than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring<acharacter).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring<acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw < rhs endfunction string_lt_character elemental function character_lt_string ( lhs , rhs ) result ( is_it ) !< Lower than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter<astring).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter<astring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs < rhs % raw endfunction character_lt_string elemental function string_le_string ( lhs , rhs ) result ( is_it ) !< Lower equal than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(3) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring<=anotherstring).eqv..false.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring<=anotherstring).eqv..true.) !< astring = 'ONE' !< anotherstring = 'ONE' !< test_passed(3) = ((astring<=anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw <= rhs % raw endfunction string_le_string elemental function string_le_character ( lhs , rhs ) result ( is_it ) !< Lower equal than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring<=acharacter).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring<=acharacter).eqv..true.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((astring<=acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw <= rhs endfunction string_le_character elemental function character_le_string ( lhs , rhs ) result ( is_it ) !< Lower equal than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter<=astring).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter<=astring).eqv..false.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((acharacter<=astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs <= rhs % raw endfunction character_le_string elemental function string_ge_string ( lhs , rhs ) result ( is_it ) !< Greater equal than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(3) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring>=anotherstring).eqv..true.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring>=anotherstring).eqv..false.) !< astring = 'ONE' !< anotherstring = 'ONE' !< test_passed(3) = ((astring>=anotherstring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw >= rhs % raw endfunction string_ge_string elemental function string_ge_character ( lhs , rhs ) result ( is_it ) !< Greater equal than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring>=acharacter).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring>=acharacter).eqv..false.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((astring>=acharacter).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw >= rhs endfunction string_ge_character elemental function character_ge_string ( lhs , rhs ) result ( is_it ) !< Greater equal than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(3) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter>=astring).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter>=astring).eqv..true.) !< astring = 'ONE' !< acharacter = 'ONE' !< test_passed(3) = ((acharacter>=astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs >= rhs % raw endfunction character_ge_string elemental function string_gt_string ( lhs , rhs ) result ( is_it ) !< Greater than to string logical operator. !< !<```fortran !< type(string) :: astring !< type(string) :: anotherstring !< logical      :: test_passed(2) !< astring = 'one' !< anotherstring = 'ONE' !< test_passed(1) = ((astring>anotherstring).eqv..true.) !< astring = 'ONE' !< anotherstring = 'one' !< test_passed(2) = ((astring>anotherstring).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw > rhs % raw endfunction string_gt_string elemental function string_gt_character ( lhs , rhs ) result ( is_it ) !< Greater than to character logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((astring>acharacter).eqv..true.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((astring>acharacter).eqv..false.) !< print '(L1)', all(test_passed) !<``` !=> T <<< class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs % raw > rhs endfunction string_gt_character elemental function character_gt_string ( lhs , rhs ) result ( is_it ) !< Greater than to character (inverted) logical operator. !< !<```fortran !< type(string)                  :: astring !< character(len=:), allocatable :: acharacter !< logical                       :: test_passed(2) !< astring = 'one' !< acharacter = 'ONE' !< test_passed(1) = ((acharacter>astring).eqv..false.) !< astring = 'ONE' !< acharacter = 'one' !< test_passed(2) = ((acharacter>astring).eqv..true.) !< print '(L1)', all(test_passed) !<``` !=> T <<< character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. is_it = lhs > rhs % raw endfunction character_gt_string ! IO subroutine read_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !< !< @bug Read listdirected with and without delimiters does not work. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. character ( kind = CK , len = 1 ) :: delim !< String delimiter, if any. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. if ( iotype == 'LISTDIRECTED' ) then call get_next_non_blank_character_any_record ( unit = unit , ch = delim , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return if ( delim == '\"' . OR . delim == \"'\" ) then call dtv % read_delimited ( unit = unit , delim = delim , iostat = iostat , iomsg = local_iomsg ) else ! step back before the non-blank read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited_listdirected ( unit = unit , iostat = iostat , iomsg = local_iomsg ) endif if ( is_iostat_eor ( iostat )) then ! suppress IOSTAT_EOR iostat = 0 elseif ( iostat /= 0 ) then iomsg = local_iomsg endif return else read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endif endsubroutine read_formatted subroutine read_delimited ( dtv , unit , delim , iostat , iomsg ) !< Read a delimited string from a unit connected for formatted input. !< !< If the closing delimiter is followed by end of record, then we return end of record. !< !< @note This does not need a doctest, it being tested by [[string::read_formatted]]. class ( string ), intent ( out ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( in ) :: delim !< String delimiter. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. logical :: was_delim !< Indicates that the last character read was a delimiter. was_delim = . false . dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then if ( was_delim ) then ! end of delimited string followed by end of record is end of the string. Pass back the ! end of record condition to the caller return else ! end of record without terminating delimiter - move along cycle endif elseif ( iostat /= 0 ) THEN return endif if ( ch == delim ) then if ( was_delim ) then ! doubled delimiter is one delimiter in the value dtv % raw = dtv % raw // ch was_delim = . false . else ! need to test next character to see what is happening was_delim = . true . endif elseif ( was_delim ) then ! the previous character was actually the delimiter for the end of the string. Put back this character read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) return else dtv % raw = dtv % raw // ch endif enddo endsubroutine read_delimited subroutine read_undelimited_listdirected ( dtv , unit , iostat , iomsg ) !< Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. !< !< A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. !< !< If input is terminated by end of record, then this procedure returns an end-of-record condition. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. logical :: decimal_point !<True if DECIMAL=POINT in effect. call get_decimal_mode ( unit = unit , decimal_point = decimal_point , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited ( unit = unit , terminators = ' ' // '/' // merge ( CK_ ',' , CK_ ';' , decimal_point ), iostat = iostat , iomsg = iomsg ) endsubroutine read_undelimited_listdirected subroutine read_undelimited ( dtv , unit , terminators , iostat , iomsg ) !< Read an undelimited string up until end of record or a character from a set of terminators is encountered. !< !< If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the !< file remains at end of record. class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: terminators !< Characters that are considered to terminate the string. !< Blanks in this string are meaningful. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then ! end of record just means end of string. We pass on the condition return elseif ( iostat /= 0 ) then ! something odd happened return endif if ( scan ( ch , terminators ) /= 0 ) then ! change the file position so that the next read sees the terminator read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return iostat = 0 return endif ! we got a character - append it dtv % raw = dtv % raw // ch enddo endsubroutine read_undelimited subroutine write_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !< Formatted output. class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif endsubroutine write_formatted subroutine read_unformatted ( dtv , unit , iostat , iomsg ) !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endsubroutine read_unformatted subroutine write_unformatted ( dtv , unit , iostat , iomsg ) !< Unformatted output. class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif endsubroutine write_unformatted ! miscellanea elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !< Return a string with the first occurrence of substring old replaced by new. !< !< @note The doctest is not necessary, this being tested by [[string:replace]]. class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif endif endif endfunction replace_one_occurrence ! non type-bound-procedures subroutine get_delimiter_mode ( unit , delim , iostat , iomsg ) !< Get the DELIM changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of NONE is always returned. use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit integer , intent ( in ) :: unit !< The unit for the connection. character ( len = 1 , kind = CK ), intent ( out ) :: delim !< Represents the value of the DELIM mode. integer , intent ( out ) :: iostat !< IOSTAT error code, non-zero on error. character ( * ), intent ( inout ) :: iomsg !< IOMSG explanatory message - only defined if iostat is non-zero. character ( 10 ) :: delim_buffer !< Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. ! get the string representation of the changeable mode inquire ( unit , delim = delim_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the DELIM mode for an internal file iostat = 0 delim = '' return elseif ( iostat /= 0 ) then iomsg = local_iomsg return endif ! interpret the DELIM string if ( delim_buffer == 'QUOTE' ) then delim = '\"' elseif ( delim_buffer == 'APOSTROPHE' ) then delim = '''' else delim = '\"' endif endsubroutine get_delimiter_mode subroutine get_next_non_blank_character_this_record ( unit , ch , iostat , iomsg ) !< Get the next non-blank character in the current record. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. do ! we spcify non-advancing, just in case we want this callable outside the context of a child input statement ! the PAD specifier simply saves the need for the READ statement to define ch if EOR is hit ! read(unit, \"(A)\", iostat=iostat, iomsg=iomsg, advance='NO') ch ! ...but that causes ifort to blow up at runtime read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg , pad = 'NO' ) ch if ( iostat /= 0 ) return if ( ch /= '' ) exit enddo endsubroutine get_next_non_blank_character_this_record subroutine get_next_non_blank_character_any_record ( unit , ch , iostat , iomsg ) !< Get the next non-blank character, advancing records if necessary. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. do call get_next_non_blank_character_this_record ( unit = unit , ch = ch , iostat = iostat , iomsg = local_iomsg ) if ( is_iostat_eor ( iostat )) then ! try again on the next record read ( unit , \"(/)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return elseif ( iostat /= 0 ) then ! some sort of problem iomsg = local_iomsg return else ! got it exit endif enddo endsubroutine get_next_non_blank_character_any_record subroutine get_decimal_mode ( unit , decimal_point , iostat , iomsg ) !< Get the DECIMAL changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the !< actual value in force at the time of the call to this procedure. use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit integer , intent ( in ) :: unit !< Logical unit. logical , intent ( out ) :: decimal_point !< True if the decimal mode is POINT, false otherwise. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( 5 ) :: decimal_buffer !< Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character ( len ( iomsg )) :: local_iomsg !< Local iomsg, so it doesn't get inappropriately redefined. inquire ( unit , decimal = decimal_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the decimal mode for an internal file iostat = 0 decimal_point = . true . return else if ( iostat /= 0 ) then iomsg = local_iomsg return endif decimal_point = decimal_buffer == 'POINT' endsubroutine get_decimal_mode endmodule stringifor_string_t","tags":"","loc":"sourcefile/stringifor_string_t.f90.html"}]}